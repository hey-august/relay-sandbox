{
  "version": 3,
  "sources": ["../src/index.ts", "../src/utils/constants.ts", "../src/utils/logger.ts", "../src/utils/common.ts", "../src/utils/index.ts", "../src/utils/parseRPCResponse.ts", "../src/utils/toExternalJSON.ts", "../src/utils/toInternalEventName.ts", "../src/utils/toInternalAction.ts", "../src/utils/toSnakeCaseKeys.ts", "../src/utils/extendComponent.ts", "../src/utils/debounce.ts", "../src/utils/SWCloseEvent.ts", "../src/utils/eventUtils.ts", "../src/RPCMessages/helpers.ts", "../src/RPCMessages/RPCConnect.ts", "../src/RPCMessages/RPCReauthenticate.ts", "../src/RPCMessages/RPCPing.ts", "../src/RPCMessages/RPCExecute.ts", "../src/RPCMessages/RPCDisconnect.ts", "../src/RPCMessages/VertoMessages.ts", "../src/redux/actions.ts", "../src/redux/toolkit/index.ts", "../src/redux/toolkit/createAction.ts", "../src/redux/toolkit/configureStore.ts", "../src/redux/toolkit/devtoolsExtension.ts", "../src/redux/toolkit/isPlainObject.ts", "../src/redux/toolkit/getDefaultMiddleware.ts", "../src/redux/toolkit/mapBuilders.ts", "../src/redux/toolkit/createReducer.ts", "../src/redux/toolkit/createSlice.ts", "../src/redux/utils/createDestroyableSlice.ts", "../src/redux/features/session/sessionSlice.ts", "../src/BaseSession.ts", "../src/BaseJWTSession.ts", "../src/redux/index.ts", "../src/redux/features/component/componentSlice.ts", "../src/redux/rootReducer.ts", "../src/redux/rootSaga.ts", "../src/redux/features/session/sessionSaga.ts", "../src/redux/utils/sagaHelpers.ts", "../src/CustomErrors.ts", "../src/redux/features/session/sessionSelectors.ts", "../src/redux/connect.ts", "../src/utils/EventEmitter.ts", "../src/redux/utils/useSession.ts", "../src/redux/utils/useInstanceMap.ts", "../src/workers/executeActionWorker.ts", "../src/BaseComponent.ts", "../src/BaseClient.ts", "../src/BaseConsumer.ts", "../src/redux/features/shared/namespace.ts", "../src/types/videoMember.ts", "../src/redux/features/component/componentSelectors.ts", "../src/rooms/index.ts", "../src/rooms/methods.ts", "../src/rooms/RoomSessionRecording.ts", "../src/rooms/RoomSessionPlayback.ts", "../src/rooms/RoomSessionStream.ts", "../src/chat/index.ts", "../src/chat/utils/toInternalChatChannels.ts", "../src/chat/utils/index.ts", "../src/chat/methods.ts", "../src/pubSub/index.ts", "../src/pubSub/workers/pubSubWorker.ts", "../src/pubSub/BasePubSub.ts", "../src/pubSub/PubSubMessage.ts", "../src/chat/workers/chatWorker.ts", "../src/chat/BaseChat.ts", "../src/chat/ChatMessage.ts", "../src/chat/ChatMember.ts", "../src/memberPosition/index.ts", "../src/memberPosition/workers.ts", "../src/testUtils.ts"],
  "sourcesContent": ["import {\n  uuid,\n  setLogger,\n  getLogger,\n  isGlobalEvent,\n  toExternalJSON,\n  fromSnakeToCamelCase,\n  toSnakeCaseKeys,\n  toLocalEvent,\n  toSyntheticEvent,\n  extendComponent,\n  validateEventsToSubscribe,\n  toInternalEventName,\n  toInternalAction,\n  timeoutPromise,\n  debounce,\n  SWCloseEvent,\n  isSATAuth,\n  LOCAL_EVENT_PREFIX,\n  stripNamespacePrefix,\n} from './utils'\nimport { WEBRTC_EVENT_TYPES, isWebrtcEventType } from './utils/common'\nimport { BaseSession } from './BaseSession'\nimport { BaseJWTSession } from './BaseJWTSession'\nimport { configureStore, connect } from './redux'\nimport { BaseClient } from './BaseClient'\nimport { BaseComponent } from './BaseComponent'\nimport { BaseConsumer } from './BaseConsumer'\nimport { EventEmitter, getEventEmitter } from './utils/EventEmitter'\nimport * as sessionSelectors from './redux/features/session/sessionSelectors'\nimport { findNamespaceInPayload } from './redux/features/shared/namespace'\nimport { GLOBAL_VIDEO_EVENTS } from './utils/constants'\nimport {\n  MEMBER_UPDATED_EVENTS,\n  INTERNAL_MEMBER_UPDATED_EVENTS,\n} from './types/videoMember'\n\nexport {\n  uuid,\n  setLogger,\n  getLogger,\n  BaseSession,\n  BaseJWTSession,\n  BaseComponent,\n  BaseConsumer,\n  BaseClient,\n  connect,\n  configureStore,\n  EventEmitter,\n  extendComponent,\n  validateEventsToSubscribe,\n  getEventEmitter,\n  isGlobalEvent,\n  toExternalJSON,\n  fromSnakeToCamelCase,\n  toSnakeCaseKeys,\n  toLocalEvent,\n  toInternalEventName,\n  toInternalAction,\n  toSyntheticEvent,\n  GLOBAL_VIDEO_EVENTS,\n  MEMBER_UPDATED_EVENTS,\n  INTERNAL_MEMBER_UPDATED_EVENTS,\n  findNamespaceInPayload,\n  timeoutPromise,\n  debounce,\n  SWCloseEvent,\n  WEBRTC_EVENT_TYPES,\n  isWebrtcEventType,\n  isSATAuth,\n  LOCAL_EVENT_PREFIX,\n  stripNamespacePrefix,\n}\n\nexport * from './redux/features/component/componentSlice'\nexport * from './redux/features/session/sessionSlice'\nexport * as componentSelectors from './redux/features/component/componentSelectors'\nexport * from './RPCMessages'\nexport * from './utils/interfaces'\nexport * from './types'\nexport * from './CustomErrors'\nexport type {\n  SessionState,\n  CustomSagaParams,\n  CustomSaga,\n  SwEventChannel,\n  PubSubAction,\n  MapToPubSubShape,\n  SDKActions,\n  ReduxComponent,\n} from './redux/interfaces'\nexport type { ToExternalJSONResult } from './utils'\nexport * as actions from './redux/actions'\nexport * as sagaHelpers from './redux/utils/sagaHelpers'\nexport * as sagaEffects from '@redux-saga/core/effects'\nexport type { SagaIterator, Task, Saga } from '@redux-saga/types'\nexport * as Rooms from './rooms'\nexport * as Chat from './chat'\nexport * as PubSub from './pubSub'\nexport * as MemberPosition from './memberPosition'\nexport type {\n  RoomSessionRecording,\n  RoomSessionPlayback,\n  RoomSessionStream,\n} from './rooms'\nexport const selectors = {\n  ...sessionSelectors,\n}\nexport { ChatMember, ChatMessage } from './chat'\nexport { PubSubMessage } from './pubSub'\nexport * as testUtils from './testUtils'\n", "export const STORAGE_PREFIX = '@signalwire:'\nexport const ADD = 'add'\nexport const REMOVE = 'remove'\nexport const SESSION_ID = 'sessId'\nexport const DEFAULT_HOST = 'wss://relay.signalwire.com'\n\nexport enum WebSocketState {\n  CONNECTING = 0,\n  OPEN = 1,\n  CLOSING = 2,\n  CLOSED = 3,\n}\n\n/**\n * Used for namespacing events.\n */\nexport const EVENT_NAMESPACE_DIVIDER = ':'\n\nexport const LOCAL_EVENT_PREFIX = '__local__'\nexport const SYNTHETIC_EVENT_PREFIX = '__synthetic__'\n\nexport const PRODUCT_PREFIX_VIDEO = 'video'\n/**\n * video-manager is an [internal] superset of the video apis\n */\nexport const PRODUCT_PREFIX_VIDEO_MANAGER = 'video-manager'\nexport const PRODUCT_PREFIX_CHAT = 'chat' as const\n/**\n * For now both, `PubSub` and `Chat` share the same\n * namespace but this might change in the future.\n */\nexport const PRODUCT_PREFIX_PUBSUB = 'chat' as const\nexport const PRODUCT_PREFIX_TASK = 'tasking'\nexport const PRODUCT_PREFIX_MESSAGING = 'messaging'\nexport const PRODUCT_PREFIX_VOICE = 'voice'\nexport const PRODUCT_PREFIX_VOICE_CALL = 'calling'\n\nexport const GLOBAL_VIDEO_EVENTS = ['room.started', 'room.ended'] as const\n\nexport const PRODUCT_PREFIXES = [\n  PRODUCT_PREFIX_VIDEO,\n  PRODUCT_PREFIX_VIDEO_MANAGER,\n  PRODUCT_PREFIX_CHAT,\n  PRODUCT_PREFIX_PUBSUB,\n  PRODUCT_PREFIX_TASK,\n  PRODUCT_PREFIX_MESSAGING,\n  PRODUCT_PREFIX_VOICE,\n  PRODUCT_PREFIX_VOICE_CALL,\n] as const\n\n/**\n * For internal usage only. These are the fully qualified event names\n * sent by the server\n * @internal\n */\nexport const INTERNAL_GLOBAL_VIDEO_EVENTS = GLOBAL_VIDEO_EVENTS.map(\n  (event) => `${PRODUCT_PREFIX_VIDEO}.${event}` as const\n)\n", "import log from 'loglevel'\nimport type {\n  SDKLogger,\n  InternalSDKLogger,\n  WsTrafficOptions,\n  UserOptions,\n} from '..'\n\nconst datetime = () => new Date().toISOString()\nconst defaultLogger = log.getLogger('signalwire')\n\nconst originalFactory = defaultLogger.methodFactory\ndefaultLogger.methodFactory = (methodName, logLevel, loggerName) => {\n  const rawMethod = originalFactory(methodName, logLevel, loggerName)\n\n  return function (...args: any[]) {\n    args.unshift(datetime(), '-')\n    rawMethod.apply(undefined, args)\n  }\n}\n\nconst defaultLoggerLevel =\n  // @ts-ignore\n  'development' === process.env.NODE_ENV\n    ? defaultLogger.levels.DEBUG\n    : defaultLogger.getLevel()\ndefaultLogger.setLevel(defaultLoggerLevel)\n\nlet userLogger: SDKLogger | null\nconst setLogger = (logger: SDKLogger | null) => {\n  userLogger = logger\n}\n\nlet debugOptions: UserOptions['debug'] = {}\nconst setDebugOptions = (options: any) => {\n  if (options == null) {\n    debugOptions = {}\n    return\n  }\n  Object.assign(debugOptions!, options)\n}\n\nconst getLoggerInstance = (): SDKLogger => {\n  return userLogger ?? (defaultLogger as any as SDKLogger)\n}\n\nconst shouldStringify = (payload: WsTrafficOptions['payload']) => {\n  if ('method' in payload && payload.method === 'signalwire.ping') {\n    return false\n  }\n\n  return true\n}\n\nconst wsTraffic: InternalSDKLogger['wsTraffic'] = ({ type, payload }) => {\n  const logger = getLoggerInstance()\n  const { logWsTraffic } = debugOptions || {}\n\n  if (!logWsTraffic) {\n    return undefined\n  }\n\n  const msg = shouldStringify(payload)\n    ? JSON.stringify(payload, null, 2)\n    : payload\n\n  return logger.info(`${type.toUpperCase()}: \\n`, msg, '\\n')\n}\n\nconst getLogger = (): InternalSDKLogger => {\n  const logger = getLoggerInstance()\n\n  return new Proxy(logger, {\n    get(target, prop: keyof InternalSDKLogger, receiver) {\n      if (prop === 'wsTraffic') {\n        return wsTraffic\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n  }) as InternalSDKLogger\n}\n\nexport { setLogger, getLogger, setDebugOptions }\n", "import { WebRTCEventType } from '..'\n\nconst UPPERCASE_REGEX = /[A-Z]/g\n/**\n * Converts values from camelCase to snake_case\n * @internal\n */\nexport const fromCamelToSnakeCase = <T>(event: T): T => {\n  // @ts-ignore\n  return event.replace(UPPERCASE_REGEX, (letter) => {\n    return `_${letter.toLowerCase()}`\n  }) as T\n}\n\nexport const WEBRTC_EVENT_TYPES: WebRTCEventType[] = [\n  'webrtc.message',\n  // 'webrtc.verto',\n]\nexport const isWebrtcEventType = (\n  eventType: string\n): eventType is WebRTCEventType => {\n  // @ts-expect-error\n  return WEBRTC_EVENT_TYPES.includes(eventType)\n}\n", "import {\n  Authorization,\n  JSONRPCRequest,\n  JSONRPCResponse,\n  SATAuthorization,\n} from '..'\nimport {\n  STORAGE_PREFIX,\n  GLOBAL_VIDEO_EVENTS,\n  INTERNAL_GLOBAL_VIDEO_EVENTS,\n  EVENT_NAMESPACE_DIVIDER,\n  LOCAL_EVENT_PREFIX,\n  SYNTHETIC_EVENT_PREFIX,\n} from './constants'\nexport { setLogger, getLogger, setDebugOptions } from './logger'\nexport { isWebrtcEventType, WEBRTC_EVENT_TYPES } from './common'\n\nexport { v4 as uuid } from 'uuid'\nexport * from './parseRPCResponse'\nexport * from './toExternalJSON'\nexport * from './toInternalEventName'\nexport * from './toInternalAction'\nexport * from './toSnakeCaseKeys'\nexport * from './extendComponent'\nexport * from './debounce'\nexport * from './SWCloseEvent'\nexport * from './eventUtils'\nexport { LOCAL_EVENT_PREFIX }\n\nexport const mutateStorageKey = (key: string) => `${STORAGE_PREFIX}${key}`\n\nexport const safeParseJson = <T>(value: T): T | Object => {\n  if (typeof value !== 'string') {\n    return value\n  }\n  try {\n    return JSON.parse(value)\n  } catch (error) {\n    return value\n  }\n}\n\nconst PROTOCOL_PATTERN = /^(ws|wss):\\/\\//\nexport const checkWebSocketHost = (host: string): string => {\n  const protocol = PROTOCOL_PATTERN.test(host) ? '' : 'wss://'\n  return `${protocol}${host}`\n}\n\nexport const timeoutPromise = <T = unknown>(\n  promise: Promise<T>,\n  time: number,\n  exception: any\n) => {\n  let timer: any = null\n  return Promise.race<T>([\n    promise,\n    new Promise(\n      (_resolve, reject) => (timer = setTimeout(reject, time, exception))\n    ),\n  ]).finally(() => clearTimeout(timer))\n}\n\n/** @internal */\nexport const isGlobalEvent = (event: string) => {\n  // @ts-ignore\n  return GLOBAL_VIDEO_EVENTS.includes(event)\n}\n\n/** @internal */\nexport const isInternalGlobalEvent = (event: string) => {\n  // @ts-ignore\n  return INTERNAL_GLOBAL_VIDEO_EVENTS.includes(event)\n}\n\nexport const isSyntheticEvent = (event: string) => {\n  return event.includes(SYNTHETIC_EVENT_PREFIX)\n}\n\nexport const isSessionEvent = (event: string) => {\n  return event.includes('session.')\n}\n\nexport const getGlobalEvents = (kind: 'all' | 'video' = 'all') => {\n  switch (kind) {\n    case 'video':\n      return GLOBAL_VIDEO_EVENTS\n    default:\n      // prettier-ignore\n      return [\n        ...GLOBAL_VIDEO_EVENTS,\n      ]\n  }\n}\n\nconst cleanupEventNamespace = (event: string) => {\n  const eventParts = event.split(EVENT_NAMESPACE_DIVIDER)\n  return eventParts[eventParts.length - 1]\n}\n\n/**\n * These events have derived events generated by the SDK\n * i.e. member.updated.audioMuted or member.talking.started\n */\nconst WITH_CUSTOM_EVENT_NAMES = [\n  'video.member.updated',\n  'video.member.talking',\n] as const\n\n/**\n * These events are generated by the SDK to make them\n * more \"user-friendly\" while others are client-side only\n * like the WebRTC ones: `track`/`active`/`destroy` for Call objects.\n */\nconst CLIENT_SIDE_EVENT_NAMES = [\n  'video.room.joined', // generated client-side\n  'video.track',\n  'video.active',\n  'video.answering',\n  'video.destroy',\n  'video.early',\n  'video.hangup',\n  'video.held',\n  'video.new',\n  'video.purge',\n  'video.recovering',\n  'video.requesting',\n  'video.ringing',\n  'video.trying',\n  'video.media.connected',\n  'video.media.reconnecting',\n  'video.media.disconnected',\n  'video.microphone.updated',\n  'video.camera.updated',\n  'video.speaker.updated',\n  'video.microphone.disconnected',\n  'video.camera.disconnected',\n  'video.speaker.disconnected',\n]\n/**\n * Check and filter the events the user attached returning only the valid ones\n * for the server.\n * IE: `member.updated.audioMuted` means `member.updated` for the server.\n * @internal\n */\nexport const validateEventsToSubscribe = <T = string>(events: T[]): T[] => {\n  const valid = events.map((internalEvent) => {\n    if (typeof internalEvent === 'string') {\n      const event = cleanupEventNamespace(internalEvent)\n      if (\n        CLIENT_SIDE_EVENT_NAMES.includes(event) ||\n        isSyntheticEvent(event) ||\n        isLocalEvent(event) ||\n        isSessionEvent(event)\n      ) {\n        return null\n      }\n      const found = WITH_CUSTOM_EVENT_NAMES.find((withCustomName) => {\n        return event.startsWith(withCustomName)\n      })\n      return found || event\n    }\n\n    return internalEvent\n  })\n\n  return Array.from(new Set(valid)).filter(Boolean) as T[]\n}\n\n/**\n * \"Local\" events are events controlled by the SDK and the\n * server has no knowledge about them.\n */\nexport const isLocalEvent = (event: string) => {\n  return event.includes(LOCAL_EVENT_PREFIX)\n}\n\nexport const toLocalEvent = <T extends string>(event: string): T => {\n  const eventParts = event.split('.')\n  const prefix = eventParts[0]\n\n  return event\n    .split('.')\n    .reduce((reducer, item) => {\n      reducer.push(item)\n\n      if (item === prefix) {\n        reducer.push(LOCAL_EVENT_PREFIX)\n      }\n\n      return reducer\n    }, [] as string[])\n    .join('.') as T\n}\n\nexport const toSyntheticEvent = <T extends string>(event: string): T => {\n  const eventParts = event.split('.')\n  const prefix = eventParts[0]\n\n  return event\n    .split('.')\n    .reduce((reducer, item) => {\n      reducer.push(item)\n\n      if (item === prefix) {\n        reducer.push(SYNTHETIC_EVENT_PREFIX)\n      }\n\n      return reducer\n    }, [] as string[])\n    .join('.') as T\n}\n\nexport const isJSONRPCRequest = (\n  e: JSONRPCRequest | JSONRPCResponse\n): e is JSONRPCRequest => {\n  return Boolean((e as JSONRPCRequest).method)\n}\n\nexport const isJSONRPCResponse = (\n  e: JSONRPCRequest | JSONRPCResponse\n): e is JSONRPCResponse => {\n  return !isJSONRPCRequest(e)\n}\n\nexport const isSATAuth = (e?: Authorization): e is SATAuthorization => {\n  return typeof e !== 'undefined' && 'jti' in e\n}\n", "import { JSONRPCRequest, JSONRPCResponse } from './interfaces'\n\ntype parseRPCResponseParams = {\n  response: JSONRPCResponse\n  request: JSONRPCRequest\n}\nexport const parseRPCResponse = ({\n  response,\n  request,\n}: parseRPCResponseParams) => {\n  const { result = {}, error } = response\n  if (error) {\n    return {\n      error,\n    }\n  }\n\n  switch (request.method) {\n    case 'signalwire.connect':\n      return { result }\n    default:\n      return parseResponse(response)\n  }\n}\n\nconst whitelistCodeRegex = /^2[0-9][0-9]$/\n\n/**\n * From the socket we can get:\n * - JSON-RPC msg with 1 level of 'result' or 'error'\n * - JSON-RPC msg with 2 nested 'result' and 'code' property to identify error\n * - JSON-RPC msg with 3 nested 'result' where the third level is the Verto JSON-RPC flat msg.\n *\n * @returns Object with error | result key to identify success or fail\n */\nconst parseResponse = (\n  response: JSONRPCResponse,\n  nodeId?: string\n): { [key: string]: any } => {\n  const { result = {}, error } = response\n  if (error) {\n    return { error }\n  }\n  const { code, node_id, result: nestedResult = null } = result\n  // Throw error if the code is not whitelisted (2xx)\n  if (code && !whitelistCodeRegex.test(code)) {\n    return { error: result }\n  }\n  if (nestedResult === null) {\n    if (nodeId) {\n      // Attach node_id to the nestedResult\n      result.node_id = nodeId\n    }\n    return { result }\n  }\n  if (nestedResult) {\n    if (nestedResult.jsonrpc) {\n      // This is a verto message\n      return parseResponse(nestedResult, node_id)\n    }\n    return { result: nestedResult }\n  }\n  return { result }\n}\n", "import { SnakeToCamelCase, ConverToExternalTypes } from '../types/utils'\n\nconst toDateObject = (timestamp?: number) => {\n  if (typeof timestamp === 'undefined') {\n    return timestamp\n  }\n\n  const date = new Date(timestamp * 1000)\n\n  /**\n   * If for some reason we can't convert to a valid date\n   * we'll return the original value\n   */\n  if (isNaN(date.getTime())) {\n    return timestamp\n  }\n\n  return date\n}\n\nconst DEFAULT_OPTIONS = {\n  /**\n   * Properties coming from the server where their value will be\n   * converted to camelCase\n   */\n  propsToUpdateValue: [\n    'updated',\n    'layers',\n    'members',\n    'recordings',\n    'playbacks',\n  ],\n}\n\n/**\n * Follows the same convention as `src/types/utils/IsTimestamp`\n */\nconst isTimestampProperty = (prop: string) => {\n  return prop.endsWith('At')\n}\n\nexport type ToExternalJSONResult<T> = {\n  [Property in NonNullable<keyof T> as SnakeToCamelCase<\n    Extract<Property, string>\n  >]: ConverToExternalTypes<Extract<Property, string>, T[Property]>\n}\n\n/**\n * Converts a record (a JSON coming from the server) to a JSON meant\n * to be consumed by our users. This mostly mean converting properties\n * from snake_case to camelCase along with some other minor case\n * convertions to guarantee that our JS users will always interact\n * with camelCase properties.\n *\n * It's worth noting that this util is suited exactly to meet our\n * needs and won't (propertly) handle cases where the input record\n * doesn't have all its properties with casing other than snake_case.\n * This is on purpose to keep this util as light and fast as possible\n * since we have the guarantee that the server will always send their\n * payloads formatted this way.\n * @internal\n */\nexport const toExternalJSON = <T>(\n  input: T,\n  options: typeof DEFAULT_OPTIONS = DEFAULT_OPTIONS\n) => {\n  // @ts-expect-error\n  if (input?.__sw_symbol || input?.__sw_proxy) {\n    // Return if the input is a BaseComponent or a Proxy\n    return input as unknown as ToExternalJSONResult<T>\n  }\n\n  return Object.entries(input).reduce((reducer, [key, value]) => {\n    const prop = fromSnakeToCamelCase(key) as any\n    const propType = typeof value\n\n    /**\n     * While this check won't be enough to detect all possible objects\n     * it would cover our needs here since we just need to detect that\n     * it's not a primitive value\n     */\n    if (propType === 'object' && value) {\n      if (Array.isArray(value)) {\n        if (options.propsToUpdateValue.includes(key)) {\n          reducer[prop] = value.map((v) => {\n            if (typeof v === 'string') {\n              return fromSnakeToCamelCase(v)\n            }\n            return toExternalJSON(v)\n          })\n        } else {\n          reducer[prop] = value\n        }\n      } else {\n        reducer[prop] = toExternalJSON(value as T)\n      }\n    } else {\n      if (isTimestampProperty(prop)) {\n        reducer[prop] = toDateObject(value)\n      } else {\n        reducer[prop] = value\n      }\n    }\n\n    return reducer\n  }, {} as Record<string, unknown>) as ToExternalJSONResult<T>\n}\n\n/**\n * Converts values from snake_case to camelCase\n * @internal\n */\nexport const fromSnakeToCamelCase = (input: string) => {\n  if (!input.includes('_')) {\n    return input\n  }\n  return input.split('_').reduce((reducer, part, index) => {\n    const fc = part.trim().charAt(0)\n    const remainingChars = part.substr(1).toLowerCase()\n\n    return `${reducer}${\n      index === 0 ? fc.toLowerCase() : fc.toUpperCase()\n    }${remainingChars}`\n  }, '')\n}\n", "import { fromCamelToSnakeCase } from './common'\nimport { EVENT_NAMESPACE_DIVIDER } from './constants'\nimport { EventEmitter } from './EventEmitter'\n\ntype ToInternalEventNameParams<\n  EventTypes extends EventEmitter.ValidEventTypes\n> = {\n  event: EventEmitter.EventNames<EventTypes>\n  namespace?: string\n}\n\nexport const toInternalEventName = <\n  EventTypes extends EventEmitter.ValidEventTypes\n>({\n  event,\n  namespace,\n}: ToInternalEventNameParams<EventTypes>) => {\n  // TODO: improve types of getNamespacedEvent and fromCamelToSnakeCase\n  if (typeof event === 'string') {\n    // other transforms here..\n    event = getNamespacedEvent({\n      event,\n      namespace,\n    }) as EventEmitter.EventNames<EventTypes>\n    event = fromCamelToSnakeCase<EventEmitter.EventNames<EventTypes>>(event)\n  }\n\n  return event\n}\n\nconst getNamespacedEvent = ({\n  namespace,\n  event,\n}: {\n  event: string\n  namespace?: string\n}) => {\n  /**\n   * If getNamespacedEvent is called with the `namespace` already\n   * present in the `event` or with a falsy namespace we'll return it\n   * as is\n   */\n  if (!namespace || event.startsWith(namespace)) {\n    return event\n  }\n\n  return `${namespace}${EVENT_NAMESPACE_DIVIDER}${event}`\n}\n", "import { JSONRPCRequest } from '..'\nimport { MapToPubSubShape } from '../redux/interfaces'\nimport { isWebrtcEventType } from './common'\n\nexport const toInternalAction = <\n  T extends { event_type: string; params?: unknown; node_id?: string }\n>(\n  event: T\n) => {\n  const { event_type, params, node_id } = event\n\n  /**\n   * queuing.relay.tasks has a slightly different shape:\n   * no nested \"params\" so we return the whole event.\n   */\n  if (event_type === 'queuing.relay.tasks') {\n    return {\n      type: event_type,\n      payload: event,\n    } as MapToPubSubShape<T>\n  }\n\n  /**\n   * `webrtc.*` events need to carry the node_id with them\n   */\n  if (isWebrtcEventType(event_type) && (params as JSONRPCRequest)?.jsonrpc) {\n    const vertoRPC = params as JSONRPCRequest\n    if (vertoRPC.params) {\n      vertoRPC.params.nodeId = node_id\n    }\n    return {\n      type: event_type,\n      payload: vertoRPC,\n    } as MapToPubSubShape<T>\n  }\n\n  return {\n    type: event_type,\n    payload: params,\n  } as MapToPubSubShape<T>\n}\n", "import { CamelToSnakeCase } from '../types/utils'\nimport { fromCamelToSnakeCase } from './common'\n\ntype ToSnakeCaseKeys<T> = {\n  [Property in NonNullable<keyof T> as CamelToSnakeCase<\n    Extract<Property, string>\n  >]: T[Property]\n}\n\nexport const toSnakeCaseKeys = <T extends Record<string, any>>(\n  obj: T,\n  transform: (value: string) => any = (value: string) => value,\n  result: Record<string, any> = {}\n) => {\n  if (Array.isArray(obj)) {\n    result = obj.map((item: any, index: number) => {\n      if (typeof item === 'object') {\n        return toSnakeCaseKeys(item, transform, result[index])\n      }\n      return item\n    })\n  } else {\n    Object.keys(obj).forEach((key) => {\n      const newKey = fromCamelToSnakeCase(key)\n      // Both 'object's and arrays will enter this branch\n      if (obj[key] && typeof obj[key] === 'object') {\n        result[newKey] = toSnakeCaseKeys(obj[key], transform, result[newKey])\n      } else {\n        result[newKey] = transform(obj[key])\n      }\n    })\n  }\n\n  return result as ToSnakeCaseKeys<T>\n}\n", "import type { APIMethodsMap } from './interfaces'\nimport type { ConstructableType } from '../types/utils'\n\nexport const extendComponent = <T, M>(\n  klass: any,\n  methods: APIMethodsMap<M>\n) => {\n  Object.keys(methods).forEach((methodName) => {\n    if (klass.prototype.hasOwnProperty(methodName)) {\n      throw new Error(`[extendComponent] Duplicated method name: ${methodName}`)\n    }\n  })\n\n  Object.defineProperties(klass.prototype, methods)\n\n  return klass as ConstructableType<T>\n}\n", "type ArgumentTypes<F extends Function> = F extends (...args: infer A) => any\n  ? A\n  : never\n\ntype MethodTypes = {\n  cancel: () => void\n  flush: () => void\n}\n\nexport function debounce<T extends Function>(\n  fn: T,\n  wait?: number,\n  callFirst?: false\n): ((...args: ArgumentTypes<T>) => void) & MethodTypes\n\nexport function debounce<T extends Function>(\n  fn: T,\n  wait: number = 0,\n  callFirst?: false\n) {\n  let timeout: NodeJS.Timeout | null = null\n  let debouncedFn: T | null = null\n\n  const clear = function () {\n    if (timeout) {\n      clearTimeout(timeout)\n\n      debouncedFn = null\n      timeout = null\n    }\n  }\n\n  const flush = function () {\n    const call = debouncedFn\n    clear()\n\n    if (call) {\n      call()\n    }\n  }\n\n  const debounceWrapper = function () {\n    if (!wait) {\n      // @ts-expect-error\n      return fn.apply(this, arguments)\n    }\n\n    // @ts-expect-error\n    const context = this\n    const args = arguments\n    const callNow = callFirst && !timeout\n    clear()\n\n    // @ts-expect-error\n    debouncedFn = function () {\n      fn.apply(context, args)\n    }\n\n    timeout = setTimeout(function () {\n      timeout = null\n\n      if (!callNow) {\n        const call = debouncedFn\n        debouncedFn = null\n\n        return call?.()\n      }\n    }, wait)\n\n    if (callNow && debouncedFn) {\n      return debouncedFn()\n    }\n  }\n\n  debounceWrapper.cancel = clear\n  debounceWrapper.flush = flush\n\n  return debounceWrapper\n}\n", "/**\n * Class representing a close event.\n * The `ws` package does not expose it so we can easily create one in here.\n *\n * @extends Event\n */\nexport class SWCloseEvent {\n  public code: number\n  public reason: string\n  public wasClean: boolean\n  constructor(\n    public type: string,\n    options: { code?: number; reason?: string; wasClean?: boolean } = {}\n  ) {\n    this.code = options.code === undefined ? 0 : options.code\n    this.reason = options.reason === undefined ? '' : options.reason\n    this.wasClean = options.wasClean === undefined ? false : options.wasClean\n  }\n}\n", "export const stripNamespacePrefix = (\n  event: string,\n  namespace?: string\n): string => {\n  if (namespace && typeof namespace === 'string') {\n    const regex = new RegExp(`^${namespace}\\.`)\n    return event.replace(regex, '')\n  }\n  const items = event.split('.')\n  if (items.length > 1) {\n    items.shift()\n    return items.join('.')\n  }\n  return event\n}\n", "import { uuid } from '../utils'\nimport { JSONRPCMethod } from '../utils/interfaces'\n\ninterface MakeRPCRequestParams {\n  id?: string\n  method: JSONRPCMethod\n  params: {\n    // TODO: use list of types?\n    [key: string]: any\n  }\n}\nexport const makeRPCRequest = (params: MakeRPCRequestParams) => {\n  return {\n    jsonrpc: '2.0' as const,\n    id: params.id ?? uuid(),\n    ...params,\n  }\n}\n\ninterface MakeRPCResponseParams {\n  id: string\n  result: {\n    // TODO: use list of types?\n    [key: string]: any\n  }\n}\nexport const makeRPCResponse = (params: MakeRPCResponseParams) => {\n  return {\n    jsonrpc: '2.0' as const,\n    ...params,\n  }\n}\n", "import { makeRPCRequest } from './helpers'\n\ntype WithToken = { token: string; jwt_token?: never }\ntype WithJWT = { token?: never; jwt_token: string }\ntype RPCConnectAuthentication = { project?: string } & (WithToken | WithJWT)\nexport type RPCConnectParams = {\n  authentication: RPCConnectAuthentication\n  version?: typeof DEFAULT_CONNECT_VERSION\n  agent?: string\n  protocol?: string\n  authorization_state?: string\n  contexts?: string[]\n  topics?: string[]\n}\n\nexport const DEFAULT_CONNECT_VERSION = {\n  major: 3,\n  minor: 0,\n  revision: 0,\n}\n\nexport const RPCConnect = (params: RPCConnectParams) => {\n  return makeRPCRequest({\n    method: 'signalwire.connect',\n    params: {\n      version: DEFAULT_CONNECT_VERSION,\n      ...params,\n    },\n  })\n}\n", "import { makeRPCRequest } from './helpers'\n\nexport type RPCReauthenticateParams = { project: string; jwt_token: string }\n\nexport const RPCReauthenticate = (authentication: RPCReauthenticateParams) => {\n  return makeRPCRequest({\n    method: 'signalwire.reauthenticate',\n    params: {\n      authentication,\n    },\n  })\n}\n", "import { makeRPCRequest, makeRPCResponse } from './helpers'\n\nexport const RPCPing = () => {\n  return makeRPCRequest({\n    method: 'signalwire.ping',\n    params: {\n      timestamp: Date.now() / 1000,\n    },\n  })\n}\n\nexport const RPCPingResponse = (id: string, timestamp?: number) => {\n  return makeRPCResponse({\n    id,\n    result: {\n      timestamp: timestamp || Date.now() / 1000,\n    },\n  })\n}\n", "import { makeRPCRequest } from './helpers'\nimport { JSONRPCMethod } from '../utils/interfaces'\n\ntype RPCExecuteParams = {\n  id?: string\n  method: JSONRPCMethod\n  params: Record<string, unknown>\n}\n\nexport const RPCExecute = ({ method, params }: RPCExecuteParams) => {\n  return makeRPCRequest({\n    method,\n    params,\n  })\n}\n", "import { makeRPCResponse } from './helpers'\n\nexport const RPCDisconnectResponse = (id: string) => {\n  return makeRPCResponse({\n    id,\n    result: {},\n  })\n}\n", "import { makeRPCRequest, makeRPCResponse } from './helpers'\nimport { VertoMethod } from '../utils/interfaces'\n\ntype VertoParams = { [key: string]: any }\n\nconst tmpMap: VertoParams = {\n  id: 'callID',\n  destinationNumber: 'destination_number',\n  remoteCallerName: 'remote_caller_id_name',\n  remoteCallerNumber: 'remote_caller_id_number',\n  callerName: 'caller_id_name',\n  callerNumber: 'caller_id_number',\n}\n\n/**\n * Translate SDK fields into verto variables\n */\nconst filterVertoParams = (params: VertoParams) => {\n  if (params.hasOwnProperty('dialogParams')) {\n    // prettier-ignore\n    const {\n      remoteSdp,\n      localStream,\n      remoteStream,\n      ...dialogParams\n    } = params.dialogParams\n    for (const key in tmpMap) {\n      if (key && dialogParams.hasOwnProperty(key)) {\n        // @ts-ignore\n        dialogParams[tmpMap[key]] = dialogParams[key]\n        delete dialogParams[key]\n      }\n    }\n    params.dialogParams = dialogParams\n  }\n\n  return params\n}\n\nconst buildVertoRPCMessage = (method: VertoMethod) => {\n  return (params: VertoParams = {}) => {\n    return makeRPCRequest({\n      method,\n      params: filterVertoParams(params),\n    })\n  }\n}\n\nexport const VertoInvite = buildVertoRPCMessage('verto.invite')\nexport const VertoBye = buildVertoRPCMessage('verto.bye')\nexport const VertoAttach = buildVertoRPCMessage('verto.attach')\nexport const VertoModify = buildVertoRPCMessage('verto.modify')\nexport const VertoInfo = buildVertoRPCMessage('verto.info')\nexport const VertoAnswer = buildVertoRPCMessage('verto.answer')\nexport const VertoSubscribe = buildVertoRPCMessage('verto.subscribe')\nexport const VertoPong = buildVertoRPCMessage('verto.pong')\nexport const VertoResult = (id: string, method: VertoMethod) => {\n  return makeRPCResponse({\n    id,\n    result: {\n      method,\n    },\n  })\n}\n", "import { createAction, Action } from './toolkit'\nimport type {\n  JSONRPCRequest,\n  SessionAuthError,\n  SessionEvents,\n  SessionActions,\n} from '../utils/interfaces'\n\nexport const initAction = createAction('swSdk/init')\nexport const destroyAction = createAction('swSdk/destroy')\n/**\n * Used to trigger a `signalwire.reauthenticate`\n */\nexport const reauthAction = createAction<{ token: string }>('swSdk/reauth')\n\nexport const authErrorAction = createAction<{ error: SessionAuthError }>(\n  'auth/error'\n)\nexport const authSuccessAction = createAction('auth/success')\nexport const authExpiringAction = createAction('auth/expiring')\n\nexport const socketMessageAction = createAction<JSONRPCRequest, string>(\n  'socket/message'\n)\n\nexport const sessionDisconnectedAction = createAction<void, SessionEvents>(\n  'session.disconnected'\n)\nexport const sessionReconnectingAction = createAction<void, SessionEvents>(\n  'session.reconnecting'\n)\nexport const sessionForceCloseAction = createAction<void, SessionActions>(\n  'session.forceClose'\n)\nconst formatCustomSagaAction = (id: string, action: Action) => {\n  return `${action.type}/${id}`\n}\n\nexport const makeCustomSagaAction = (id: string, action: Action) => {\n  return {\n    ...action,\n    type: formatCustomSagaAction(id, action),\n  }\n}\n\nexport const getCustomSagaActionType = (id: string, action: Action) => {\n  return formatCustomSagaAction(id, action)\n}\n\nexport { createAction }\n", "/**\n * Cherry-picked (and adapted) version of Redux Toolkit. API\n * wise it remains fully compatible but we changed a couple\n * of things to reduce the overall bundle size. Most\n * important is that our version doesn't depend on Immer and\n * we don't include any of the default middleares included\n * by RTK like thunks or inmutable state (we do this through\n * TS).\n */\nexport * from 'redux'\nexport * from './createAction'\nexport * from './configureStore'\n", "import type { Action } from 'redux'\nimport type {\n  IsUnknownOrNonInferrable,\n  IfMaybeUndefined,\n  IfVoid,\n  IsAny,\n} from './tsHelpers'\n\n\n/**\n * An action with a string type and an associated payload. This is the\n * type of action returned by `createAction()` action creators.\n *\n * @template P The type of the action's payload.\n * @template T the type used for the action type.\n * @template M The type of the action's meta (optional)\n * @template E The type of the action's error (optional)\n *\n * @public\n */\nexport type PayloadAction<\n  P = void,\n  T extends string = string,\n  M = never,\n  E = never\n> = {\n  payload: P\n  type: T\n} & ([M] extends [never]\n  ? {}\n  : {\n      meta: M\n    }) &\n  ([E] extends [never]\n    ? {}\n    : {\n        error: E\n      })\n\n/**\n * A \"prepare\" method to be used as the second parameter of `createAction`.\n * Takes any number of arguments and returns a Flux Standard Action without\n * type (will be added later) that *must* contain a payload (might be undefined).\n *\n * @public\n */\nexport type PrepareAction<P> =\n  | ((...args: any[]) => { payload: P })\n  | ((...args: any[]) => { payload: P; meta: any })\n  | ((...args: any[]) => { payload: P; error: any })\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\n\n/**\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\n *\n * @internal\n */\nexport type _ActionCreatorWithPreparedPayload<\n  PA extends PrepareAction<any> | void,\n  T extends string = string\n> = PA extends PrepareAction<infer P>\n  ? ActionCreatorWithPreparedPayload<\n      Parameters<PA>,\n      P,\n      T,\n      ReturnType<PA> extends {\n        error: infer E\n      }\n        ? E\n        : never,\n      ReturnType<PA> extends {\n        meta: infer M\n      }\n        ? M\n        : never\n    >\n  : void\n\n/**\n * Basic type for all action creators.\n *\n * @inheritdoc {redux#ActionCreator}\n */\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\n  type: T\n  match: (action: Action<unknown>) => action is PayloadAction<P, T, M, E>\n}\n\n/**\n * An action creator that takes multiple arguments that are passed\n * to a `PrepareAction` method to create the final Action.\n * @typeParam Args arguments for the action creator function\n * @typeParam P `payload` type\n * @typeParam T `type` name\n * @typeParam E optional `error` type\n * @typeParam M optional `meta` type\n *\n * @inheritdoc {redux#ActionCreator}\n *\n * @public\n */\nexport interface ActionCreatorWithPreparedPayload<\n  Args extends unknown[],\n  P,\n  T extends string = string,\n  E = never,\n  M = never\n> extends BaseActionCreator<P, T, M, E> {\n  /**\n   * Calling this {@link redux#ActionCreator} with `Args` will return\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\n   */\n  (...args: Args): PayloadAction<P, T, M, E>\n}\n\n/**\n * An action creator of type `T` that takes an optional payload of type `P`.\n *\n * @inheritdoc {redux#ActionCreator}\n *\n * @public\n */\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\n  extends BaseActionCreator<P, T> {\n  /**\n   * Calling this {@link redux#ActionCreator} with an argument will\n   * return a {@link PayloadAction} of type `T` with a payload of `P`.\n   * Calling it without an argument will return a PayloadAction with a payload of `undefined`.\n   */\n  (payload?: P): PayloadAction<P, T>\n}\n\n/**\n * An action creator of type `T` that takes no payload.\n *\n * @inheritdoc {redux#ActionCreator}\n *\n * @public\n */\nexport interface ActionCreatorWithoutPayload<T extends string = string>\n  extends BaseActionCreator<undefined, T> {\n  /**\n   * Calling this {@link redux#ActionCreator} will\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\n   */\n  (): PayloadAction<undefined, T>\n}\n\n/**\n * An action creator of type `T` that requires a payload of type P.\n *\n * @inheritdoc {redux#ActionCreator}\n *\n * @public\n */\nexport interface ActionCreatorWithPayload<P, T extends string = string>\n  extends BaseActionCreator<P, T> {\n  /**\n   * Calling this {@link redux#ActionCreator} with an argument will\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\n   */\n  (payload: P): PayloadAction<P, T>\n}\n\n/**\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\n *\n * @inheritdoc {redux#ActionCreator}\n *\n * @public\n */\nexport interface ActionCreatorWithNonInferrablePayload<\n  T extends string = string\n> extends BaseActionCreator<unknown, T> {\n  /**\n   * Calling this {@link redux#ActionCreator} with an argument will\n   * return a {@link PayloadAction} of type `T` with a payload\n   * of exactly the type of the argument.\n   */\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\n}\n\n/**\n * An action creator that produces actions with a `payload` attribute.\n *\n * @typeParam P the `payload` type\n * @typeParam T the `type` of the resulting action\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\n *\n * @public\n */\nexport type PayloadActionCreator<\n  P = void,\n  T extends string = string,\n  PA extends PrepareAction<P> | void = void\n> = IfPrepareActionMethodProvided<\n  PA,\n  _ActionCreatorWithPreparedPayload<PA, T>,\n  // else\n  IsAny<\n    P,\n    ActionCreatorWithPayload<any, T>,\n    IsUnknownOrNonInferrable<\n      P,\n      ActionCreatorWithNonInferrablePayload<T>,\n      // else\n      IfVoid<\n        P,\n        ActionCreatorWithoutPayload<T>,\n        // else\n        IfMaybeUndefined<\n          P,\n          ActionCreatorWithOptionalPayload<P, T>,\n          // else\n          ActionCreatorWithPayload<P, T>\n        >\n      >\n    >\n  >\n>\n\n/**\n * A utility function to create an action creator for the given action type\n * string. The action creator accepts a single argument, which will be included\n * in the action object as a field called payload. The action creator function\n * will also have its toString() overriden so that it returns the action type,\n * allowing it to be used in reducer logic that is looking for that action type.\n *\n * @param type The action type to use for created actions.\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\n *                If this is given, the resulting action creator will pass its arguments to this method to calculate payload & meta.\n *\n * @public\n */\nexport function createAction<P = void, T extends string = string>(\n  type: T\n): PayloadActionCreator<P, T>\n\n/**\n * A utility function to create an action creator for the given action type\n * string. The action creator accepts a single argument, which will be included\n * in the action object as a field called payload. The action creator function\n * will also have its toString() overriden so that it returns the action type,\n * allowing it to be used in reducer logic that is looking for that action type.\n *\n * @param type The action type to use for created actions.\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\n *                If this is given, the resulting action creator will pass its arguments to this method to calculate payload & meta.\n *\n * @public\n */\nexport function createAction<\n  PA extends PrepareAction<any>,\n  T extends string = string\n>(\n  type: T,\n  prepareAction: PA\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\n\nexport function createAction(type: string, prepareAction?: Function): any {\n  function actionCreator(...args: any[]) {\n    if (prepareAction) {\n      let prepared = prepareAction(...args)\n      if (!prepared) {\n        throw new Error('prepareAction did not return an object')\n      }\n\n      return {\n        type,\n        payload: prepared.payload,\n        ...('meta' in prepared && { meta: prepared.meta }),\n        ...('error' in prepared && { error: prepared.error }),\n      }\n    }\n    return { type, payload: args[0] }\n  }\n\n  actionCreator.toString = () => `${type}`\n\n  actionCreator.type = type\n\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\n    action.type === type\n\n  return actionCreator\n}\n\n// helper types for more readable typings\n\ntype IfPrepareActionMethodProvided<\n  PA extends PrepareAction<any> | void,\n  True,\n  False\n> = PA extends (...args: any[]) => any ? True : False\n", "import type {\n  Reducer,\n  ReducersMapObject,\n  Middleware,\n  Action,\n  AnyAction,\n  StoreEnhancer,\n  Store,\n  Dispatch,\n  PreloadedState,\n  CombinedState,\n} from 'redux'\nimport { createStore, compose, applyMiddleware, combineReducers } from 'redux'\nimport type { EnhancerOptions as DevToolsOptions } from './devtoolsExtension'\nimport { composeWithDevTools } from './devtoolsExtension'\n\nimport isPlainObject from './isPlainObject'\nimport {\n  CurriedGetDefaultMiddleware,\n  curryGetDefaultMiddleware,\n} from './getDefaultMiddleware'\nimport type { DispatchForMiddlewares, NoInfer } from './tsHelpers'\n\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\n\n/**\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\n *\n * @public\n */\nexport type ConfigureEnhancersCallback = (\n  defaultEnhancers: readonly StoreEnhancer[]\n) => StoreEnhancer[]\n\n/**\n * Options for `configureStore()`.\n *\n * @public\n */\nexport interface ConfigureStoreOptions<\n  S = any,\n  A extends Action = AnyAction,\n  M extends Middlewares<S> = Middlewares<S>\n> {\n  /**\n   * A single reducer function that will be used as the root reducer, or an\n   * object of slice reducers that will be passed to `combineReducers()`.\n   */\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\n\n  /**\n   * An array of Redux middleware to install. If not supplied, defaults to\n   * the set of middleware returned by `getDefaultMiddleware()`.\n   */\n  middleware?: ((getDefaultMiddleware: CurriedGetDefaultMiddleware<S>) => M) | M\n\n  /**\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\n   *\n   * Additional configuration can be done by passing Redux DevTools options\n   */\n  devTools?: boolean | DevToolsOptions\n\n  /**\n   * The initial state, same as Redux's createStore.\n   * You may optionally specify it to hydrate the state\n   * from the server in universal apps, or to restore a previously serialized\n   * user session. If you use `combineReducers()` to produce the root reducer\n   * function (either directly or indirectly by passing an object as `reducer`),\n   * this must be an object with the same shape as the reducer map keys.\n   */\n  /*\n  Not 100% correct but the best approximation we can get:\n  - if S is a `CombinedState` applying a second `CombinedState` on it does not change anything.\n  - if it is not, there could be two cases:\n    - `ReducersMapObject<S, A>` is being passed in. In this case, we will call `combineReducers` on it and `CombinedState<S>` is correct\n    - `Reducer<S, A>` is being passed in. In this case, actually `CombinedState<S>` is wrong and `S` would be correct.\n    As we cannot distinguish between those two cases without adding another generic paramter,\n    we just make the pragmatic assumption that the latter almost never happens.\n  */\n  preloadedState?: PreloadedState<CombinedState<NoInfer<S>>>\n\n  /**\n   * The store enhancers to apply. See Redux's `createStore()`.\n   * All enhancers will be included before the DevTools Extension enhancer.\n   * If you need to customize the order of enhancers, supply a callback\n   * function that will receive the original array (ie, `[applyMiddleware]`),\n   * and should return a new array (such as `[applyMiddleware, offline]`).\n   * If you only need to add middleware, you can use the `middleware` parameter instead.\n   */\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\n}\n\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\n\n/**\n * A Redux store returned by `configureStore()`. Supports dispatching\n * side-effectful _thunks_ in addition to plain actions.\n *\n * @public\n */\nexport interface EnhancedStore<\n  S = any,\n  A extends Action = AnyAction,\n  M extends Middlewares<S> = Middlewares<S>\n> extends Store<S, A> {\n  /**\n   * The `dispatch` method of your store, enhanced by all its middlewares.\n   *\n   * @inheritdoc\n   */\n  dispatch: Dispatch<A> & DispatchForMiddlewares<M>\n}\n\n/**\n * A friendly abstraction over the standard Redux `createStore()` function.\n *\n * @param config The store configuration.\n * @returns A configured Redux store.\n *\n * @public\n */\nexport function configureStore<\n  S = any,\n  A extends Action = AnyAction,\n  M extends Middlewares<S> = []\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\n  const curriedGetDefaultMiddleware = curryGetDefaultMiddleware<S>()\n\n  const {\n    reducer = undefined,\n    middleware = curriedGetDefaultMiddleware(),\n    devTools = true,\n    preloadedState = undefined,\n    enhancers = undefined,\n  } = options || {}\n\n  let rootReducer: Reducer<S, A>\n\n  if (typeof reducer === 'function') {\n    rootReducer = reducer\n  } else if (isPlainObject(reducer)) {\n    rootReducer = combineReducers(reducer)\n  } else {\n    throw new Error(\n      '\"reducer\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\n    )\n  }\n\n  let finalMiddleware = middleware\n  if (typeof finalMiddleware === 'function') {\n    finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware)\n\n    if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {\n      throw new Error(\n        'when using a middleware builder function, an array of middleware must be returned'\n      )\n    }\n  }\n  if (\n    !IS_PRODUCTION &&\n    finalMiddleware.some((item) => typeof item !== 'function')\n  ) {\n    throw new Error(\n      'each middleware provided to configureStore must be a function'\n    )\n  }\n\n  const middlewareEnhancer = applyMiddleware(...finalMiddleware)\n\n  let finalCompose = compose\n\n  if (devTools) {\n    finalCompose = composeWithDevTools({\n      // Enable capture of stack traces for dispatched Redux actions\n      trace: !IS_PRODUCTION,\n      ...(typeof devTools === 'object' && devTools),\n    })\n  }\n\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\n\n  if (Array.isArray(enhancers)) {\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\n  } else if (typeof enhancers === 'function') {\n    storeEnhancers = enhancers(storeEnhancers)\n  }\n\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\n\n  return createStore(rootReducer, preloadedState, composedEnhancer)\n}\n", "import type { Action, ActionCreator, StoreEnhancer } from 'redux'\nimport { compose } from 'redux'\n\n/**\n * @public\n */\nexport interface EnhancerOptions {\n  /**\n   * the instance name to be showed on the monitor page. Default value is `document.title`.\n   * If not specified and there's no document title, it will consist of `tabId` and `instanceId`.\n   */\n  name?: string\n  /**\n   * action creators functions to be available in the Dispatcher.\n   */\n  actionCreators?: ActionCreator<any>[] | { [key: string]: ActionCreator<any> }\n  /**\n   * if more than one action is dispatched in the indicated interval, all new actions will be collected and sent at once.\n   * It is the joint between performance and speed. When set to `0`, all actions will be sent instantly.\n   * Set it to a higher value when experiencing perf issues (also `maxAge` to a lower value).\n   *\n   * @default 500 ms.\n   */\n  latency?: number\n  /**\n   * (> 1) - maximum allowed actions to be stored in the history tree. The oldest actions are removed once maxAge is reached. It's critical for performance.\n   *\n   * @default 50\n   */\n  maxAge?: number\n  /**\n   * See detailed documentation at http://extension.remotedev.io/docs/API/Arguments.html#serialize\n   */\n  serialize?:\n    | boolean\n    | {\n        options?:\n          | boolean\n          | {\n              date?: boolean\n              regex?: boolean\n              undefined?: boolean\n              error?: boolean\n              symbol?: boolean\n              map?: boolean\n              set?: boolean\n              function?: boolean | Function\n            }\n        replacer?: (key: string, value: unknown) => unknown\n        reviver?: (key: string, value: unknown) => unknown\n        immutable?: unknown\n        refs?: unknown[]\n      }\n  /**\n   * function which takes `action` object and id number as arguments, and should return `action` object back.\n   */\n  actionSanitizer?: <A extends Action>(action: A, id: number) => A\n  /**\n   * function which takes `state` object and index as arguments, and should return `state` object back.\n   */\n  stateSanitizer?: <S>(state: S, index: number) => S\n  /**\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\n   */\n  actionsBlacklist?: string | string[]\n  /**\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\n   */\n  actionsWhitelist?: string | string[]\n  /**\n   * called for every action before sending, takes `state` and `action` object, and returns `true` in case it allows sending the current data to the monitor.\n   * Use it as a more advanced version of `actionsBlacklist`/`actionsWhitelist` parameters.\n   */\n  predicate?: <S, A extends Action>(state: S, action: A) => boolean\n  /**\n   * if specified as `false`, it will not record the changes till clicking on `Start recording` button.\n   * Available only for Redux enhancer, for others use `autoPause`.\n   *\n   * @default true\n   */\n  shouldRecordChanges?: boolean\n  /**\n   * if specified, whenever clicking on `Pause recording` button and there are actions in the history log, will add this action type.\n   * If not specified, will commit when paused. Available only for Redux enhancer.\n   *\n   * @default \"@@PAUSED\"\"\n   */\n  pauseActionType?: string\n  /**\n   * auto pauses when the extension\u2019s window is not opened, and so has zero impact on your app when not in use.\n   * Not available for Redux enhancer (as it already does it but storing the data to be sent).\n   *\n   * @default false\n   */\n  autoPause?: boolean\n  /**\n   * if specified as `true`, it will not allow any non-monitor actions to be dispatched till clicking on `Unlock changes` button.\n   * Available only for Redux enhancer.\n   *\n   * @default false\n   */\n  shouldStartLocked?: boolean\n  /**\n   * if set to `false`, will not recompute the states on hot reloading (or on replacing the reducers). Available only for Redux enhancer.\n   *\n   * @default true\n   */\n  shouldHotReload?: boolean\n  /**\n   * if specified as `true`, whenever there's an exception in reducers, the monitors will show the error message, and next actions will not be dispatched.\n   *\n   * @default false\n   */\n  shouldCatchErrors?: boolean\n  /**\n   * If you want to restrict the extension, specify the features you allow.\n   * If not specified, all of the features are enabled. When set as an object, only those included as `true` will be allowed.\n   * Note that except `true`/`false`, `import` and `export` can be set as `custom` (which is by default for Redux enhancer), meaning that the importing/exporting occurs on the client side.\n   * Otherwise, you'll get/set the data right from the monitor part.\n   */\n  features?: {\n    /**\n     * start/pause recording of dispatched actions\n     */\n    pause?: boolean\n    /**\n     * lock/unlock dispatching actions and side effects\n     */\n    lock?: boolean\n    /**\n     * persist states on page reloading\n     */\n    persist?: boolean\n    /**\n     * export history of actions in a file\n     */\n    export?: boolean | 'custom'\n    /**\n     * import history of actions from a file\n     */\n    import?: boolean | 'custom'\n    /**\n     * jump back and forth (time travelling)\n     */\n    jump?: boolean\n    /**\n     * skip (cancel) actions\n     */\n    skip?: boolean\n    /**\n     * drag and drop actions in the history list\n     */\n    reorder?: boolean\n    /**\n     * dispatch custom actions or action creators\n     */\n    dispatch?: boolean\n    /**\n     * generate tests for the selected actions\n     */\n    test?: boolean\n  }\n  /**\n   * Set to true or a stacktrace-returning function to record call stack traces for dispatched actions.\n   * Defaults to false.\n   */\n  trace?: boolean | (<A extends Action>(action: A) => string)\n  /**\n   * The maximum number of stack trace entries to record per action. Defaults to 10.\n   */\n  traceLimit?: number\n}\n\n/**\n * @public\n */\nexport const composeWithDevTools: {\n  (options: EnhancerOptions): typeof compose\n  <StoreExt>(...funcs: Array<StoreEnhancer<StoreExt>>): StoreEnhancer<StoreExt>\n} =\n  typeof window !== 'undefined' &&\n  (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\n    : function () {\n        if (arguments.length === 0) return undefined\n        if (typeof arguments[0] === 'object') return compose\n        return compose.apply(null, arguments as any as Function[])\n      }\n\n/**\n * @public\n */\nexport const devToolsEnhancer: {\n  (options: EnhancerOptions): StoreEnhancer<any>\n} =\n  typeof window !== 'undefined' && (window as any).__REDUX_DEVTOOLS_EXTENSION__\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION__\n    : function () {\n        return function (noop) {\n          return noop\n        }\n      }\n", "/**\n * Returns true if the passed value is \"plain\" object, i.e. an object whose\n * prototype is the root `Object.prototype`. This includes objects created\n * using object literals, but not for instance for class instances.\n *\n * @param {any} value The value to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n *\n * @public\n */\nexport default function isPlainObject(value: unknown): value is object {\n  if (typeof value !== 'object' || value === null) return false\n\n  let proto = Object.getPrototypeOf(value)\n  if (proto === null) return true\n\n  let baseProto = proto\n  while (Object.getPrototypeOf(baseProto) !== null) {\n    baseProto = Object.getPrototypeOf(baseProto)\n  }\n\n  return proto === baseProto\n}\n", "import { Middleware } from 'redux'\nimport { MiddlewareArray } from './utils'\n\ninterface GetDefaultMiddlewareOptions {}\n\nexport type CurriedGetDefaultMiddleware<S = any> = <\n  O extends Partial<GetDefaultMiddlewareOptions> = {\n    thunk: true\n    immutableCheck: true\n    serializableCheck: true\n  }\n>(\n  options?: O\n) => MiddlewareArray<Middleware<{}, S>>\n\nexport function curryGetDefaultMiddleware<\n  S = any\n>(): CurriedGetDefaultMiddleware<S> {\n  return function curriedGetDefaultMiddleware() {\n    return [] as unknown as MiddlewareArray<Middleware<{}, S>>\n  }\n}\n", "import { Action, AnyAction } from \"redux\"\nimport { CaseReducer } from \"./createReducer\"\nimport { ActionMatcher, ActionMatcherDescriptionCollection, CaseReducers } from \"./createReducer\"\n\nexport interface TypedActionCreator<Type extends string> {\n  (...args: any[]): Action<Type>\n  type: Type\n}\n\n/**\n * A builder for an action <-> reducer map.\n *\n * @public\n */\n export interface ActionReducerMapBuilder<State> {\n  /**\n   * Adds a case reducer to handle a single exact action type.\n   * @remarks\n   * All calls to `builder.addCase` must come before any calls to `builder.addMatcher` or `builder.addDefaultCase`.\n   * @param actionCreator - Either a plain action type string, or an action creator generated by [`createAction`](./createAction) that can be used to determine the action type.\n   * @param reducer - The actual case reducer function.\n   */\n  addCase<ActionCreator extends TypedActionCreator<string>>(\n    actionCreator: ActionCreator,\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\n  ): ActionReducerMapBuilder<State>\n  /**\n   * Adds a case reducer to handle a single exact action type.\n   * @remarks\n   * All calls to `builder.addCase` must come before any calls to `builder.addMatcher` or `builder.addDefaultCase`.\n   * @param actionCreator - Either a plain action type string, or an action creator generated by [`createAction`](./createAction) that can be used to determine the action type.\n   * @param reducer - The actual case reducer function.\n   */\n  addCase<Type extends string, A extends Action<Type>>(\n    type: Type,\n    reducer: CaseReducer<State, A>\n  ): ActionReducerMapBuilder<State>\n\n  addMatcher<A extends AnyAction>(\n    matcher: ActionMatcher<A> | ((action: AnyAction) => boolean),\n    reducer: CaseReducer<State, A>\n  ): Omit<ActionReducerMapBuilder<State>, 'addCase'>\n\n  addDefaultCase(reducer: CaseReducer<State, AnyAction>): {}\n}\n\nexport function executeReducerBuilderCallback<S>(\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\n): [\n  CaseReducers<S, any>,\n  ActionMatcherDescriptionCollection<S>,\n  CaseReducer<S, AnyAction> | undefined\n] {\n  const actionsMap: CaseReducers<S, any> = {}\n  const actionMatchers: ActionMatcherDescriptionCollection<S> = []\n  let defaultCaseReducer: CaseReducer<S, AnyAction> | undefined\n  const builder = {\n    addCase(\n      typeOrActionCreator: string | TypedActionCreator<any>,\n      reducer: CaseReducer<S>\n    ) {\n      if (process.env.NODE_ENV !== 'production') {\n        /*\n         to keep the definition by the user in line with actual behavior,\n         we enforce `addCase` to always be called before calling `addMatcher`\n         as matching cases take precedence over matchers\n         */\n        if (actionMatchers.length > 0) {\n          throw new Error(\n            '`builder.addCase` should only be called before calling `builder.addMatcher`'\n          )\n        }\n        if (defaultCaseReducer) {\n          throw new Error(\n            '`builder.addCase` should only be called before calling `builder.addDefaultCase`'\n          )\n        }\n      }\n      const type =\n        typeof typeOrActionCreator === 'string'\n          ? typeOrActionCreator\n          : typeOrActionCreator.type\n      if (type in actionsMap) {\n        throw new Error(\n          'addCase cannot be called with two reducers for the same action type'\n        )\n      }\n      actionsMap[type] = reducer\n      return builder\n    },\n    addMatcher<A extends AnyAction>(\n      matcher: ActionMatcher<A>,\n      reducer: CaseReducer<S, A>\n    ) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (defaultCaseReducer) {\n          throw new Error(\n            '`builder.addMatcher` should only be called before calling `builder.addDefaultCase`'\n          )\n        }\n      }\n      actionMatchers.push({ matcher, reducer })\n      return builder\n    },\n    addDefaultCase(reducer: CaseReducer<S, AnyAction>) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (defaultCaseReducer) {\n          throw new Error('`builder.addDefaultCase` can only be called once')\n        }\n      }\n      defaultCaseReducer = reducer\n      return builder\n    },\n  }\n  builderCallback(builder)\n  return [actionsMap, actionMatchers, defaultCaseReducer]\n}\n", "import { Action, AnyAction, Reducer } from 'redux'\nimport { DeepReadonly } from '../../types'\nimport { ActionReducerMapBuilder, executeReducerBuilderCallback } from './mapBuilders'\nimport { NoInfer } from './tsHelpers'\n\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\n  state: S,\n  action: A\n) => S | void\n\nexport interface ActionMatcher<A extends AnyAction> {\n  (action: AnyAction): action is A\n}\n\n/**\n * Defines a mapping from action types to corresponding action object shapes.\n *\n * @deprecated This should not be used manually - it is only used for internal\n *             inference purposes and should not have any further value.\n *             It might be removed in the future.\n * @public\n */\nexport type Actions<T extends keyof any = string> = Record<T, Action>\n\n/**\n * A mapping from action types to case reducers for `createReducer()`.\n *\n * @deprecated This should not be used manually - it is only used\n *             for internal inference purposes and using it manually\n *             would lead to type erasure.\n *             It might be removed in the future.\n * @public\n */\nexport type CaseReducers<S, AS extends Actions> = {\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\n}\n\nexport type ActionMatcherDescription<S, A extends AnyAction> = {\n  matcher: ActionMatcher<A>\n  reducer: CaseReducer<S, NoInfer<A>>\n}\n\nexport type ActionMatcherDescriptionCollection<S> = Array<\n  ActionMatcherDescription<S, any>\n>\n\n\nexport type NotFunction<T> = T extends Function ? never : T\n\nexport type ReducerWithInitialState<S extends NotFunction<any>> = Reducer<DeepReadonly<S>> & {\n  getInitialState: () => DeepReadonly<S>\n}\n\nexport type ReadonlyActionMatcherDescriptionCollection<S> = ReadonlyArray<\n  ActionMatcherDescription<S, any>\n>\n\nfunction isStateFunction<S>(x: unknown): x is () => S {\n  return typeof x === 'function'\n}\n\nexport function createReducer<S extends NotFunction<any>>(\n  initialState: S | (() => S),\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\n): ReducerWithInitialState<S>\n\nexport function createReducer<\n  S extends NotFunction<any>,\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\n>(\n  initialState: S | (() => S),\n  actionsMap: CR,\n  actionMatchers?: ActionMatcherDescriptionCollection<S>,\n  defaultCaseReducer?: CaseReducer<S>\n): ReducerWithInitialState<S>\n\nexport function createReducer<S extends NotFunction<any>>(\n  initialState: S | (() => S),\n  mapOrBuilderCallback:\n    | CaseReducers<S, any>\n    | ((builder: ActionReducerMapBuilder<S>) => void),\n  actionMatchers: ReadonlyActionMatcherDescriptionCollection<S> = [],\n  defaultCaseReducer?: CaseReducer<S>\n): ReducerWithInitialState<S> {\n  let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] =\n    typeof mapOrBuilderCallback === 'function'\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\n      : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer]\n\n  // Ensure the initial state gets frozen either way\n  let getInitialState: () => S\n  if (isStateFunction(initialState)) {\n    getInitialState = () => initialState()\n  } else {\n    getInitialState = () => initialState\n  }\n\n  function reducer(state = getInitialState(), action: any): S {\n    let caseReducers = [\n      actionsMap[action.type],\n      ...finalActionMatchers\n        .filter(({ matcher }) => matcher(action))\n        .map(({ reducer }) => reducer),\n    ]\n    if (caseReducers.filter((cr) => !!cr).length === 0) {\n      caseReducers = [finalDefaultCaseReducer]\n    }\n\n    return caseReducers.reduce((previousState, caseReducer): S => {\n      if (caseReducer) {\n        return caseReducer(previousState, action) as S\n      }\n\n      return previousState\n    }, state)\n  }\n\n  reducer.getInitialState = getInitialState\n\n  return reducer as ReducerWithInitialState<S>\n}\n", "import type { Reducer } from 'redux'\nimport {\n  ActionCreatorWithoutPayload,\n  createAction,\n  PayloadAction,\n  PrepareAction,\n  _ActionCreatorWithPreparedPayload,\n} from '.'\nimport { DeepReadonly } from '../../types'\nimport { PayloadActionCreator } from './createAction'\nimport {\n  CaseReducer,\n  CaseReducers,\n  createReducer,\n  ReducerWithInitialState,\n} from './createReducer'\nimport {\n  ActionReducerMapBuilder,\n  executeReducerBuilderCallback,\n} from './mapBuilders'\nimport { NoInfer } from './tsHelpers'\n\n/**\n * An action creator attached to a slice.\n *\n * @deprecated please use PayloadActionCreator directly\n *\n * @public\n */\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\n\n/**\n * The return value of `createSlice`\n *\n * @public\n */\nexport interface Slice<\n  State = any,\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\n  Name extends string = string\n> {\n  /**\n   * The slice name.\n   */\n  name: Name\n\n  /**\n   * The slice's reducer.\n   */\n  reducer: Reducer<DeepReadonly<State>>\n\n  /**\n   * Action creators for the types of actions that are handled by the slice\n   * reducer.\n   */\n  actions: CaseReducerActions<CaseReducers>\n\n  /**\n   * The individual case reducer functions that were passed in the `reducers` parameter.\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\n   */\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\n\n  /**\n   * Provides access to the initial state value given to the slice.\n   * If a lazy state initializer was provided, it will be called and a fresh value returned.\n   */\n  getInitialState: () => DeepReadonly<State>\n}\n\n/**\n * Options for `createSlice()`.\n *\n * @public\n */\nexport interface CreateSliceOptions<\n  State = any,\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\n  Name extends string = string\n> {\n  name: Name\n  initialState: State | (() => State)\n  reducers: ValidateSliceCaseReducers<State, CR>\n  extraReducers?:\n    | CaseReducers<NoInfer<State>, any>\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\n}\n\n/**\n * A CaseReducer with a `prepare` method.\n *\n * @public\n */\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\n  reducer: CaseReducer<State, Action>\n  prepare: PrepareAction<Action['payload']>\n}\n\n/**\n * The type describing a slice's `reducers` option.\n *\n * @public\n */\nexport type SliceCaseReducers<State> = {\n  [K: string]:\n    | CaseReducer<DeepReadonly<State>, PayloadAction<any>>\n    | CaseReducerWithPrepare<DeepReadonly<State>, PayloadAction<any, string, any, any>>\n}\n\n/**\n * Derives the slice's `actions` property from the `reducers` options\n *\n * @public\n */\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\n}\n\n/**\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\n *\n * @internal\n */\ntype ActionCreatorForCaseReducerWithPrepare<CR extends { prepare: any }> =\n  _ActionCreatorWithPreparedPayload<CR['prepare'], string>\n\n/**\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\n *\n * @internal\n */\ntype ActionCreatorForCaseReducer<CR> = CR extends (\n  state: any,\n  action: infer Action\n) => any\n  ? Action extends { payload: infer P }\n    ? PayloadActionCreator<P>\n    : ActionCreatorWithoutPayload\n  : ActionCreatorWithoutPayload\n\n/**\n * Extracts the CaseReducers out of a `reducers` object, even if they are\n * tested into a `CaseReducerWithPrepare`.\n *\n * @internal\n */\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\n    reducer: infer Reducer\n  }\n    ? Reducer\n    : CaseReducers[Type]\n}\n\n/**\n * Used on a SliceCaseReducers object.\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\n * the `reducer` and the `prepare` function use the same type of `payload`.\n *\n * Might do additional such checks in the future.\n *\n * This type is only ever useful if you want to write your own wrapper around\n * `createSlice`. Please don't use it otherwise!\n *\n * @public\n */\nexport type ValidateSliceCaseReducers<\n  S,\n  ACR extends SliceCaseReducers<S>\n> = ACR & {\n  [T in keyof ACR]: ACR[T] extends {\n    reducer(s: S, action?: infer A): any\n  }\n    ? {\n        prepare(...a: never[]): Omit<A, 'type'>\n      }\n    : {}\n}\n\nfunction getType(slice: string, actionKey: string): string {\n  return `${slice}/${actionKey}`\n}\n\n/**\n * A function that accepts an initial state, an object full of reducer\n * functions, and a \"slice name\", and automatically generates\n * action creators and action types that correspond to the\n * reducers and state.\n *\n * The `reducer` argument is passed to `createReducer()`.\n *\n * @public\n */\nexport function createSlice<\n  State,\n  CaseReducers extends SliceCaseReducers<State>,\n  Name extends string = string\n>(\n  options: CreateSliceOptions<State, CaseReducers, Name>\n): Slice<State, CaseReducers, Name> {\n  const { name } = options\n  if (!name) {\n    throw new Error('`name` is a required option for createSlice')\n  }\n\n  // const initialState =\n  //   typeof options.initialState == 'function'\n  //     ? options.initialState\n  //     : createNextState(options.initialState, () => {})\n  const initialState = options.initialState\n\n  const reducers = options.reducers || {}\n\n  const reducerNames = Object.keys(reducers)\n\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\n  const actionCreators: Record<string, Function> = {}\n\n  reducerNames.forEach((reducerName) => {\n    const maybeReducerWithPrepare = reducers[reducerName]\n    const type = getType(name, reducerName)\n\n    let caseReducer: CaseReducer<DeepReadonly<State>, any>\n    let prepareCallback: PrepareAction<any> | undefined\n\n    if ('reducer' in maybeReducerWithPrepare) {\n      caseReducer = maybeReducerWithPrepare.reducer\n      prepareCallback = maybeReducerWithPrepare.prepare\n    } else {\n      caseReducer = maybeReducerWithPrepare\n    }\n\n    sliceCaseReducersByName[reducerName] = caseReducer\n    sliceCaseReducersByType[type] = caseReducer\n    actionCreators[reducerName] = prepareCallback\n      ? createAction(type, prepareCallback)\n      : createAction(type)\n  })\n\n  function buildReducer() {\n    const [\n      extraReducers = {},\n      actionMatchers = [],\n      defaultCaseReducer = undefined,\n    ] =\n      typeof options.extraReducers === 'function'\n        ? executeReducerBuilderCallback(options.extraReducers)\n        : [options.extraReducers]\n\n    const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\n    return createReducer(\n      initialState,\n      finalCaseReducers as any,\n      actionMatchers,\n      defaultCaseReducer\n    )\n  }\n\n  let _reducer: ReducerWithInitialState<State>\n\n  return {\n    name,\n    reducer(state, action) {\n      if (!_reducer) _reducer = buildReducer()\n\n      return _reducer(state, action)\n    },\n    actions: actionCreators as any,\n    caseReducers: sliceCaseReducersByName as any,\n    getInitialState() {\n      if (!_reducer) _reducer = buildReducer()\n\n      return _reducer.getInitialState()\n    },\n  }\n}\n", "import {\n  SliceCaseReducers,\n  ValidateSliceCaseReducers,\n  createSlice,\n} from '../toolkit/createSlice'\nimport { ActionReducerMapBuilder } from '../toolkit/mapBuilders'\nimport { destroyAction } from '../actions'\n\nexport const createDestroyableSlice = <\n  T,\n  Reducers extends SliceCaseReducers<T>\n>({\n  name = '',\n  initialState,\n  reducers,\n  extraReducers,\n}: {\n  name: string\n  initialState: T\n  reducers: ValidateSliceCaseReducers<T, Reducers>\n  extraReducers?: (builder: ActionReducerMapBuilder<T>) => void\n}) => {\n  return createSlice({\n    name,\n    initialState,\n    reducers,\n    extraReducers: (builder) => {\n      builder.addCase(destroyAction.type, () => {\n        return initialState\n      })\n\n      if (typeof extraReducers === 'function') {\n        extraReducers(builder)\n      }\n    },\n  })\n}\n", "import type { PayloadAction, AnyAction } from '../../toolkit'\nimport type { SessionState } from '../../interfaces'\nimport type {\n  Authorization,\n  RPCConnectResult,\n  SessionAuthError,\n  SessionAuthStatus,\n} from '../../../utils/interfaces'\nimport type { DeepReadonly } from '../../../types'\nimport { createDestroyableSlice } from '../../utils/createDestroyableSlice'\nimport { authErrorAction, initAction, reauthAction } from '../../actions'\n\nexport const initialSessionState: DeepReadonly<SessionState> = {\n  protocol: '',\n  iceServers: [],\n  authStatus: 'unknown',\n  authState: undefined,\n  authError: undefined,\n  authCount: 0,\n}\n\ntype AuthorizingAction = typeof initAction | typeof reauthAction\nfunction authorizingAction(action: AnyAction): action is AuthorizingAction {\n  return [initAction.type, reauthAction.type].includes(action.type)\n}\n\nconst sessionSlice = createDestroyableSlice({\n  name: 'session',\n  initialState: initialSessionState,\n  reducers: {\n    connected: (state, { payload }: PayloadAction<RPCConnectResult>) => {\n      return {\n        ...state,\n        authStatus: 'authorized',\n        authState: payload?.authorization,\n        authCount: state.authCount + 1,\n        protocol: payload?.protocol ?? '',\n        iceServers: payload?.ice_servers ?? [],\n      }\n    },\n    authStatus: (state, { payload }: PayloadAction<SessionAuthStatus>) => {\n      return {\n        ...state,\n        authStatus: payload,\n      }\n    },\n    updateAuthState: (state, { payload }: PayloadAction<Authorization>) => {\n      return {\n        ...state,\n        authState: payload,\n      }\n    },\n  },\n  extraReducers: (builder) => {\n    builder.addCase(\n      authErrorAction.type,\n      (state, { payload }: PayloadAction<{ error: SessionAuthError }>) => {\n        return {\n          ...state,\n          authStatus: 'unauthorized',\n          authError: payload.error,\n        }\n      }\n    )\n    builder.addMatcher(authorizingAction, (state) => {\n      return {\n        ...state,\n        authStatus: 'authorizing',\n      }\n    })\n  },\n})\n\n// prettier-ignore\nexport const {\n  actions: sessionActions,\n  reducer: sessionReducer\n} = sessionSlice\n", "import {\n  uuid,\n  getLogger,\n  checkWebSocketHost,\n  timeoutPromise,\n  parseRPCResponse,\n  safeParseJson,\n  isJSONRPCResponse,\n  isSATAuth,\n  SWCloseEvent,\n} from './utils'\nimport { DEFAULT_HOST, WebSocketState } from './utils/constants'\nimport {\n  RPCConnect,\n  RPCConnectParams,\n  DEFAULT_CONNECT_VERSION,\n  RPCDisconnectResponse,\n  RPCPingResponse,\n} from './RPCMessages'\nimport {\n  SessionOptions,\n  SessionRequestObject,\n  RPCConnectResult,\n  JSONRPCRequest,\n  JSONRPCResponse,\n  WebSocketAdapter,\n  NodeSocketAdapter,\n  WebSocketClient,\n  SessionStatus,\n  SessionAuthError,\n} from './utils/interfaces'\nimport {\n  authErrorAction,\n  authSuccessAction,\n  socketMessageAction,\n  sessionDisconnectedAction,\n  sessionReconnectingAction,\n} from './redux/actions'\nimport { sessionActions } from './redux/features/session/sessionSlice'\nimport { SwAuthorizationState } from '.'\nimport { SessionChannel, SessionChannelAction } from './redux/interfaces'\n\nexport const SW_SYMBOL = Symbol('BaseSession')\n\nconst randomInt = (min: number, max: number) => {\n  return Math.floor(Math.random() * (max - min + 1) + min)\n}\nconst reconnectDelay = () => {\n  return randomInt(1, 4) * 1000\n}\n\nexport class BaseSession {\n  /** @internal */\n  public __sw_symbol = SW_SYMBOL\n\n  public uuid = uuid()\n  public WebSocketConstructor: NodeSocketAdapter | WebSocketAdapter\n  public CloseEventConstructor: typeof SWCloseEvent\n  public agent: string\n  public connectVersion = DEFAULT_CONNECT_VERSION\n  public reauthenticate?(): Promise<void>\n\n  protected _rpcConnectResult: RPCConnectResult\n\n  private _requests = new Map<string, SessionRequestObject>()\n  private _socket: WebSocketClient | null = null\n  private _host: string = DEFAULT_HOST\n\n  private _executeTimeoutMs = 10 * 1000\n  private _executeTimeoutError = Symbol.for('sw-execute-timeout')\n  private _executeQueue: Set<JSONRPCRequest | JSONRPCResponse> = new Set()\n  private _swConnectError = Symbol.for('sw-connect-error')\n  private _executeConnectionClosed = Symbol.for('sw-execute-connection-closed')\n\n  private _checkPingDelay = 15 * 1000\n  private _checkPingTimer: any = null\n  private _reconnectTimer: ReturnType<typeof setTimeout>\n  private _status: SessionStatus = 'unknown'\n  private _sessionChannel: SessionChannel\n  private wsOpenHandler: (event: Event) => void\n  private wsCloseHandler: (event: SWCloseEvent) => void\n  private wsErrorHandler: (event: Event) => void\n\n  constructor(public options: SessionOptions) {\n    const { host, logLevel = 'info', sessionChannel } = options\n    if (host) {\n      this._host = checkWebSocketHost(host)\n    }\n\n    if (sessionChannel) {\n      this._sessionChannel = sessionChannel\n    }\n\n    if (logLevel) {\n      /**\n       * `setLevel` only makes sense when dealing with our\n       * default logger. The error is expected because we\n       * don't expose `setLevel` as part of our public\n       * SDKLogger since there's no standard API across\n       * loggers to do this.\n       */\n      // @ts-expect-error\n      this.logger.setLevel?.(logLevel)\n    }\n    this._onSocketOpen = this._onSocketOpen.bind(this)\n    this._onSocketError = this._onSocketError.bind(this)\n    this._onSocketClose = this._onSocketClose.bind(this)\n    this._onSocketMessage = this._onSocketMessage.bind(this)\n    this.execute = this.execute.bind(this)\n    this.connect = this.connect.bind(this)\n\n    /** Listen on socket events once */\n    this.wsOpenHandler = (event) => {\n      this._socket?.removeEventListener('open', this.wsOpenHandler)\n      this._onSocketOpen(event)\n    }\n    this.wsCloseHandler = (event) => {\n      this._socket?.removeEventListener('close', this.wsCloseHandler)\n      this._onSocketClose(event)\n    }\n    this.wsErrorHandler = (event) => {\n      this._socket?.removeEventListener('error', this.wsErrorHandler)\n      this._onSocketError(event)\n    }\n  }\n\n  get host() {\n    return this._host\n  }\n\n  get rpcConnectResult() {\n    return this._rpcConnectResult\n  }\n\n  get relayProtocol() {\n    return this._rpcConnectResult?.protocol ?? ''\n  }\n\n  get signature() {\n    if (this._rpcConnectResult) {\n      const { authorization } = this._rpcConnectResult\n      return isSATAuth(authorization)\n        ? authorization.jti\n        : authorization.signature\n    }\n    return undefined\n  }\n\n  protected get logger() {\n    return getLogger()\n  }\n\n  get connecting() {\n    return this._socket?.readyState === WebSocketState.CONNECTING\n  }\n\n  get connected() {\n    return this._socket?.readyState === WebSocketState.OPEN\n  }\n\n  get closing() {\n    return this._socket?.readyState === WebSocketState.CLOSING\n  }\n\n  get closed() {\n    return this._socket\n      ? this._socket.readyState === WebSocketState.CLOSED\n      : true\n  }\n\n  get status() {\n    return this._status\n  }\n\n  get idle() {\n    return this._status === 'idle'\n  }\n\n  get ready() {\n    return !Boolean(this.idle || !this.connected)\n  }\n\n  set token(token: string) {\n    this.options.token = token\n  }\n\n  /**\n   * Connect the websocket\n   *\n   * @return void\n   */\n  connect(): void {\n    if (!this?.WebSocketConstructor) {\n      throw new Error('Missing WebSocketConstructor')\n    }\n    if (!this?.CloseEventConstructor) {\n      throw new Error('Missing CloseEventConstructor')\n    }\n    this._clearTimers()\n    /**\n     * Return if already connecting or connected\n     * This prevents issues if \"connect()\" is called multiple times.\n     */\n    if (this.connecting || this.connected) {\n      this.logger.warn('Session already connected.')\n      return\n    }\n\n    /** In case of reconnect: remove listeners and then destroy it */\n    this._removeSocketListeners()\n    this.destroySocket()\n    this._clearCheckPingTimer()\n\n    this._socket = this._createSocket()\n    this._addSocketListeners()\n  }\n\n  /**\n   * Allow children classes to override it.\n   * @return WebSocket instance\n   */\n  protected _createSocket() {\n    return new this.WebSocketConstructor(this._host)\n  }\n\n  /** Allow children classes to override it. */\n  protected destroySocket() {\n    if (this._socket) {\n      this._socket.close()\n      this._socket = null\n    }\n  }\n\n  protected _addSocketListeners() {\n    if (!this._socket) {\n      return this.logger.debug('Invalid socket instance to add listeners')\n    }\n    this._removeSocketListeners()\n    this._socket.addEventListener('open', this.wsOpenHandler)\n    this._socket.addEventListener('close', this.wsCloseHandler)\n    this._socket.addEventListener('error', this.wsErrorHandler)\n    this._socket.addEventListener('message', this._onSocketMessage)\n  }\n\n  protected _removeSocketListeners() {\n    if (!this._socket) {\n      return this.logger.debug('Invalid socket instance to remove listeners')\n    }\n    this._socket.removeEventListener('open', this.wsOpenHandler)\n    this._socket.removeEventListener('close', this.wsCloseHandler)\n    this._socket.removeEventListener('error', this.wsErrorHandler)\n    this._socket.removeEventListener('message', this._onSocketMessage)\n  }\n\n  /**\n   * Clear the Session and close the WS connection.\n   * @return void\n   */\n  async disconnect() {\n    /**\n     * Return if there is not a _socket instance or\n     * if it's already in closing state.\n     */\n    if (!this._socket || this.closing) {\n      this.logger.debug('Session not connected or already in closing state.')\n      return\n    }\n\n    this._status = 'disconnecting'\n    this._checkCurrentStatus()\n  }\n\n  /**\n   * Send a JSON object to the server.\n   * @return Promise that will resolve/reject depending on the server response\n   */\n  execute(msg: JSONRPCRequest | JSONRPCResponse): Promise<any> {\n    if (this._status === 'disconnecting') {\n      this.logger.warn(\n        'Reject request because the session is disconnecting',\n        msg\n      )\n      return Promise.reject({\n        code: '400',\n        message: 'The SDK session is disconnecting',\n      })\n    }\n    // In case of a response don't wait for a result\n    let promise: Promise<unknown> = Promise.resolve()\n    if ('params' in msg) {\n      // This is a request so save the \"id\" to resolve the Promise later\n      promise = new Promise((resolve, reject) => {\n        this._requests.set(msg.id, { rpcRequest: msg, resolve, reject })\n      })\n    }\n\n    if (!this.ready) {\n      this._addToExecuteQueue(msg)\n      this.connect()\n\n      return promise\n    }\n\n    this._send(msg)\n\n    return timeoutPromise(\n      promise,\n      this._executeTimeoutMs,\n      this._executeTimeoutError\n    ).catch((error) => {\n      if (error === this._executeConnectionClosed) {\n        throw this._executeConnectionClosed\n      } else if (error === this._executeTimeoutError) {\n        if ('method' in msg && msg.method === 'signalwire.connect') {\n          throw this._swConnectError\n        }\n        this._checkCurrentStatus()\n        this.logger.error('Request Timeout', msg)\n        if (this.status === 'disconnected') {\n          return this.logger.debug(\n            'Request failed because the session is disconnected',\n            this.status,\n            this._socket\n          )\n        }\n\n        // Possibly half-open connection so force close our side\n        this._closeConnection('reconnecting')\n      } else {\n        throw error\n      }\n    })\n  }\n\n  /**\n   * Authenticate with the SignalWire Network\n   * @return Promise<void>\n   */\n  async authenticate() {\n    const params: RPCConnectParams = {\n      agent: this.agent,\n      version: this.connectVersion,\n      authentication: {\n        project: this.options.project,\n        token: this.options.token,\n      },\n    }\n    if (this._relayProtocolIsValid()) {\n      params.protocol = this.relayProtocol\n    }\n    if (this.options.topics?.length) {\n      params.contexts = this.options.topics\n    } else if (this.options.contexts?.length) {\n      params.contexts = this.options.contexts\n    }\n    this._rpcConnectResult = await this.execute(RPCConnect(params))\n  }\n\n  authError(error: SessionAuthError) {\n    /** Ignore WS events after the auth error and just disconnect */\n    this._removeSocketListeners()\n\n    this.dispatch(authErrorAction({ error }))\n  }\n\n  forceClose() {\n    this._removeSocketListeners()\n\n    return this._closeConnection('reconnecting')\n  }\n\n  protected async _onSocketOpen(event: Event) {\n    this.logger.debug('_onSocketOpen', event.type)\n    try {\n      // Reset to \"unknown\" in case of reconnect\n      this._status = 'unknown'\n      this._clearTimers()\n      await this.authenticate()\n      this._status = 'connected'\n      this._flushExecuteQueue()\n      this.dispatch(authSuccessAction())\n    } catch (error) {\n      if (\n        error === this._swConnectError ||\n        error === this._executeConnectionClosed\n      ) {\n        this.logger.debug(\n          'Invalid connect or connection closed. Waiting for retry.'\n        )\n        return\n      }\n\n      this.logger.error('Auth Error', error)\n      this.authError(error)\n    }\n  }\n\n  protected _onSocketError(event: Event) {\n    this.logger.debug('_onSocketError', event)\n  }\n\n  protected _onSocketClose(event: SWCloseEvent) {\n    this.logger.debug('_onSocketClose', event.type, event.code, event.reason)\n    if (this._status !== 'disconnected') {\n      this._status = 'reconnecting'\n      this.dispatch(sessionReconnectingAction())\n      this._clearTimers()\n      this._clearPendingRequests()\n      this._reconnectTimer = setTimeout(() => {\n        this.connect()\n      }, reconnectDelay())\n    }\n    this._socket = null\n  }\n\n  private _clearTimers() {\n    clearTimeout(this._reconnectTimer)\n  }\n\n  private _clearPendingRequests() {\n    this.logger.debug('_clearPendingRequests', this._requests.size)\n    this._requests.forEach(({ reject }) => {\n      reject(this._executeConnectionClosed)\n    })\n  }\n\n  protected _onSocketMessage(event: MessageEvent) {\n    const payload = this.decode<JSONRPCRequest | JSONRPCResponse>(event.data)\n    this.logger.wsTraffic({ type: 'recv', payload })\n\n    if (isJSONRPCResponse(payload)) {\n      const request = this._requests.get(payload.id)\n      if (request) {\n        const { rpcRequest, resolve, reject } = request\n        this._requests.delete(payload.id)\n        const { result, error } = parseRPCResponse({\n          response: payload,\n          request: rpcRequest,\n        })\n\n        this._checkCurrentStatus()\n\n        return error ? reject(error) : resolve(result)\n      }\n\n      return this.logger.warn('Unknown request for', payload)\n    }\n\n    switch (payload.method) {\n      case 'signalwire.ping':\n        return this._pingHandler(payload)\n      case 'signalwire.disconnect': {\n        /**\n         * Set this._status = 'idle' because the server\n         * will close the connection soon.\n         */\n        this.execute(RPCDisconnectResponse(payload.id))\n          .catch((error) => {\n            this.logger.error('SwDisconnect Error', error)\n          })\n          .finally(() => {\n            this._status = 'idle'\n          })\n        break\n      }\n      default:\n        // If it's not a response, trigger the dispatch.\n        this.dispatch(socketMessageAction(payload))\n    }\n  }\n\n  public dispatch(_payload: SessionChannelAction) {\n    if (!this._sessionChannel) {\n      throw new Error('Session channel does not exist')\n    }\n    this._sessionChannel.put(_payload)\n  }\n\n  /**\n   * Check the current relayProtocol against the signature\n   * to make sure is still valid.\n   * @return boolean\n   */\n  protected _relayProtocolIsValid() {\n    return (\n      this.signature && this?.relayProtocol?.split('_')[1] === this.signature\n    )\n  }\n\n  protected encode<T>(input: T): Parameters<WebSocketClient['send']>[0] {\n    return JSON.stringify(input)\n  }\n\n  protected decode<T>(input: any): T {\n    return safeParseJson(input)\n  }\n\n  async onSwAuthorizationState(state: SwAuthorizationState) {\n    this.persistSwAuthorizationState(state)\n  }\n\n  protected async retrieveSwAuthorizationState() {\n    // no-op : allow override\n    return ''\n  }\n\n  protected async persistSwAuthorizationState(_: SwAuthorizationState) {\n    // no-op : allow override\n  }\n\n  private _send(msg: JSONRPCRequest | JSONRPCResponse) {\n    this.logger.wsTraffic({ type: 'send', payload: msg })\n    this._socket!.send(this.encode(msg))\n  }\n\n  private _addToExecuteQueue(msg: JSONRPCRequest | JSONRPCResponse) {\n    this.logger.warn('Request queued waiting for session to reconnect', msg)\n    this._executeQueue.add(msg)\n  }\n\n  private _flushExecuteQueue() {\n    if (!this._executeQueue.size) {\n      return\n    }\n    if (!this.ready) {\n      this.logger.warn(`Session not ready to flush the queue.`)\n      this._closeConnection('reconnecting')\n      return\n    }\n    this.logger.debug(`${this._executeQueue.size} messages to flush`)\n    this._executeQueue.forEach((msg) => {\n      this._send(msg)\n      this._executeQueue.delete(msg)\n    })\n    this._executeQueue.clear()\n  }\n\n  private _clearCheckPingTimer() {\n    clearTimeout(this._checkPingTimer)\n  }\n\n  private async _pingHandler(payload: JSONRPCRequest) {\n    this._clearCheckPingTimer()\n    this._checkPingTimer = setTimeout(() => {\n      // Possibly half-open connection so force close our side\n      this.logger.debug('Timeout waiting for ping')\n      this._closeConnection('reconnecting')\n    }, this._checkPingDelay)\n\n    await this.execute(RPCPingResponse(payload.id, payload?.params?.timestamp))\n  }\n\n  /**\n   * Do something based on the current `this._status`\n   */\n  private _checkCurrentStatus() {\n    switch (this._status) {\n      // Only close the WS connection if there are no pending requests\n      case 'disconnecting':\n        if (this._requests.size > 0) {\n          return\n        }\n        this._requests.clear()\n        this._closeConnection('disconnected')\n        break\n      case 'disconnected':\n        // Will destroy the rootSaga too\n        this.dispatch(sessionDisconnectedAction())\n        break\n      case 'reconnecting':\n        /**\n         * Since the real `close` event can be delayed by OS/Browser,\n         * trigger it manually to start the reconnect process if required.\n         */\n        this.wsCloseHandler(\n          new this.CloseEventConstructor('close', {\n            reason: 'Client-side closed',\n          })\n        )\n        break\n    }\n  }\n\n  private _closeConnection(\n    status: Extract<SessionStatus, 'reconnecting' | 'disconnected'>\n  ) {\n    this._clearCheckPingTimer()\n    this.logger.debug('Close Connection:', status)\n    this._status = status\n    this.dispatch(\n      sessionActions.authStatus(\n        status === 'disconnected' ? 'unauthorized' : 'unknown'\n      )\n    )\n    this._removeSocketListeners()\n    this.destroySocket()\n    this._checkCurrentStatus()\n  }\n}\n", "import {\n  RPCConnect,\n  RPCConnectParams,\n  RPCReauthenticate,\n  RPCReauthenticateParams,\n} from './RPCMessages'\nimport { SessionOptions } from './utils/interfaces'\nimport { BaseSession } from './BaseSession'\nimport { authExpiringAction } from './redux/actions'\nimport { type SWCloseEvent, isSATAuth } from './utils'\n\nexport class BaseJWTSession extends BaseSession {\n  /**\n   * Can be set a value different then zero\n   * to force the JWT as expired within X seconds.\n   * TODO: Remove this workaround.\n   */\n  private _expiredDiffSeconds = 0\n  private _refreshTokenNotificationDiff = 120\n  /**\n   * Check the JWT expiration every 20seconds\n   */\n  private _checkTokenExpirationDelay = 20 * 1000\n  private _checkTokenExpirationTimer: any = null\n\n  constructor(public options: SessionOptions) {\n    super(options)\n\n    this._checkTokenExpiration = this._checkTokenExpiration.bind(this)\n    this.reauthenticate = this.reauthenticate.bind(this)\n  }\n\n  get expiresAt() {\n    if (!this?._rpcConnectResult) {\n      return 0\n    }\n    const { authorization } = this._rpcConnectResult\n    const expiresAt =\n      (isSATAuth(authorization)\n        ? authorization.fabric_subscriber.expires_at\n        : authorization?.expires_at) ?? 0\n    if (typeof expiresAt === 'string') {\n      const parsed = Date.parse(expiresAt)\n      if (!isNaN(parsed)) {\n        return Math.floor(parsed / 1000)\n      }\n    }\n    return expiresAt\n  }\n\n  get expiresIn() {\n    const now = Math.floor(Date.now() / 1000)\n    return this.expiresAt - now\n  }\n\n  get expired() {\n    return this.expiresAt > 0 && this.expiresIn <= this._expiredDiffSeconds\n  }\n\n  /**\n   * Authenticate with the SignalWire Network\n   * using JWT\n   * @return Promise<void>\n   */\n  async authenticate() {\n    const params: RPCConnectParams = {\n      agent: this.agent,\n      version: this.connectVersion,\n      authentication: {\n        jwt_token: this.options.token,\n      },\n    }\n\n    if (this._relayProtocolIsValid()) {\n      params.protocol = this.relayProtocol\n    } else {\n      /**\n       * TODO: Find out a better way to get the prevProtocol\n       */\n      const prevProtocol = await this.retrieveRelayProtocol()\n      if (prevProtocol) {\n        params.protocol = prevProtocol\n      }\n    }\n\n    // Try to set authorization_state only if we have a valid protocol\n    if (params.protocol) {\n      const authorizationState = await this.retrieveSwAuthorizationState()\n      if (authorizationState) {\n        params.authorization_state = authorizationState\n      }\n    }\n\n    try {\n      this._rpcConnectResult = await this.execute(RPCConnect(params))\n      await this.persistRelayProtocol()\n      await this._checkTokenExpiration()\n    } catch (error) {\n      this.logger.debug('BaseJWTSession authenticate error', error)\n      throw error\n    }\n  }\n\n  async retrieveRelayProtocol() {\n    // no-op\n    return ''\n  }\n\n  async persistRelayProtocol() {\n    // no-op\n  }\n\n  /**\n   * Reauthenticate with the SignalWire Network\n   * using a newer JWT. If the session has expired\n   * will reconnect it.\n   * @return Promise<void>\n   */\n  async reauthenticate() {\n    this.logger.debug('Session Reauthenticate', {\n      ready: this.ready,\n      expired: this.expired,\n    })\n    if (!this.ready || this.expired) {\n      return this.connect()\n    }\n\n    const params: RPCReauthenticateParams = {\n      project: this._rpcConnectResult.authorization.project_id,\n      jwt_token: this.options.token,\n    }\n\n    try {\n      this._rpcConnectResult = await this.execute(RPCReauthenticate(params))\n    } catch (error) {\n      clearTimeout(this._checkTokenExpirationTimer)\n      throw error\n    }\n  }\n\n  protected override _onSocketClose(event: SWCloseEvent) {\n    clearTimeout(this._checkTokenExpirationTimer)\n    super._onSocketClose(event)\n  }\n\n  /**\n   * Set a timer to dispatch a notification when the JWT is going to expire.\n   * @return void\n   */\n  protected async _checkTokenExpiration() {\n    if (!this.expiresAt) {\n      return\n    }\n    const refreshTokenFn =\n      this.options._onRefreshToken || this.options.onRefreshToken\n    if (this.expiresIn <= this._refreshTokenNotificationDiff) {\n      this.dispatch(authExpiringAction())\n\n      if (typeof refreshTokenFn === 'function') {\n        try {\n          await refreshTokenFn()\n        } catch (error) {\n          this.logger.error(error)\n        }\n      } else {\n        this.logger.warn('The token is going to expire!')\n      }\n    }\n    clearTimeout(this._checkTokenExpirationTimer)\n    if (!this.expired) {\n      this._checkTokenExpirationTimer = setTimeout(\n        this._checkTokenExpiration,\n        this._checkTokenExpirationDelay\n      )\n    }\n  }\n}\n", "import { Store } from 'redux'\nimport createSagaMiddleware, {\n  channel,\n  multicastChannel,\n  Saga,\n  Task,\n} from '@redux-saga/core'\nimport { configureStore as rtConfigureStore } from './toolkit'\nimport { rootReducer } from './rootReducer'\nimport rootSaga from './rootSaga'\nimport { SDKState, SessionChannel, SwEventChannel } from './interfaces'\nimport { connect } from './connect'\nimport {\n  InternalUserOptions,\n  SessionConstructor,\n  InternalChannels,\n} from '../utils/interfaces'\nimport { useSession } from './utils/useSession'\nimport { useInstanceMap } from './utils/useInstanceMap'\n\nexport interface ConfigureStoreOptions {\n  userOptions: InternalUserOptions\n  SessionConstructor: SessionConstructor\n  runSagaMiddleware?: boolean\n  preloadedState?: Partial<SDKState>\n}\n\nexport type SDKStore = ReturnType<typeof configureStore>\nexport type SDKRunSaga = <S extends Saga>(\n  saga: S,\n  params?: Parameters<S>[0]\n) => Task\n\nconst configureStore = (options: ConfigureStoreOptions) => {\n  const {\n    userOptions,\n    SessionConstructor,\n    preloadedState = {},\n    runSagaMiddleware = true,\n  } = options\n  const sagaMiddleware = createSagaMiddleware()\n  const swEventChannel: SwEventChannel = multicastChannel()\n  const sessionChannel: SessionChannel = channel()\n  /**\n   * List of channels that are gonna be shared across all\n   * sagas.\n   */\n  const channels: InternalChannels = {\n    swEventChannel,\n    sessionChannel,\n  }\n  const store = rtConfigureStore({\n    devTools: userOptions?.devTools ?? true,\n    reducer: rootReducer,\n    preloadedState,\n    middleware: (getDefaultMiddleware) =>\n      // It is preferrable to use the chainable .concat(...) and\n      // .prepend(...) methods of the returned MiddlewareArray instead\n      // of the array spread operator, as the latter can lose valuable\n      // type information under some circumstances.\n      // @see https://redux-toolkit.js.org/api/getDefaultMiddleware#intended-usage\n      getDefaultMiddleware().concat(sagaMiddleware),\n  }) as Store\n\n  const { initSession, getSession, sessionEmitter } = useSession({\n    userOptions,\n    sessionChannel,\n    SessionConstructor,\n  })\n\n  const map = useInstanceMap()\n\n  const runSaga = <T>(\n    saga: Saga,\n    args: {\n      instance: T\n      runSaga: any\n    }\n  ) => {\n    return sagaMiddleware.run(saga, {\n      ...args,\n      channels,\n      getSession,\n      instanceMap: map,\n    })\n  }\n\n  if (runSagaMiddleware) {\n    const saga = rootSaga({\n      initSession,\n      sessionEmitter,\n    })\n    sagaMiddleware.run(saga, { userOptions, channels })\n  }\n\n  return {\n    ...store,\n    runSaga,\n    channels,\n    instanceMap: map,\n    sessionEmitter,\n  }\n}\n\nexport { connect, configureStore }\nexport * from './actions'\nexport * from './utils/sagaHelpers'\nexport * from './toolkit'\n", "import { createDestroyableSlice } from '../../utils/createDestroyableSlice'\nimport type { PayloadAction } from '../../toolkit'\nimport type { ComponentState, ReduxComponent } from '../../interfaces'\nimport type { DeepReadonly } from '../../../types'\n\nexport const initialComponentState: DeepReadonly<ComponentState> = {\n  byId: {},\n}\n\ntype UpdateComponent = Partial<ReduxComponent> & Pick<ReduxComponent, 'id'>\ntype CleanupComponentParams = {\n  ids: Array<ReduxComponent['id']>\n}\n\nconst componentSlice = createDestroyableSlice({\n  name: 'components',\n  initialState: initialComponentState,\n  reducers: {\n    upsert: (state, { payload }: PayloadAction<UpdateComponent>) => {\n      if (payload.id in state.byId) {\n        return {\n          ...state,\n          byId: {\n            ...state.byId,\n            [payload.id]: {\n              ...state.byId[payload.id],\n              ...payload,\n            },\n          },\n        }\n      } else {\n        return {\n          ...state,\n          byId: {\n            ...state.byId,\n            [payload.id]: payload,\n          },\n        }\n      }\n    },\n    cleanup: (state, { payload }: PayloadAction<CleanupComponentParams>) => {\n      return {\n        ...state,\n        byId: Object.entries(state.byId).reduce(\n          (reducer, [componentId, value]) => {\n            if (!payload.ids.includes(componentId)) {\n              reducer[componentId] = value\n            }\n\n            return reducer\n          },\n          {} as ComponentState['byId']\n        ),\n      }\n    },\n  },\n})\n\n// prettier-ignore\nexport const {\n  actions: componentActions,\n  reducer: componentReducer\n} = componentSlice\n", "import { combineReducers } from './toolkit'\nimport { componentReducer, sessionReducer } from './features'\n\nexport const rootReducer = combineReducers({\n  components: componentReducer,\n  session: sessionReducer,\n})\n", "import type { Task, SagaIterator } from '@redux-saga/types'\nimport { fork, call, take, put, all, cancelled } from '@redux-saga/core/effects'\nimport {\n  InternalUserOptions,\n  InternalChannels,\n  ClientEvents,\n} from '../utils/interfaces'\nimport { getLogger, setDebugOptions, setLogger } from '../utils'\nimport { BaseSession } from '../BaseSession'\nimport { sessionChannelWatcher } from './features/session/sessionSaga'\nimport {\n  initAction,\n  destroyAction,\n  sessionReconnectingAction,\n  sessionDisconnectedAction,\n  reauthAction,\n  sessionForceCloseAction,\n} from './actions'\nimport { sessionActions } from './features'\nimport {\n  authErrorAction,\n  authSuccessAction,\n  authExpiringAction,\n} from './actions'\nimport { AuthError } from '../CustomErrors'\nimport { SessionChannel } from './interfaces'\nimport { createRestartableSaga } from './utils/sagaHelpers'\nimport { EventEmitter } from '../utils/EventEmitter'\n\ninterface StartSagaOptions {\n  session: BaseSession\n  sessionEmitter: EventEmitter<ClientEvents>\n  sessionChannel: SessionChannel\n  userOptions: InternalUserOptions\n}\n\nexport function* initSessionSaga({\n  initSession,\n  sessionEmitter,\n  userOptions,\n  channels,\n}: {\n  initSession: () => BaseSession\n  sessionEmitter: EventEmitter<ClientEvents>\n  userOptions: InternalUserOptions\n  channels: InternalChannels\n}): SagaIterator {\n  const session = initSession()\n  /**\n   * Channel to broadcast all the events sent by the server\n   */\n  const swEventChannel = channels.swEventChannel\n  /**\n   * Channel to communicate with base session\n   */\n  const sessionChannel = channels.sessionChannel\n\n  /**\n   * Start all the custom workers on startup\n   */\n  let customTasks: Task[] = []\n  if (userOptions.workers?.length) {\n    try {\n      const effects = userOptions.workers.map((saga) => {\n        return call(createRestartableSaga(saga))\n      })\n      customTasks = yield all(effects)\n    } catch (error) {\n      getLogger().error('Error running custom workers', error)\n    }\n  }\n\n  yield fork(sessionChannelWatcher, {\n    session,\n    sessionChannel,\n    swEventChannel,\n  })\n\n  /**\n   * Fork the watcher for the session status\n   */\n  const sessionStatusTask: Task = yield fork(sessionStatusWatcher, {\n    session,\n    sessionEmitter,\n    sessionChannel,\n    userOptions,\n  })\n\n  session.connect()\n\n  yield take(destroyAction.type)\n\n  session.disconnect()\n\n  yield take(sessionDisconnectedAction.type)\n  sessionEmitter.emit('session.disconnected')\n\n  /**\n   * We have to manually cancel the fork because it is not\n   * being automatically cleaned up when the session is\n   * destroyed, most likely because it's using a timer.\n   */\n  sessionStatusTask.cancel()\n  customTasks.forEach((task) => task.cancel())\n  /**\n   * Do not close swEventChannel, and sessionChannel\n   * since we may need them again in case of reauth/reconnect\n   * swEventChannel.close()\n   * sessionChannel.close()\n   */\n}\n\nexport function* reauthenticateWorker({\n  session,\n  token,\n  sessionEmitter,\n}: {\n  session: BaseSession\n  token: string\n  sessionEmitter: EventEmitter<ClientEvents>\n}) {\n  try {\n    if (session.reauthenticate) {\n      session.token = token\n      yield call(session.reauthenticate)\n      // Update the store with the new \"connect result\"\n      yield put(sessionActions.connected(session.rpcConnectResult))\n      sessionEmitter.emit('session.connected')\n    }\n  } catch (error) {\n    getLogger().error('Reauthenticate Error', error)\n    session.authError(error)\n  }\n}\n\nexport function* sessionStatusWatcher(options: StartSagaOptions): SagaIterator {\n  getLogger().debug('sessionStatusWatcher [started]')\n  const { session, sessionEmitter } = options\n\n  try {\n    while (true) {\n      const action = yield take([\n        authSuccessAction.type,\n        authErrorAction.type,\n        authExpiringAction.type,\n        reauthAction.type,\n        sessionReconnectingAction.type,\n        sessionForceCloseAction.type,\n      ])\n\n      getLogger().trace('sessionStatusWatcher', action.type, action.payload)\n      switch (action.type) {\n        case authSuccessAction.type: {\n          yield put(sessionActions.connected(session.rpcConnectResult))\n          sessionEmitter.emit('session.connected')\n          break\n        }\n        case authErrorAction.type: {\n          yield fork(sessionAuthErrorSaga, {\n            ...options,\n            action,\n          })\n          break\n        }\n        case authExpiringAction.type: {\n          sessionEmitter.emit('session.expiring')\n          break\n        }\n        case reauthAction.type: {\n          yield fork(reauthenticateWorker, {\n            session: session,\n            token: action.payload.token,\n            sessionEmitter,\n          })\n          break\n        }\n        case sessionReconnectingAction.type: {\n          sessionEmitter.emit('session.reconnecting')\n          break\n        }\n        case sessionForceCloseAction.type: {\n          session.forceClose()\n          break\n        }\n      }\n    }\n  } finally {\n    if (yield cancelled()) {\n      getLogger().debug('sessionStatusWatcher [cancelled]')\n    }\n  }\n}\n\ninterface SessionAuthErrorOptions extends StartSagaOptions {\n  action: any\n}\nexport function* sessionAuthErrorSaga(\n  options: SessionAuthErrorOptions\n): SagaIterator {\n  getLogger().debug('sessionAuthErrorSaga [started]')\n\n  try {\n    const { action, sessionEmitter } = options\n    const { error: authError } = action.payload\n    const error = authError\n      ? new AuthError(authError.code, authError.message)\n      : new Error('Unauthorized')\n\n    sessionEmitter.emit('session.auth_error', error)\n  } finally {\n    if (yield cancelled()) {\n      getLogger().debug('sessionAuthErrorSaga [cancelled]')\n    }\n  }\n}\n\ninterface RootSagaOptions {\n  initSession: () => BaseSession\n  sessionEmitter: EventEmitter<ClientEvents>\n}\n\nexport default (options: RootSagaOptions) => {\n  return function* root({\n    userOptions,\n    channels,\n  }: {\n    userOptions: InternalUserOptions\n    channels: InternalChannels\n  }): SagaIterator {\n    if (userOptions.logger) {\n      setLogger(userOptions.logger)\n    }\n    if (userOptions.debug) {\n      setDebugOptions(userOptions.debug)\n    }\n\n    while (true) {\n      /**\n       * Wait for an initAction to start\n       */\n      const action = yield take([initAction.type, reauthAction.type])\n\n      /**\n       * Update token only if the action contains a `token`\n       * (case of reauthAction with a new token)\n       */\n      if (action?.payload?.token) {\n        userOptions.token = action.payload.token\n      }\n\n      /**\n       * Create Session and related sessionChannel to\n       * send/receive websocket messages\n       */\n      try {\n        yield call(initSessionSaga, {\n          ...options,\n          userOptions,\n          channels,\n        })\n      } catch (error) {\n        getLogger().error('RootSaga Error:', error)\n      } finally {\n        if (yield cancelled()) {\n          getLogger().debug('rootSaga [cancelled]')\n        }\n        getLogger().debug('Reboot rootSaga')\n      }\n    }\n  }\n}\n", "import { SagaIterator } from '@redux-saga/core'\nimport { put, take, fork } from '@redux-saga/core/effects'\nimport type { PayloadAction } from '../../toolkit'\nimport { BaseSession } from '../../../BaseSession'\nimport { JSONRPCRequest } from '../../../utils/interfaces'\nimport type {\n  VideoAPIEventParams,\n  SwEventParams,\n  WebRTCMessageParams,\n  SwAuthorizationStateParams,\n} from '../../../types'\nimport type { SessionChannel, SwEventChannel } from '../../interfaces'\nimport { createCatchableSaga } from '../../utils/sagaHelpers'\nimport { socketMessageAction } from '../../actions'\nimport { getLogger, isWebrtcEventType, toInternalAction } from '../../../utils'\n\ntype SessionSagaParams = {\n  session: BaseSession\n  sessionChannel: SessionChannel\n  swEventChannel: SwEventChannel\n}\n\n// TODO: Move TypeGuards to its own module\nconst isWebrtcEvent = (e: SwEventParams): e is WebRTCMessageParams => {\n  return isWebrtcEventType(e?.event_type)\n}\nconst isVideoEvent = (e: SwEventParams): e is VideoAPIEventParams => {\n  return !!e?.event_type?.startsWith('video.')\n}\nconst isSwAuthorizationState = (\n  e: SwEventParams\n): e is SwAuthorizationStateParams => {\n  return e?.event_type === 'signalwire.authorization.state'\n}\n\nexport function* sessionChannelWatcher({\n  sessionChannel,\n  swEventChannel,\n  session,\n}: SessionSagaParams): SagaIterator {\n  function* swEventWorker(broadcastParams: SwEventParams) {\n    yield put(swEventChannel, toInternalAction(broadcastParams))\n\n    if (isWebrtcEvent(broadcastParams) || isVideoEvent(broadcastParams)) {\n      /**\n       * Skip `webrtc.*` & `video.*` events.\n       * There are custom workers handling them through `swEventChannel`\n       */\n      return\n    }\n    if (isSwAuthorizationState(broadcastParams)) {\n      session.onSwAuthorizationState(broadcastParams.params.authorization_state)\n      return\n    }\n\n    /**\n     * Put actions with `event_type` to trigger all the children sagas\n     * This should replace all the isWebrtcEvent/isVideoEvent guards below\n     * since we'll move that logic on a separate package.\n     */\n    yield put({ type: broadcastParams.event_type, payload: broadcastParams })\n  }\n\n  function* sessionChannelWorker(\n    action: PayloadAction<JSONRPCRequest>\n  ): SagaIterator {\n    if (action.type !== socketMessageAction.type) {\n      yield put(action)\n      return\n    }\n    const { method, params } = action.payload\n\n    switch (method) {\n      case 'signalwire.event':\n        yield fork(swEventWorker, params as SwEventParams)\n        break\n      default:\n        return getLogger().debug(`Unknown message: ${method}`, action)\n    }\n  }\n  const sessionChannelWorkerCatchable = createCatchableSaga<\n    PayloadAction<JSONRPCRequest>\n  >(sessionChannelWorker, (error) => {\n    getLogger().error('Channel Error', error)\n  })\n\n  /**\n   * Make the watcher restartable\n   */\n  while (true) {\n    try {\n      while (true) {\n        const action = yield take(sessionChannel)\n        yield fork(sessionChannelWorkerCatchable, action)\n      }\n    } catch (error) {\n      getLogger().error('sessionChannelWorker error:', error)\n    } finally {\n      getLogger().debug('sessionChannelWorker finally')\n    }\n  }\n}\n", "import { Saga } from '@redux-saga/core'\nimport { call, spawn } from '@redux-saga/core/effects'\nimport { getLogger } from '../../utils'\n\nexport const createRestartableSaga = (saga: Saga) => {\n  return function* () {\n    spawn(function* () {\n      while (true) {\n        try {\n          getLogger().debug('Run a restartable saga')\n          yield call(saga)\n          getLogger().debug(\n            'One of the restartable saga has ended. Restarting..'\n          )\n        } catch (error) {\n          getLogger().error('Restartable Saga Error', error)\n        }\n      }\n    })\n  }\n}\n\nconst defaultCatchHandler = (error: any) =>\n  getLogger().error('Catchable Saga Error', error)\n\nexport const createCatchableSaga = <Args = any>(\n  saga: Saga,\n  errorHandler = defaultCatchHandler\n) => {\n  return function* (...params: Args[]) {\n    try {\n      yield call(saga, ...params)\n    } catch (error) {\n      errorHandler(error)\n    }\n  }\n}\n\nexport { eventChannel } from '@redux-saga/core'\n", "export class AuthError extends Error {\n  name = 'AuthError'\n\n  constructor(public code: number, public message: string) {\n    super(message)\n    Object.setPrototypeOf(this, AuthError.prototype)\n  }\n}\n\nexport class HttpError extends Error {\n  name = 'HttpError'\n\n  constructor(\n    public code: number,\n    public message: string,\n    public response?: Record<string, any>\n  ) {\n    super(message)\n    Object.setPrototypeOf(this, HttpError.prototype)\n  }\n}\n", "import { SDKState } from '../../interfaces'\n\nexport const getIceServers = ({ session }: SDKState) => {\n  return session?.iceServers ?? []\n}\n\nexport const getSession = (store: SDKState) => {\n  return store.session\n}\n\nexport const getAuthStatus = ({ session }: SDKState) => {\n  return session.authStatus\n}\n\nexport const getAuthError = ({ session }: SDKState) => {\n  return session.authError\n}\n\nexport const getAuthState = ({ session }: SDKState) => {\n  return session.authState\n}\n", "import { SessionState, CustomSaga } from './interfaces'\nimport { SDKStore } from './'\nimport { getSession } from './features/session/sessionSelectors'\nimport type { BaseComponent } from '../BaseComponent'\nimport { EventEmitter } from '../utils/EventEmitter'\n\ntype SessionEventHandler = (session: SessionState) => unknown\ninterface Connect<T> {\n  sessionListeners?: Partial<\n    Record<ReduxSessionKeys, string | SessionEventHandler>\n  >\n  store: SDKStore\n  Component: new (o: any) => T\n  customSagas?: Array<CustomSaga<T>>\n}\ntype ReduxSessionKeys = keyof SessionState\n\nexport const connect = <\n  EventTypes extends EventEmitter.ValidEventTypes,\n  /**\n   * Class extending BaseComponent.\n   */\n  T extends BaseComponent<EventTypes>,\n  /**\n   * The type the end user will be interacting with.\n   */\n  TargetType\n>(\n  options: Connect<T>\n) => {\n  const { sessionListeners = {}, store, Component, customSagas = [] } = options\n  const sessionKeys = Object.keys(sessionListeners) as ReduxSessionKeys[]\n\n  return (userOptions: any): TargetType => {\n    const instance = new Component({ ...userOptions, store })\n    const cacheMap = new Map<string, any>()\n    /**\n     * Stop the execution of the redux listeners if `destroyer`\n     * below was called in the meantime.\n     */\n    let run = true\n\n    const storeUnsubscribe = store.subscribe(() => {\n      const state = store.getState()\n\n      const session = getSession(state)\n      for (const reduxKey of sessionKeys) {\n        if (run === false) {\n          return\n        }\n        const cacheKey = `session.${reduxKey}`\n        const current = cacheMap.get(cacheKey)\n        const updatedValue = session[reduxKey]\n\n        if (updatedValue !== undefined && current !== updatedValue) {\n          cacheMap.set(cacheKey, updatedValue)\n          const fnName = sessionListeners[reduxKey]\n\n          if (typeof fnName === 'string') {\n            // FIXME: proper types for fnName\n            // @ts-ignore\n            instance[fnName](session)\n          } else if (typeof fnName === 'function') {\n            fnName(session)\n          }\n        }\n      }\n    })\n\n    // Run all the custom sagas\n    const taskList = customSagas?.map((saga) => {\n      return store.runSaga(saga, { instance, runSaga: store.runSaga })\n    })\n\n    instance.destroyer = () => {\n      run = false\n      storeUnsubscribe()\n      cacheMap.clear()\n\n      // Cancel all the custom sagas\n      if (taskList?.length) {\n        taskList.forEach((task) => task.cancel())\n      }\n    }\n\n    return instance as any as TargetType\n  }\n}\n", "import EventEmitter from 'eventemitter3'\n\nconst REQUIRED_EMITTER_METHODS = [\n  'on',\n  'off',\n  'once',\n  'removeAllListeners',\n  'emit',\n]\n\n/**\n * Checks the shape of the emitter at runtime. This is useful for when\n * the user is using the SDK without TS\n */\nconst assertEventEmitter = (emitter: unknown): emitter is EventEmitter => {\n  if (\n    emitter &&\n    typeof emitter === 'object' &&\n    REQUIRED_EMITTER_METHODS.every((name) => name in emitter)\n  ) {\n    return true\n  }\n\n  return false\n}\n\nconst getEventEmitter = <T extends EventEmitter.ValidEventTypes>() => {\n  return new EventEmitter<T>()\n}\n\nexport { assertEventEmitter, EventEmitter, getEventEmitter }\n", "import { BaseSession } from '../../BaseSession'\nimport { getLogger } from '../../utils'\nimport { getEventEmitter } from '../../utils/EventEmitter'\nimport {\n  ClientEvents,\n  InternalUserOptions,\n  SessionConstructor,\n} from '../../utils/interfaces'\nimport { SessionChannel } from '../interfaces'\n\ninterface UseSessionOptions {\n  userOptions: InternalUserOptions\n  SessionConstructor: SessionConstructor\n  sessionChannel: SessionChannel\n}\n\nexport const useSession = (options: UseSessionOptions) => {\n  const { SessionConstructor, userOptions, sessionChannel } = options\n\n  const sessionEmitter = getEventEmitter<ClientEvents>()\n\n  let session: BaseSession | null = null\n\n  const initSession = () => {\n    session = new SessionConstructor({\n      ...userOptions,\n      sessionChannel,\n    })\n    return session\n  }\n\n  const getSession = () => {\n    if (!session) {\n      getLogger().warn('Custom worker started without the session')\n    }\n    return session\n  }\n\n  return { session, initSession, getSession, sessionEmitter }\n}\n", "export const useInstanceMap = () => {\n  // Generic map stores multiple instance\n  // For eg;\n  // callId => CallInstance\n  // controlId => PlaybackInstance | RecordingInstance\n  const instanceMap = new Map<string, unknown>()\n\n  const getInstance = <T extends unknown>(key: string): T => {\n    return instanceMap.get(key) as T\n  }\n\n  const setInstance = <T extends unknown>(key: string, value: T) => {\n    instanceMap.set(key, value)\n    return instanceMap\n  }\n\n  const deleteInstance = (key: string) => {\n    instanceMap.delete(key)\n    return instanceMap\n  }\n\n  return {\n    get: getInstance,\n    set: setInstance,\n    remove: deleteInstance,\n  }\n}\n", "import { call } from '@redux-saga/core/effects'\nimport { SagaIterator } from '@redux-saga/core'\nimport { getLogger } from '../utils/logger'\nimport { RPCExecute } from '../RPCMessages/RPCExecute'\nimport type { SDKWorker } from '../utils/interfaces'\nimport type { ExecuteActionParams } from '../redux/interfaces'\n\n/**\n * Send a JSONRPC over the wire using session.execute and resolve/reject the promise\n */\nexport const executeActionWorker: SDKWorker<ExecuteActionParams> = function* (\n  options\n): SagaIterator {\n  const { initialState, onDone, onFail, getSession } = options\n\n  const { requestId, method, params } = initialState\n\n  const session = getSession()\n\n  if (!session) {\n    const error = new Error('Session does not exist!')\n    getLogger().error(error)\n    onFail?.(error)\n    return\n  }\n\n  try {\n    const message = RPCExecute({\n      id: requestId,\n      method,\n      params,\n    })\n    const response = yield call(session.execute, message)\n    onDone?.(response)\n  } catch (error) {\n    getLogger().warn('Execute error: ', error)\n    onFail?.(error)\n  }\n}\n", "import type { Task } from '@redux-saga/types'\nimport { uuid, validateEventsToSubscribe, getLogger } from './utils'\nimport { Action } from './redux'\nimport {\n  ExecuteParams,\n  ExecuteTransform,\n  BaseComponentOptions,\n  ExecuteExtendedOptions,\n  SDKWorker,\n  SDKWorkerDefinition,\n  SessionAuthStatus,\n  SDKWorkerHooks,\n  Authorization,\n} from './utils/interfaces'\nimport { EventEmitter } from './utils/EventEmitter'\nimport { SDKState } from './redux/interfaces'\nimport { makeCustomSagaAction } from './redux/actions'\nimport {\n  OnlyStateProperties,\n  EmitterContract,\n  BaseComponentContract,\n} from './types'\nimport {\n  getAuthError,\n  getAuthState,\n  getAuthStatus,\n} from './redux/features/session/sessionSelectors'\nimport { AuthError } from './CustomErrors'\nimport { executeActionWorker } from './workers'\n\nconst identity: ExecuteTransform<any, any> = (payload) => payload\n\nexport const SW_SYMBOL = Symbol('BaseComponent')\n\nexport class BaseComponent<\n  EventTypes extends EventEmitter.ValidEventTypes,\n  StateProperties = Record<string, unknown>\n> implements EmitterContract<EventTypes>, BaseComponentContract\n{\n  /** @internal */\n  public __sw_symbol = SW_SYMBOL\n\n  /** @internal */\n  private readonly uuid = uuid()\n\n  /** @internal */\n  get __uuid() {\n    return this.uuid\n  }\n\n  private _customSagaTriggers = new Map()\n  private _destroyer?: () => void\n  private eventEmitter: EventEmitter<EventTypes>\n\n  /**\n   * List of running Tasks to be cancelled on `destroy`.\n   */\n  private _runningWorkers: Task[] = []\n\n  protected get logger() {\n    return getLogger()\n  }\n\n  /**\n   * Map of Sagas that will be attached to the Store to\n   * handle events or perform side-effects. This Map will\n   * behave as a queue and will be emptied once the workers\n   * have been attached. See `this.attachWorkers` for\n   * details.\n   */\n  protected _workers: Map<string, { worker: SDKWorker<any> }> = new Map()\n\n  constructor(public options: BaseComponentOptions) {\n    this.eventEmitter = new EventEmitter<EventTypes>()\n  }\n\n  /** @internal */\n  set destroyer(d: () => void) {\n    this._destroyer = d\n  }\n\n  /** @internal */\n  get store() {\n    return this.options.store\n  }\n\n  /** @internal */\n  get instanceMap() {\n    return this.options.store.instanceMap\n  }\n\n  /** @internal */\n  get emitter() {\n    return this.eventEmitter\n  }\n\n  /** @internal */\n  get sessionEmitter() {\n    return this.options.store.sessionEmitter\n  }\n\n  /** @internal */\n  get session() {\n    return this.sessionEmitter\n  }\n\n  on<T extends EventEmitter.EventNames<EventTypes>>(\n    event: T,\n    fn: EventEmitter.EventListener<EventTypes, T>\n  ) {\n    return this.emitter.on(event, fn)\n  }\n\n  once<T extends EventEmitter.EventNames<EventTypes>>(\n    event: T,\n    fn: EventEmitter.EventListener<EventTypes, T>\n  ) {\n    return this.emitter.once(event, fn)\n  }\n\n  off<T extends EventEmitter.EventNames<EventTypes>>(\n    event: T,\n    fn?: EventEmitter.EventListener<EventTypes, T>\n  ) {\n    return this.emitter.off(event, fn)\n  }\n\n  removeAllListeners<T extends EventEmitter.EventNames<EventTypes>>(event?: T) {\n    if (event) {\n      return this.off(event)\n    }\n\n    this.eventNames().forEach((eventName) => {\n      this.off(eventName)\n    })\n\n    this.sessionEventNames().forEach((eventName) => {\n      this.sessionEmitter.off(eventName)\n    })\n\n    return this.emitter as EventEmitter<EventTypes>\n  }\n\n  /** @internal */\n  eventNames() {\n    return this.emitter.eventNames()\n  }\n\n  /** @internal */\n  sessionEventNames() {\n    return this.sessionEmitter.eventNames()\n  }\n\n  protected getSubscriptions() {\n    return validateEventsToSubscribe(this.eventNames())\n  }\n\n  /** @internal */\n  emit(event: EventEmitter.EventNames<EventTypes>, ...args: any[]) {\n    // @ts-ignore\n    return this.emitter.emit(event, ...args)\n  }\n\n  /** @internal */\n  listenerCount<T extends EventEmitter.EventNames<EventTypes>>(event: T) {\n    return this.emitter.listenerCount(event)\n  }\n\n  destroy() {\n    this._destroyer?.()\n    this.removeAllListeners()\n    this.detachWorkers()\n  }\n\n  /** @internal */\n  execute<\n    InputType = unknown,\n    OutputType = unknown,\n    ParamsType = Record<string, any>\n  >(\n    { method, params }: ExecuteParams,\n    {\n      transformParams = identity,\n      transformResolve = identity,\n      transformReject = identity,\n    }: ExecuteExtendedOptions<InputType, OutputType, ParamsType> = {\n      transformParams: identity,\n      transformResolve: identity,\n      transformReject: identity,\n    }\n  ) {\n    return new Promise<OutputType>((resolve, reject) => {\n      const requestId = uuid()\n\n      this.runWorker('executeActionWorker', {\n        worker: executeActionWorker,\n        onDone: (data) => resolve(transformResolve(data)),\n        onFail: (error) => reject(transformReject(error)),\n        initialState: {\n          requestId,\n          componentId: this.__uuid,\n          method,\n          params: transformParams(params as ParamsType),\n        },\n      })\n    })\n  }\n\n  /** @internal */\n  triggerCustomSaga<T>(action: Action): Promise<T> {\n    return new Promise((resolve, reject) => {\n      const dispatchId = uuid()\n      this._customSagaTriggers.set(dispatchId, { resolve, reject })\n\n      this.store.dispatch({\n        dispatchId,\n        ...makeCustomSagaAction(this.__uuid, action),\n      })\n    })\n  }\n\n  /** @internal */\n  settleCustomSagaTrigger<T>({\n    dispatchId,\n    payload,\n    kind,\n  }: {\n    dispatchId: string\n    payload?: T\n    kind: 'resolve' | 'reject'\n  }) {\n    const actions = this._customSagaTriggers.get(dispatchId)\n    if (actions) {\n      actions[kind](payload)\n      this._customSagaTriggers.delete(dispatchId)\n    }\n  }\n\n  /** @internal */\n  select<T>(selectorFn: (state: SDKState) => T) {\n    return selectorFn(this.store.getState())\n  }\n\n  /** @internal */\n  getStateProperty(param: keyof OnlyStateProperties<StateProperties>) {\n    // @ts-expect-error\n    return this[param]\n  }\n\n  /** @internal */\n  protected get _sessionAuthStatus(): SessionAuthStatus {\n    return getAuthStatus(this.store.getState())\n  }\n\n  /** @internal */\n  protected get _sessionAuthState(): Authorization | undefined {\n    return getAuthState(this.store.getState())\n  }\n\n  /** @internal */\n  protected _waitUntilSessionAuthorized(): Promise<this> {\n    const authStatus = getAuthStatus(this.store.getState())\n\n    switch (authStatus) {\n      case 'authorized':\n        return Promise.resolve(this)\n\n      /**\n       * `unknown` is the initial state of the auth reducer\n       * so if we've got this far it means it's the first\n       * time the user is calling `connect`.\n       */\n      case 'unknown':\n      /**\n       * `authorizing` means that the user is calling\n       * `connect` again while we're in the process of\n       * authorizing the session.\n       */\n      case 'authorizing':\n        return new Promise((resolve, reject) => {\n          const unsubscribe = this.store.subscribe(() => {\n            const authStatus = getAuthStatus(this.store.getState())\n            const authError = getAuthError(this.store.getState())\n\n            if (authStatus === 'authorized') {\n              resolve(this)\n              unsubscribe()\n            } else if (authStatus === 'unauthorized') {\n              const error = authError\n                ? new AuthError(authError.code, authError.message)\n                : new Error('Unauthorized')\n              reject(error)\n              unsubscribe()\n            }\n          })\n        })\n\n      case 'unauthorized':\n        return Promise.reject(new Error('Unauthorized'))\n    }\n  }\n\n  /** @internal */\n  protected runWorker<Hooks extends SDKWorkerHooks = SDKWorkerHooks>(\n    name: string,\n    def: SDKWorkerDefinition<Hooks>\n  ) {\n    if (this._workers.has(name)) {\n      getLogger().warn(\n        `[runWorker] Worker with name ${name} has already been registerd.`\n      )\n    } else {\n      this._setWorker(name, def)\n    }\n\n    return this._attachWorker(name, def)\n  }\n\n  private _setWorker<Hooks extends SDKWorkerHooks = SDKWorkerHooks>(\n    name: string,\n    def: SDKWorkerDefinition<Hooks>\n  ) {\n    this._workers.set(name, def)\n  }\n\n  private _attachWorker<Hooks extends SDKWorkerHooks = SDKWorkerHooks>(\n    name: string,\n    { worker, ...params }: SDKWorkerDefinition<Hooks>\n  ) {\n    const task = this.store.runSaga(worker, {\n      instance: this,\n      runSaga: this.store.runSaga,\n      ...params,\n    })\n    this._runningWorkers.push(task)\n    /**\n     * Attaching workers is a one-time op for instances so\n     * the moment we attach one we'll remove it from the\n     * queue.\n     */\n    this._workers.delete(name)\n    return task\n  }\n\n  private detachWorkers() {\n    this._runningWorkers.forEach((task) => {\n      task.cancel()\n    })\n    this._runningWorkers = []\n  }\n}\n", "import { destroyAction, initAction } from './redux'\nimport { BaseClientOptions } from './utils/interfaces'\nimport { BaseComponent } from './BaseComponent'\nimport { EventEmitter } from './utils/EventEmitter'\nimport { getAuthStatus } from './redux/features/session/sessionSelectors'\n\nexport class BaseClient<\n  EventTypes extends EventEmitter.ValidEventTypes\n> extends BaseComponent<EventTypes> {\n  constructor(public options: BaseClientOptions<EventTypes>) {\n    super(options)\n  }\n\n  /**\n   * Connect the underlay WebSocket connection to the SignalWire network.\n   *\n   * @returns Promise that will resolve with the Client object.\n   */\n  connect(): Promise<this> {\n    const authStatus = getAuthStatus(this.store.getState())\n\n    if (authStatus === 'unknown' || authStatus === 'unauthorized') {\n      this.store.dispatch(initAction())\n    }\n\n    return this._waitUntilSessionAuthorized()\n  }\n\n  /**\n   * Disconnect the Client from the SignalWire network.\n   */\n  disconnect() {\n    this.store.dispatch(destroyAction())\n  }\n}\n", "import {\n  BaseComponent,\n  ExecuteParams,\n  EventEmitter,\n  BaseComponentOptions,\n  JSONRPCSubscribeMethod,\n} from '.'\n\n/**\n * Instances of this class are meant to be wrapped by a\n * Proxy that intercepts the `_eventsNamespace` (to tell the\n * BaseComponent it's fine to attach the event listeners)\n * and the `eventChannel`\n * @internal\n */\nexport class BaseConsumer<\n  EventTypes extends EventEmitter.ValidEventTypes\n> extends BaseComponent<EventTypes> {\n  protected subscribeMethod: JSONRPCSubscribeMethod = 'signalwire.subscribe'\n  protected subscribeParams?: Record<string, any> = {}\n  private _latestExecuteParams?: ExecuteParams\n\n  constructor(public options: BaseComponentOptions) {\n    super(options)\n    /**\n     * TODO: To Review\n     * Reset _latestExecuteParams when on session connect/disconnet\n     * so a reconnected client can send subscribe again.\n     */\n    const resetLatestExecuteParams = () => {\n      this._latestExecuteParams = undefined\n    }\n    super.session.on('session.connected', resetLatestExecuteParams)\n    super.session.on('session.disconnected', resetLatestExecuteParams)\n    super.session.on('session.reconnecting', resetLatestExecuteParams)\n  }\n\n  private shouldExecuteSubscribe(execParams: ExecuteParams) {\n    return (\n      !this._latestExecuteParams ||\n      JSON.stringify(execParams) !== JSON.stringify(this._latestExecuteParams)\n    )\n  }\n\n  async subscribe() {\n    await this._waitUntilSessionAuthorized()\n\n    const subscriptions = this.getSubscriptions()\n\n    if (subscriptions.length === 0) {\n      this.logger.debug(\n        '`subscribe()` was called without any listeners attached.'\n      )\n      return\n    }\n\n    const execParams: ExecuteParams = {\n      method: this.subscribeMethod,\n      params: {\n        ...this.subscribeParams,\n        event_channel: this.getStateProperty('eventChannel'),\n        events: subscriptions,\n      },\n    }\n\n    if (!this.shouldExecuteSubscribe(execParams)) {\n      this.logger.debug(\n        'BaseConsumer.subscribe() - Skipped .execute() since the execParams are exactly the same as last time'\n      )\n      return\n    }\n\n    this._latestExecuteParams = execParams\n    return new Promise(async (resolve, reject) => {\n      try {\n        await this.execute(execParams)\n        return resolve(undefined)\n      } catch (error) {\n        return reject(error)\n      }\n    })\n  }\n}\n", "import type {\n  ChatEvent,\n  InternalVideoMemberEvent,\n  InternalVideoRoomEvent,\n  VideoLayoutEvent,\n  VideoMemberEvent,\n  VideoPlaybackEvent,\n  VideoRecordingEvent,\n  VideoRoomEvent,\n  VideoRoomAudienceCountEvent,\n  VoiceCallEvent,\n  InternalVideoRoomAudienceCountEvent,\n  VideoStreamEvent,\n} from '../../../types'\nimport { getLogger } from '../../../utils'\nimport type { MapToPubSubShape, PubSubAction } from '../../interfaces'\n\nconst isVideoMemberEvent = (\n  action: PubSubAction\n): action is MapToPubSubShape<VideoMemberEvent | InternalVideoMemberEvent> => {\n  return (\n    action.type.startsWith('video.member.') ||\n    // TODO: find a better way to do this check.\n    action.type.startsWith('video.__synthetic__.member')\n  )\n}\n\nconst isVideoRoomEvent = (\n  action: PubSubAction\n): action is MapToPubSubShape<VideoRoomEvent | InternalVideoRoomEvent> => {\n  return action.type.startsWith('video.room.')\n}\n\nconst isVideoRoomAudienceCountEvent = (\n  action: PubSubAction\n): action is MapToPubSubShape<\n  VideoRoomAudienceCountEvent | InternalVideoRoomAudienceCountEvent\n> => {\n  return (\n    action.type === 'video.room.audience_count' ||\n    action.type === 'video.room.audienceCount'\n  )\n}\n\nconst isVideoLayoutEvent = (\n  action: PubSubAction\n): action is MapToPubSubShape<VideoLayoutEvent> => {\n  return action.type.startsWith('video.layout.')\n}\n\nconst isVideoRecordingEvent = (\n  action: PubSubAction\n): action is MapToPubSubShape<VideoRecordingEvent> => {\n  return action.type.startsWith('video.recording.')\n}\n\nconst isVideoPlaybackEvent = (\n  action: PubSubAction\n): action is MapToPubSubShape<VideoPlaybackEvent> => {\n  return action.type.startsWith('video.playback.')\n}\n\nconst isVideoStreamEvent = (\n  action: PubSubAction\n): action is MapToPubSubShape<VideoStreamEvent> => {\n  return action.type.startsWith('video.stream.')\n}\n\nconst isChatEvent = (\n  action: PubSubAction\n): action is MapToPubSubShape<ChatEvent> => {\n  return action.type.startsWith('chat.')\n}\n\nconst isVoiceCallEvent = (\n  action: PubSubAction\n): action is MapToPubSubShape<VoiceCallEvent> => {\n  return action.type.startsWith('calling.')\n}\n\nexport const findNamespaceInPayload = (action: PubSubAction): string => {\n  if (action.payload === undefined) {\n    return ''\n  } else if (\n    isVideoMemberEvent(action) ||\n    isVideoLayoutEvent(action) ||\n    isVideoRecordingEvent(action) ||\n    isVideoPlaybackEvent(action) ||\n    isVideoStreamEvent(action) ||\n    isVideoRoomAudienceCountEvent(action)\n  ) {\n    return action.payload.room_session_id\n  } else if (isVideoRoomEvent(action)) {\n    return action.payload.room_session.id\n  } else if (isChatEvent(action)) {\n    return ''\n  } else if (isVoiceCallEvent(action)) {\n    /**\n     * Some calling events (ie: `calling.call.receive`) have no \"tag\"\n     * but we inject it within the workers before put the action.\n     * See voiceCallPlayWorker as an example.\n     */\n    // @ts-expect-error\n    return action.payload.tag ?? ''\n  }\n\n  if ('development' === process.env.NODE_ENV) {\n    getLogger().info(\n      'Namespace not found for action.type: ',\n      (action as any)?.type\n    )\n  }\n\n  return ''\n}\n", "import { PRODUCT_PREFIX_VIDEO } from '../utils/constants'\nimport { toExternalJSON } from '../utils'\nimport type { SwEvent, VideoPosition } from '.'\nimport type {\n  CamelToSnakeCase,\n  SnakeToCamelCase,\n  EntityUpdated,\n  ToInternalVideoEvent,\n  OnlyStateProperties,\n  OnlyFunctionProperties,\n} from './utils'\nimport * as Rooms from '../rooms'\nimport { Authorization } from '..'\n\n/**\n * Used to not duplicate member fields across constants and types\n * and generate `MEMBER_UPDATED_EVENTS` below.\n * `key`: `type`\n */\nexport const INTERNAL_MEMBER_UPDATABLE_PROPS = {\n  audio_muted: true,\n  video_muted: true,\n  deaf: true,\n  visible: true,\n  input_volume: 1,\n  output_volume: 1,\n  input_sensitivity: 1,\n}\nexport type InternalVideoMemberUpdatableProps =\n  typeof INTERNAL_MEMBER_UPDATABLE_PROPS\n\nexport const INTERNAL_MEMBER_UPDATED_EVENTS = Object.keys(\n  INTERNAL_MEMBER_UPDATABLE_PROPS\n).map((key) => {\n  return `${PRODUCT_PREFIX_VIDEO}.member.updated.${\n    key as keyof InternalVideoMemberUpdatableProps\n  }` as const\n})\n\ntype VideoMemberUpdatableProps = {\n  [K in keyof InternalVideoMemberUpdatableProps as SnakeToCamelCase<K>]: InternalVideoMemberUpdatableProps[K]\n}\n\nexport const MEMBER_UPDATABLE_PROPS: VideoMemberUpdatableProps = toExternalJSON(\n  INTERNAL_MEMBER_UPDATABLE_PROPS\n)\n\nexport const MEMBER_UPDATED_EVENTS = Object.keys(MEMBER_UPDATABLE_PROPS).map(\n  (key) => {\n    return `member.updated.${key as keyof VideoMemberUpdatableProps}` as const\n  }\n)\n\n/**\n * Public event types\n */\nexport type MemberJoined = 'member.joined'\nexport type MemberLeft = 'member.left'\nexport type MemberUpdated = 'member.updated'\nexport type MemberTalking = 'member.talking'\nexport type MemberPromoted = 'member.promoted'\nexport type MemberDemoted = 'member.demoted'\n\n// Generated by the SDK\n\n/**\n * @privateRemarks\n *\n * This event will take care of handling multiple events at\n * once with the purpose of providing a nicer API for\n * keeping an up-to-date list of members within a certain\n * room.\n */\nexport type MemberListUpdated = 'memberList.updated'\n\n/**\n * See {@link MEMBER_UPDATED_EVENTS} for the full list of events.\n */\nexport type MemberUpdatedEventNames = (typeof MEMBER_UPDATED_EVENTS)[number]\nexport type MemberTalkingStarted = 'member.talking.started'\nexport type MemberTalkingEnded = 'member.talking.ended'\n/**\n * Use `member.talking.started` instead\n * @deprecated\n */\nexport type MemberTalkingStart = 'member.talking.start'\n/**\n * Use `member.talking.ended` instead\n * @deprecated\n */\nexport type MemberTalkingStop = 'member.talking.stop'\n\nexport type MemberTalkingEventNames =\n  | MemberTalking\n  | MemberTalkingStarted\n  | MemberTalkingEnded\n  | MemberTalkingStart\n  | MemberTalkingStop\n\n/**\n * List of public events\n */\nexport type VideoMemberEventNames =\n  | MemberJoined\n  | MemberLeft\n  | MemberUpdated\n  | MemberUpdatedEventNames\n  | MemberTalkingEventNames\n  | MemberListUpdated\n\nexport type InternalMemberUpdatedEventNames =\n  (typeof INTERNAL_MEMBER_UPDATED_EVENTS)[number]\n\n/**\n * List of internal events\n * @internal\n */\nexport type InternalVideoMemberEventNames =\n  | ToInternalVideoEvent<\n      MemberJoined | MemberLeft | MemberUpdated | MemberTalkingEventNames\n    >\n  | InternalMemberUpdatedEventNames\n\nexport type VideoMemberType = 'member' | 'screen' | 'device'\n\n/**\n * Public Contract for a VideoMember\n */\nexport interface VideoMemberContract extends VideoMemberUpdatableProps {\n  /** Unique id of this member. */\n  id: string\n  /** Id of the room associated to this member. */\n  roomId: string\n  /** Id of the room session associated to this member. */\n  roomSessionId: string\n  /** Name of this member. */\n  name: string\n  /** Id of the parent video member, if it exists. */\n  parentId?: string\n  /** Type of this video member. Can be `'member'`, `'screen'`, or `'device'`. */\n  type: VideoMemberType\n  /**\n   * Position requested for this member in the layout. This may differ from\n   * `currentPosition` if the requested position is not currently available.\n   */\n  requestedPosition: VideoPosition\n  /** Current position of this member in the layout. */\n  currentPosition?: VideoPosition\n  /** Metadata associated to this member. */\n  meta?: Record<string, unknown>\n  /** Indicate if the member hand is raised or not */\n  handraised: Boolean\n\n  /**\n   * Mutes the outbound audio for this member (e.g., the one coming from a\n   * microphone). The other participants will not hear audio from the muted\n   * participant anymore.\n   *\n   * @example\n   * ```typescript\n   * await member.audioMute()\n   * ```\n   */\n  audioMute(): Rooms.AudioMuteMember\n\n  /**\n   * Unmutes the outbound audio for this member (e.g., the one coming from a\n   * microphone) if it had been previously muted.\n   *\n   * @example\n   * ```typescript\n   * await member.audioUnmute()\n   * ```\n   */\n  audioUnmute(): Rooms.AudioUnmuteMember\n\n  /**\n   * Mutes the outbound video for this member (e.g., the one coming from a\n   * webcam). Participants will see a mute image instead of the video stream.\n   *\n   * @example\n   * ```typescript\n   * await member.videoMute()\n   * ```\n   */\n  videoMute(): Rooms.VideoMuteMember\n\n  /**\n   * Unmutes the outbound video for this member (e.g., the one coming from a\n   * webcam) if it had been previously muted. Participants will start seeing the\n   * video stream again.\n   *\n   * @example\n   * ```typescript\n   * await member.videoUnmute()\n   * ```\n   */\n  videoUnmute(): Rooms.VideoUnmuteMember\n\n  /**\n   * Mutes or unmutes the inbound audio for the member (e.g., the one that get\n   * played through this member's speakers). When the inbound audio is muted,\n   * the affected participant will not hear audio from the other participants\n   * anymore.\n   *\n   * @param value whether to mute the audio\n   *\n   * @example\n   * ```typescript\n   * await member.setDeaf(true)\n   * ```\n   */\n  setDeaf(value: boolean): Rooms.SetDeaf\n\n  /**\n   * @deprecated Use {@link setInputVolume} instead.\n   * `setMicrophoneVolume` will be removed in v4.0.0\n   */\n  setMicrophoneVolume(params: { volume: number }): Rooms.SetInputVolumeMember\n\n  /**\n   * Sets the input volume for the member (e.g., the microphone input level).\n   *\n   * @param params\n   * @param params.volume desired volume. Values range from -50 to 50, with a\n   * default of 0.\n   *\n   * @example\n   * ```typescript\n   * await member.setInputVolume({volume: -10})\n   * ```\n   */\n  setInputVolume(params: { volume: number }): Rooms.SetInputVolumeMember\n\n  /**\n   * @deprecated Use {@link setOutputVolume} instead.\n   * `setSpeakerVolume` will be removed in v4.0.0\n   */\n  setSpeakerVolume(params: { volume: number }): Rooms.SetOutputVolumeMember\n\n  /**\n   * Sets the output volume for the member (e.g., the speaker output level).\n   *\n   * @param params\n   * @param params.volume desired volume. Values range from -50 to 50, with a\n   * default of 0.\n   *\n   * @example\n   * ```typescript\n   * await member.setOutputVolume({volume: -10})\n   * ```\n   */\n  setOutputVolume(params: { volume: number }): Rooms.SetOutputVolumeMember\n\n  /**\n   * Sets the input level at which the participant is identified as currently\n   * speaking.\n   *\n   * @param params\n   * @param params.value desired sensitivity. The default value is 30 and the\n   * scale goes from 0 (lowest sensitivity, essentially muted) to 100 (highest\n   * sensitivity).\n   *\n   * @example\n   * ```typescript\n   * await member.setInputSensitivity({value: 80})\n   * ```\n   */\n  setInputSensitivity(params: {\n    value: number\n  }): Rooms.SetInputSensitivityMember\n\n  /**\n   * Removes this member from the room.\n   *\n   * @example\n   * ```typescript\n   * await member.remove()\n   * ```\n   */\n  remove(): Rooms.RemoveMember\n\n  /**\n   * Raise or lower this member's hand.\n   *\n   * @example\n   * ```typescript\n   * await member.setRaisedHand()\n   * ```\n   */\n  setRaisedHand(params?: Rooms.SetRaisedHandMemberParams): Rooms.SetRaisedHand\n}\n\n/**\n * VideoMember properties\n */\nexport type VideoMemberEntity = OnlyStateProperties<VideoMemberContract>\n/**\n * VideoMember methods\n */\nexport type VideoMemberMethods = OnlyFunctionProperties<VideoMemberContract>\n\n/**\n * VideoMemberEntity entity plus `updated` field\n */\nexport type VideoMemberEntityUpdated = EntityUpdated<VideoMemberEntity>\n\n/**\n * VideoMemberEntity entity for internal usage (converted to snake_case)\n * @internal\n */\nexport type InternalVideoMemberEntity = {\n  [K in NonNullable<\n    keyof VideoMemberEntity\n  > as CamelToSnakeCase<K>]: VideoMemberEntity[K]\n}\n\n/**\n * VideoMember entity plus `updated` field\n * for internal usage (converted to snake_case)\n * @internal\n */\nexport type InternalVideoMemberEntityUpdated =\n  EntityUpdated<InternalVideoMemberEntity>\n\nexport interface InternalVideoMemberUpdatedEvent extends SwEvent {\n  event_type: InternalMemberUpdatedEventNames\n  params: VideoMemberUpdatedEventParams\n}\n\nexport interface InternalVideoMemberTalkingEvent extends SwEvent {\n  event_type: MemberTalkingEventNames\n  params: VideoMemberTalkingEventParams\n}\n\nexport type InternalVideoMemberEvent =\n  | InternalVideoMemberUpdatedEvent\n  | InternalVideoMemberTalkingEvent\n\n/**\n * ==========\n * ==========\n * Server-Side Events\n * ==========\n * ==========\n */\n\n/**\n * 'video.member.joined'\n */\nexport interface VideoMemberJoinedEventParams {\n  room_session_id: string\n  room_id: string\n  member: InternalVideoMemberEntity\n}\n\nexport interface VideoMemberJoinedEvent extends SwEvent {\n  event_type: ToInternalVideoEvent<MemberJoined>\n  params: VideoMemberJoinedEventParams\n}\n\n/**\n * 'video.member.updated'\n */\nexport interface VideoMemberUpdatedEventParams {\n  room_session_id: string\n  room_id: string\n  member: InternalVideoMemberEntityUpdated\n}\n\nexport interface VideoMemberUpdatedEvent extends SwEvent {\n  event_type: ToInternalVideoEvent<MemberUpdated>\n  params: VideoMemberUpdatedEventParams\n}\n\n/**\n * 'video.member.left'\n */\nexport interface VideoMemberLeftEventParams {\n  room_session_id: string\n  room_id: string\n  member: InternalVideoMemberEntity\n}\n\nexport interface VideoMemberLeftEvent extends SwEvent {\n  event_type: ToInternalVideoEvent<MemberLeft>\n  params: VideoMemberLeftEventParams\n}\n\n/**\n * 'video.member.talking'\n */\nexport interface VideoMemberTalkingEventParams {\n  room_session_id: string\n  room_id: string\n  member: {\n    id: string\n    talking: boolean\n  }\n}\n\nexport interface VideoMemberTalkingEvent extends SwEvent {\n  event_type: ToInternalVideoEvent<MemberTalking>\n  params: VideoMemberTalkingEventParams\n}\n\n/**\n * 'video.member.promoted'\n */\nexport interface VideoMemberPromotedEventParams {\n  room_session_id: string\n  room_id: string\n  member_id: string\n  authorization: Authorization\n}\n\nexport interface VideoMemberPromotedEvent extends SwEvent {\n  event_type: ToInternalVideoEvent<MemberPromoted>\n  params: VideoMemberPromotedEventParams\n}\n\n/**\n * 'video.member.demoted'\n */\nexport interface VideoMemberDemotedEventParams {\n  room_session_id: string\n  room_id: string\n  member_id: string\n  authorization: Authorization\n}\n\nexport interface VideoMemberDemotedEvent extends SwEvent {\n  event_type: ToInternalVideoEvent<MemberDemoted>\n  params: VideoMemberDemotedEventParams\n}\n\nexport type VideoMemberEvent =\n  | VideoMemberJoinedEvent\n  | VideoMemberLeftEvent\n  | VideoMemberUpdatedEvent\n  | VideoMemberTalkingEvent\n  | VideoMemberPromotedEvent\n  | VideoMemberDemotedEvent\n\n/**\n * VideoMemberPromotedEventParams and VideoMemberDemotedEventParams\n * are special events without the full `member` object so we avoid\n * them in VideoMemberEventParams\n */\nexport type VideoMemberEventParams =\n  | VideoMemberJoinedEventParams\n  | VideoMemberLeftEventParams\n  | VideoMemberUpdatedEventParams\n  | VideoMemberTalkingEventParams\n", "import { ReduxComponent, SDKState } from '../../interfaces'\n\nexport const getComponent = ({ components }: SDKState, id: string) => {\n  return components.byId?.[id]\n}\n\nexport const getComponentsById = ({ components }: SDKState) => {\n  return components.byId\n}\n\nexport const getComponentsToCleanup = (state: SDKState) => {\n  const components = getComponentsById(state)\n\n  let toCleanup: Array<ReduxComponent['id']> = []\n  Object.keys(components).forEach((id) => {\n    if (components[id].responses || components[id].errors) {\n      toCleanup.push(id)\n    }\n  })\n\n  return toCleanup\n}\n", "import { BaseComponent, EventEmitter } from '..'\n\nexport interface BaseRoomInterface<\n  EventTypes extends EventEmitter.ValidEventTypes\n> extends BaseComponent<EventTypes> {\n  roomId: string\n  roomSessionId: string\n  memberId: string\n}\n\nexport * from './methods'\nexport * from './RoomSessionRecording'\nexport * from './RoomSessionPlayback'\nexport * from './RoomSessionStream'\n", "import {\n  type BaseRoomInterface,\n  type RoomSessionRecording,\n  type RoomSessionPlayback,\n  type RoomSessionStream,\n  createRoomSessionPlaybackObject,\n  createRoomSessionRecordingObject,\n  createRoomSessionStreamObject,\n} from '.'\nimport type {\n  VideoMemberEntity,\n  MemberCommandParams,\n  VideoPosition,\n} from '../types'\nimport type {\n  ExecuteExtendedOptions,\n  RoomMethod,\n  BaseRPCResult,\n  MediaAllowed,\n  VideoMeta,\n} from '../utils/interfaces'\n\ntype RoomMethodParams = Record<string, unknown>\n\ninterface RoomMethodPropertyDescriptor<OutputType, ParamsType>\n  extends PropertyDescriptor {\n  value: (params: ParamsType) => Promise<OutputType>\n}\n\ntype RoomMethodDescriptor<\n  OutputType = unknown,\n  ParamsType = RoomMethodParams\n> = RoomMethodPropertyDescriptor<OutputType, ParamsType> &\n  // TODO: Replace string with a tighter type\n  ThisType<BaseRoomInterface<string>>\n\n/**\n * Transform for returning `undefined` for `execute`s that were\n * successully resolved. If the `execute` failed for some reason, then\n * the promise will be rejected and this transform will never be\n * executed.\n */\nconst baseCodeTransform = () => {}\n\nconst createRoomMethod = <\n  InputType,\n  OutputType = InputType,\n  ParamsType extends RoomMethodParams = RoomMethodParams\n>(\n  method: RoomMethod,\n  options: ExecuteExtendedOptions<InputType, OutputType, ParamsType> = {}\n): RoomMethodDescriptor<OutputType, ParamsType> => ({\n  value: function (params = {} as ParamsType): Promise<OutputType> {\n    return this.execute(\n      {\n        method,\n        params: {\n          room_session_id: this.roomSessionId,\n          ...params,\n        },\n      },\n      options\n    )\n  },\n})\n\n/**\n * Type the params for each room member method that uses the provided\n * memberId or fallback to the instance memberId. Additional params\n * can be passed as `value` or `volume`.\n */\ninterface RoomMemberMethodParams extends Record<string, unknown> {\n  memberId?: string\n}\n\nconst createRoomMemberMethod = <\n  InputType,\n  OutputType,\n  ParamsType extends RoomMemberMethodParams = RoomMemberMethodParams\n>(\n  method: RoomMethod,\n  options: ExecuteExtendedOptions<InputType, OutputType, ParamsType> = {}\n): RoomMethodDescriptor<OutputType, ParamsType> => ({\n  value: function ({ memberId, ...rest } = {} as ParamsType) {\n    return this.execute(\n      {\n        method,\n        params: {\n          room_session_id: this.roomSessionId,\n          member_id: memberId || this.memberId,\n          ...rest,\n        },\n      },\n      options\n    )\n  },\n})\n\n/**\n * Room Methods\n */\nexport const getLayouts = createRoomMethod<{ layouts: string[] }>(\n  'video.list_available_layouts',\n  {\n    transformResolve: (payload) => ({ layouts: payload.layouts }),\n  }\n)\nexport const getMembers = createRoomMethod<{ members: VideoMemberEntity[] }>(\n  'video.members.get',\n  {\n    transformResolve: (payload) => ({ members: payload.members }),\n  }\n)\nexport interface SetLayoutParams {\n  name: string\n  positions?: Record<string, VideoPosition>\n}\nexport const setLayout = createRoomMethod<BaseRPCResult, void>(\n  'video.set_layout',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport interface SetPositionsParams {\n  positions: Record<string, VideoPosition>\n}\nexport const setPositions = createRoomMethod<BaseRPCResult, void>(\n  'video.set_position',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const hideVideoMuted = createRoomMethod<BaseRPCResult, void>(\n  'video.hide_video_muted',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const showVideoMuted = createRoomMethod<BaseRPCResult, void>(\n  'video.show_video_muted',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const lock = createRoomMethod<BaseRPCResult, void>('video.lock', {\n  transformResolve: baseCodeTransform,\n})\nexport const unlock = createRoomMethod<BaseRPCResult, void>('video.unlock', {\n  transformResolve: baseCodeTransform,\n})\n\nexport const setHideVideoMuted: RoomMethodDescriptor<void, boolean> = {\n  value: function (value) {\n    return this.execute(\n      {\n        method: value ? 'video.hide_video_muted' : 'video.show_video_muted',\n        params: {\n          room_session_id: this.roomSessionId,\n        },\n      },\n      {\n        transformResolve: baseCodeTransform,\n      }\n    )\n  },\n}\n\nexport interface GetRecordingsOutput {\n  recordings: RoomSessionRecording[]\n}\n\nexport const getRecordings: RoomMethodDescriptor<GetRecordingsOutput> = {\n  value: function () {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const { recordings } = await this.execute<void, any>({\n          method: 'video.recording.list',\n          params: {\n            room_session_id: this.roomSessionId,\n          },\n        })\n\n        const recordingInstances: RoomSessionRecording[] = []\n        recordings.forEach((recording: any) => {\n          let recordingInstance = this.instanceMap.get<RoomSessionRecording>(\n            recording.id\n          )\n          if (!recordingInstance) {\n            recordingInstance = createRoomSessionRecordingObject({\n              store: this.store,\n              payload: {\n                room_id: this.roomId,\n                room_session_id: this.roomSessionId,\n                recording,\n              },\n            })\n          } else {\n            recordingInstance.setPayload({\n              room_id: this.roomId,\n              room_session_id: this.roomSessionId,\n              recording,\n            })\n          }\n          recordingInstances.push(recordingInstance)\n          this.instanceMap.set<RoomSessionRecording>(\n            recordingInstance.id,\n            recordingInstance\n          )\n        })\n\n        resolve({ recordings: recordingInstances })\n      } catch (error) {\n        reject(error)\n      }\n    })\n  },\n}\n\nexport const startRecording: RoomMethodDescriptor<RoomSessionRecording> = {\n  value: function () {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const { recording } = await this.execute<void, any>({\n          method: 'video.recording.start',\n          params: {\n            room_session_id: this.roomSessionId,\n          },\n        })\n\n        const recordingInstance = createRoomSessionRecordingObject({\n          store: this.store,\n          payload: {\n            room_id: this.roomId,\n            room_session_id: this.roomSessionId,\n            recording,\n          },\n        })\n        this.instanceMap.set<RoomSessionRecording>(\n          recordingInstance.id,\n          recordingInstance\n        )\n\n        resolve(recordingInstance)\n      } catch (error) {\n        reject(error)\n      }\n    })\n  },\n}\n\nexport interface GetPlaybacksOutput {\n  playbacks: RoomSessionPlayback[]\n}\n\nexport const getPlaybacks: RoomMethodDescriptor<GetPlaybacksOutput> = {\n  value: function () {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const { playbacks } = await this.execute<void, any>({\n          method: 'video.playback.list',\n          params: {\n            room_session_id: this.roomSessionId,\n          },\n        })\n\n        const playbackInstances: RoomSessionPlayback[] = []\n        playbacks.forEach((playback: any) => {\n          let playbackInstance = this.instanceMap.get<RoomSessionPlayback>(\n            playback.id\n          )\n          if (!playbackInstance) {\n            playbackInstance = createRoomSessionPlaybackObject({\n              store: this.store,\n              payload: {\n                room_id: this.roomId,\n                room_session_id: this.roomSessionId,\n                playback,\n              },\n            })\n          } else {\n            playbackInstance.setPayload({\n              room_id: this.roomId,\n              room_session_id: this.roomSessionId,\n              playback,\n            })\n          }\n          playbackInstances.push(playbackInstance)\n          this.instanceMap.set<RoomSessionPlayback>(\n            playbackInstance.id,\n            playbackInstance\n          )\n        })\n\n        resolve({ playbacks: playbackInstances })\n      } catch (error) {\n        reject(error)\n      }\n    })\n  },\n}\n\nexport type PlayParams = {\n  url: string\n  volume?: number\n  positions?: Record<string, VideoPosition>\n  layout?: string\n  seekPosition?: number\n  /**\n   * @deprecated Use {@link seekPosition} instead.\n   * `currentTimecode` will be removed in v4.0.0\n   */\n  currentTimecode?: number\n}\nexport const play: RoomMethodDescriptor<any, PlayParams> = {\n  value: function ({ seekPosition, currentTimecode, ...params }) {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const seek_position = seekPosition || currentTimecode\n        const { playback } = await this.execute<void, any>({\n          method: 'video.playback.start',\n          params: {\n            room_session_id: this.roomSessionId,\n            seek_position,\n            ...params,\n          },\n        })\n        const playbackInstance = createRoomSessionPlaybackObject({\n          store: this.store,\n          payload: {\n            room_id: this.roomId,\n            room_session_id: this.roomSessionId,\n            playback,\n          },\n        })\n        this.instanceMap.set<RoomSessionPlayback>(\n          playbackInstance.id,\n          playbackInstance\n        )\n        resolve(playbackInstance)\n      } catch (error) {\n        reject(error)\n      }\n    })\n  },\n}\n\nconst createRoomMetaMethod = <ParamsType extends RoomMethodParams>(\n  method: RoomMethod\n) => {\n  return createRoomMethod<BaseRPCResult, void, ParamsType>(method, {\n    transformResolve: baseCodeTransform,\n    transformParams: (params) => {\n      const { room_session_id, ...meta } = params\n      return { room_session_id, meta }\n    },\n  })\n}\n\ninterface GetMetaOutput {\n  meta: VideoMeta\n}\n\nexport const getMeta = createRoomMethod<GetMetaOutput>('video.get_meta', {\n  transformResolve: ({ meta }) => ({ meta }),\n})\n\nexport interface SetMetaParams extends Record<string, unknown> {}\nexport const setMeta = createRoomMetaMethod<SetMetaParams>('video.set_meta')\n\nexport interface UpdateMetaParams extends Record<string, unknown> {}\nexport const updateMeta =\n  createRoomMetaMethod<UpdateMetaParams>('video.update_meta')\n\nexport type DeleteMetaParams = string[]\nexport const deleteMeta: RoomMethodDescriptor<any, DeleteMetaParams> = {\n  value: function (params) {\n    return this.execute({\n      method: 'video.delete_meta',\n      params: {\n        room_session_id: this.roomSessionId,\n        keys: params,\n      },\n    })\n  },\n}\n\nexport interface GetStreamsOutput {\n  streams: RoomSessionStream[]\n}\n\nexport const getStreams: RoomMethodDescriptor<GetStreamsOutput> = {\n  value: function () {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const { streams } = await this.execute<void, any>({\n          method: 'video.stream.list',\n          params: {\n            room_session_id: this.roomSessionId,\n          },\n        })\n\n        const streamInstances: RoomSessionStream[] = []\n        streams.forEach((stream: any) => {\n          let streamInstance = this.instanceMap.get<RoomSessionStream>(\n            stream.id\n          )\n          if (!streamInstance) {\n            streamInstance = createRoomSessionStreamObject({\n              store: this.store,\n              payload: {\n                room_id: this.roomId,\n                room_session_id: this.roomSessionId,\n                stream,\n              },\n            })\n          } else {\n            streamInstance.setPayload({\n              room_id: this.roomId,\n              room_session_id: this.roomSessionId,\n              stream,\n            })\n          }\n          streamInstances.push(streamInstance)\n          this.instanceMap.set<RoomSessionStream>(\n            streamInstance.id,\n            streamInstance\n          )\n        })\n\n        resolve({ streams: streamInstances })\n      } catch (error) {\n        reject(error)\n      }\n    })\n  },\n}\n\nexport interface StartStreamParams {\n  url: string\n}\nexport const startStream: RoomMethodDescriptor<any, StartStreamParams> = {\n  value: function (params) {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const { stream } = await this.execute<StartStreamParams, any>({\n          method: 'video.stream.start',\n          params: {\n            room_session_id: this.roomSessionId,\n            ...params,\n          },\n        })\n\n        const streamInstance = createRoomSessionStreamObject({\n          store: this.store,\n          payload: {\n            room_id: this.roomId,\n            room_session_id: this.roomSessionId,\n            stream,\n          },\n        })\n        this.instanceMap.set<RoomSessionStream>(\n          streamInstance.id,\n          streamInstance\n        )\n\n        resolve({ stream: streamInstance })\n      } catch (error) {\n        reject(error)\n      }\n    })\n  },\n}\n\nexport const setPrioritizeHandraise: RoomMethodDescriptor<any, boolean> = {\n  value: function (params) {\n    return this.execute({\n      method: 'video.prioritize_handraise',\n      params: {\n        room_session_id: this.roomSessionId,\n        enable: params,\n      },\n    })\n  },\n}\n\nexport type GetLayouts = ReturnType<typeof getLayouts.value>\nexport type GetMembers = ReturnType<typeof getMembers.value>\nexport type HideVideoMuted = ReturnType<typeof hideVideoMuted.value>\nexport type ShowVideoMuted = ReturnType<typeof showVideoMuted.value>\nexport type SetHideVideoMuted = ReturnType<typeof setHideVideoMuted.value>\n\nexport type GetRecordings = ReturnType<typeof getRecordings.value>\nexport type StartRecording = ReturnType<typeof startRecording.value>\n\nexport type GetPlaybacks = ReturnType<typeof getPlaybacks.value>\nexport type Play = ReturnType<typeof play.value>\nexport type GetMeta = ReturnType<typeof getMeta.value>\nexport type SetMeta = ReturnType<typeof setMeta.value>\nexport type UpdateMeta = ReturnType<typeof updateMeta.value>\nexport type DeleteMeta = ReturnType<typeof deleteMeta.value>\n\nexport type GetStreams = ReturnType<typeof getStreams.value>\nexport type StartStream = ReturnType<typeof startStream.value>\n\nexport type Lock = ReturnType<typeof lock.value>\nexport type Unlock = ReturnType<typeof unlock.value>\nexport type SetPrioritizeHandraise = ReturnType<\n  typeof setPrioritizeHandraise.value\n>\n// End Room Methods\n\n/**\n * Room Member Methods\n */\nexport const audioMuteMember = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.audio_mute',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const audioUnmuteMember = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.audio_unmute',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const videoMuteMember = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.video_mute',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const videoUnmuteMember = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.video_unmute',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const deafMember = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.deaf',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const undeafMember = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.undeaf',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\n// This is used on a RoomSessionMember instance where we have\n// `this.roomSessionId` and `this.memberId`\nexport const setDeaf: RoomMethodDescriptor<void, boolean> = {\n  value: function (value) {\n    return this.execute(\n      {\n        method: value ? 'video.member.deaf' : 'video.member.undeaf',\n        params: {\n          room_session_id: this.roomSessionId,\n          member_id: this.memberId,\n        },\n      },\n      {\n        transformResolve: baseCodeTransform,\n      }\n    )\n  },\n}\nexport const setInputVolumeMember = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.set_input_volume',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const setOutputVolumeMember = createRoomMemberMethod<\n  BaseRPCResult,\n  void\n>('video.member.set_output_volume', {\n  transformResolve: baseCodeTransform,\n})\nexport const setInputSensitivityMember = createRoomMemberMethod<\n  BaseRPCResult,\n  void\n>('video.member.set_input_sensitivity', {\n  transformResolve: baseCodeTransform,\n})\n\ninterface PromoteDemoteMemberParams extends Required<MemberCommandParams> {\n  mediaAllowed?: MediaAllowed\n}\n\nexport interface PromoteMemberParams extends PromoteDemoteMemberParams {\n  permissions?: string[]\n  meta?: VideoMeta\n  joinAudioMuted?: boolean\n  joinVideoMuted?: boolean\n}\nexport const promote: RoomMethodDescriptor<void, PromoteMemberParams> = {\n  value: function ({\n    memberId,\n    mediaAllowed,\n    joinAudioMuted,\n    joinVideoMuted,\n    ...rest\n  }) {\n    return this.execute<unknown, void, PromoteMemberParams>(\n      {\n        method: 'video.member.promote',\n        params: {\n          room_session_id: this.roomSessionId,\n          member_id: memberId,\n          media_allowed: mediaAllowed,\n          join_audio_muted: joinAudioMuted,\n          join_video_muted: joinVideoMuted,\n          ...rest,\n        },\n      },\n      {\n        transformResolve: baseCodeTransform as any,\n      }\n    )\n  },\n}\n\nexport interface DemoteMemberParams extends PromoteDemoteMemberParams {}\nexport const demote: RoomMethodDescriptor<void, DemoteMemberParams> = {\n  value: function ({ memberId, mediaAllowed }) {\n    return this.execute<unknown, void, DemoteMemberParams>(\n      {\n        method: 'video.member.demote',\n        params: {\n          room_session_id: this.roomSessionId,\n          member_id: memberId,\n          media_allowed: mediaAllowed,\n        },\n      },\n      {\n        transformResolve: baseCodeTransform as any,\n      }\n    )\n  },\n}\n\nexport interface SetMemberPositionParams extends MemberCommandParams {\n  position: VideoPosition\n}\nexport const setMemberPosition = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.set_position',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const removeMember: RoomMethodDescriptor<\n  void,\n  Required<RoomMemberMethodParams>\n> = {\n  value: function ({ memberId, ...rest }) {\n    if (!memberId) {\n      throw new TypeError('Invalid or missing \"memberId\" argument')\n    }\n    return this.execute(\n      {\n        method: 'video.member.remove',\n        params: {\n          room_session_id: this.roomSessionId,\n          member_id: memberId,\n          ...rest,\n        },\n      },\n      {\n        transformResolve: baseCodeTransform,\n      }\n    )\n  },\n}\n\nexport const removeAllMembers: RoomMethodDescriptor<void, void> = {\n  value: function () {\n    return this.execute(\n      {\n        method: 'video.member.remove',\n        params: {\n          room_session_id: this.roomSessionId,\n          member_id: 'all',\n        },\n      },\n      {\n        transformResolve: baseCodeTransform,\n      }\n    )\n  },\n}\n\ninterface GetMemberMetaOutput {\n  meta: VideoMeta\n}\n\nexport const getMemberMeta = createRoomMemberMethod<\n  BaseRPCResult & VideoMeta,\n  GetMemberMetaOutput\n>('video.member.get_meta', {\n  transformResolve: ({ meta }) => ({ meta }),\n})\nexport interface SetMemberMetaParams extends MemberCommandParams {\n  meta: VideoMeta\n}\nexport const setMemberMeta = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.set_meta',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\n\nexport interface UpdateMemberMetaParams extends MemberCommandParams {\n  meta: VideoMeta\n}\nexport const updateMemberMeta = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.update_meta',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport interface DeleteMemberMetaParams extends MemberCommandParams {\n  keys: string[]\n}\nexport const deleteMemberMeta = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.delete_meta',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\n\nexport interface SetRaisedHandRoomParams {\n  memberId: string\n  raised?: boolean\n}\n\nexport interface SetRaisedHandMemberParams {\n  raised?: boolean\n}\n\nexport const setRaisedHand: RoomMethodDescriptor<\n  void,\n  SetRaisedHandRoomParams | SetRaisedHandMemberParams\n> = {\n  value: function (value) {\n    const { raised = true, memberId = this.memberId } =\n      (value as SetRaisedHandRoomParams) || {}\n\n    if (!memberId) {\n      throw new TypeError('Invalid or missing \"memberId\" argument')\n    }\n\n    return this.execute(\n      {\n        method: raised ? 'video.member.raisehand' : 'video.member.lowerhand',\n        params: {\n          room_session_id: this.roomSessionId,\n          member_id: memberId,\n        },\n      },\n      {\n        transformResolve: baseCodeTransform,\n      }\n    )\n  },\n}\n\nexport type AudioMuteMember = ReturnType<typeof audioMuteMember.value>\nexport type AudioUnmuteMember = ReturnType<typeof audioUnmuteMember.value>\nexport type VideoMuteMember = ReturnType<typeof videoMuteMember.value>\nexport type VideoUnmuteMember = ReturnType<typeof videoUnmuteMember.value>\nexport type DeafMember = ReturnType<typeof deafMember.value>\nexport type UndeafMember = ReturnType<typeof undeafMember.value>\nexport type SetDeaf = ReturnType<typeof setDeaf.value>\nexport type SetLayout = ReturnType<typeof setLayout.value>\nexport type SetPositions = ReturnType<typeof setPositions.value>\nexport type SetInputVolumeMember = ReturnType<typeof setInputVolumeMember.value>\nexport type SetOutputVolumeMember = ReturnType<\n  typeof setOutputVolumeMember.value\n>\nexport type SetInputSensitivityMember = ReturnType<\n  typeof setInputSensitivityMember.value\n>\nexport type SetMemberPosition = ReturnType<typeof setMemberPosition.value>\nexport type RemoveMember = ReturnType<typeof removeMember.value>\nexport type RemoveAllMembers = ReturnType<typeof removeAllMembers.value>\nexport type GetMemberMeta = ReturnType<typeof getMemberMeta.value>\nexport type SetMemberMeta = ReturnType<typeof setMemberMeta.value>\nexport type UpdateMemberMeta = ReturnType<typeof updateMemberMeta.value>\nexport type DeleteMemberMeta = ReturnType<typeof deleteMemberMeta.value>\nexport type PromoteMember = ReturnType<typeof promote.value>\nexport type DemoteMember = ReturnType<typeof demote.value>\nexport type SetRaisedHand = ReturnType<typeof setRaisedHand.value>\n// End Room Member Methods\n", "import { connect } from '../redux'\nimport { BaseComponent } from '../BaseComponent'\nimport { BaseComponentOptionsWithPayload } from '../utils/interfaces'\nimport type {\n  VideoRecordingContract,\n  VideoRecordingEventNames,\n  VideoRecordingEventParams,\n  VideoRecordingMethods,\n} from '../types/videoRecording'\n\n/**\n * Represents a specific recording of a room session.\n */\nexport interface RoomSessionRecording extends VideoRecordingContract {\n  setPayload(payload: VideoRecordingEventParams): void\n}\n\nexport type RoomSessionRecordingEventsHandlerMapping = Record<\n  VideoRecordingEventNames,\n  (recording: RoomSessionRecording) => void\n>\n\nexport interface RoomSessionRecordingOptions\n  extends BaseComponentOptionsWithPayload<VideoRecordingEventParams> {}\n\nexport class RoomSessionRecordingAPI\n  extends BaseComponent<RoomSessionRecordingEventsHandlerMapping>\n  implements VideoRecordingMethods\n{\n  private _payload: VideoRecordingEventParams\n\n  constructor(options: RoomSessionRecordingOptions) {\n    super(options)\n\n    this._payload = options.payload\n  }\n\n  get id() {\n    return this._payload.recording.id\n  }\n\n  get roomId() {\n    return this._payload.room_id\n  }\n\n  get roomSessionId() {\n    return this._payload.room_session_id\n  }\n\n  get state() {\n    return this._payload.recording.state\n  }\n\n  get duration() {\n    return this._payload.recording.duration\n  }\n\n  get startedAt() {\n    if (!this._payload.recording.started_at) return undefined\n    return new Date(\n      (this._payload.recording.started_at as unknown as number) * 1000\n    )\n  }\n\n  get endedAt() {\n    if (!this._payload.recording.ended_at) return undefined\n    return new Date(\n      (this._payload.recording.ended_at as unknown as number) * 1000\n    )\n  }\n\n  /** @internal */\n  protected setPayload(payload: VideoRecordingEventParams) {\n    this._payload = payload\n  }\n\n  async pause() {\n    await this.execute({\n      method: 'video.recording.pause',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        recording_id: this.getStateProperty('id'),\n      },\n    })\n  }\n\n  async resume() {\n    await this.execute({\n      method: 'video.recording.resume',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        recording_id: this.getStateProperty('id'),\n      },\n    })\n  }\n\n  async stop() {\n    await this.execute({\n      method: 'video.recording.stop',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        recording_id: this.getStateProperty('id'),\n      },\n    })\n  }\n}\n\nexport const createRoomSessionRecordingObject = (\n  params: RoomSessionRecordingOptions\n): RoomSessionRecording => {\n  const recording = connect<\n    RoomSessionRecordingEventsHandlerMapping,\n    RoomSessionRecordingAPI,\n    RoomSessionRecording\n  >({\n    store: params.store,\n    Component: RoomSessionRecordingAPI,\n  })(params)\n\n  return recording\n}\n", "import { connect } from '../redux'\nimport { BaseComponent } from '../BaseComponent'\nimport { BaseComponentOptionsWithPayload } from '../utils/interfaces'\nimport type {\n  VideoPlaybackContract,\n  VideoPlaybackMethods,\n  VideoPlaybackEventNames,\n  VideoPlaybackEventParams,\n} from '../types/videoPlayback'\n\n/**\n * Instances of this class allow you to control (e.g., pause, resume, stop) the\n * playback inside a room session. You can obtain instances of this class by\n * starting a playback from the desired {@link RoomSession} (see\n * {@link RoomSession.play})\n */\nexport interface RoomSessionPlayback extends VideoPlaybackContract {\n  setPayload(payload: VideoPlaybackEventParams): void\n}\n\nexport type RoomSessionPlaybackEventsHandlerMapping = Record<\n  VideoPlaybackEventNames,\n  (playback: RoomSessionPlayback) => void\n>\n\nexport interface RoomSessionPlaybackOptions\n  extends BaseComponentOptionsWithPayload<VideoPlaybackEventParams> {}\n\nexport class RoomSessionPlaybackAPI\n  extends BaseComponent<RoomSessionPlaybackEventsHandlerMapping>\n  implements VideoPlaybackMethods\n{\n  private _payload: VideoPlaybackEventParams\n\n  constructor(options: RoomSessionPlaybackOptions) {\n    super(options)\n\n    this._payload = options.payload\n  }\n\n  get id() {\n    return this._payload.playback.id\n  }\n\n  get roomId() {\n    return this._payload.room_id\n  }\n\n  get roomSessionId() {\n    return this._payload.room_session_id\n  }\n\n  get url() {\n    return this._payload.playback.url\n  }\n\n  get state() {\n    return this._payload.playback.state\n  }\n\n  get volume() {\n    return this._payload.playback.volume\n  }\n\n  get startedAt() {\n    if (!this._payload.playback.started_at) return undefined\n    return new Date(\n      (this._payload.playback.started_at as unknown as number) * 1000\n    )\n  }\n\n  get endedAt() {\n    if (!this._payload.playback.ended_at) return undefined\n    return new Date(\n      (this._payload.playback.ended_at as unknown as number) * 1000\n    )\n  }\n\n  get position() {\n    return this._payload.playback.position\n  }\n\n  get seekable() {\n    return this._payload.playback.seekable\n  }\n\n  /** @internal */\n  protected setPayload(payload: VideoPlaybackEventParams) {\n    this._payload = payload\n  }\n\n  async pause() {\n    await this.execute({\n      method: 'video.playback.pause',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        playback_id: this.getStateProperty('id'),\n      },\n    })\n  }\n\n  async resume() {\n    await this.execute({\n      method: 'video.playback.resume',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        playback_id: this.getStateProperty('id'),\n      },\n    })\n  }\n\n  async stop() {\n    await this.execute({\n      method: 'video.playback.stop',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        playback_id: this.getStateProperty('id'),\n      },\n    })\n  }\n\n  async setVolume(volume: number) {\n    await this.execute({\n      method: 'video.playback.set_volume',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        playback_id: this.getStateProperty('id'),\n        volume,\n      },\n    })\n  }\n\n  async seek(timecode: number) {\n    await this.execute({\n      method: 'video.playback.seek_absolute',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        playback_id: this.getStateProperty('id'),\n        position: Math.abs(timecode),\n      },\n    })\n  }\n\n  async forward(offset: number = 5000) {\n    await this.execute({\n      method: 'video.playback.seek_relative',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        playback_id: this.getStateProperty('id'),\n        position: Math.abs(offset),\n      },\n    })\n  }\n\n  async rewind(offset: number = 5000) {\n    await this.execute({\n      method: 'video.playback.seek_relative',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        playback_id: this.getStateProperty('id'),\n        position: -Math.abs(offset),\n      },\n    })\n  }\n}\n\nexport const createRoomSessionPlaybackObject = (\n  params: RoomSessionPlaybackOptions\n): RoomSessionPlayback => {\n  const playback = connect<\n    RoomSessionPlaybackEventsHandlerMapping,\n    RoomSessionPlaybackAPI,\n    RoomSessionPlayback\n  >({\n    store: params.store,\n    Component: RoomSessionPlaybackAPI,\n  })(params)\n\n  return playback\n}\n", "import { connect } from '../redux'\nimport { BaseComponent } from '../BaseComponent'\nimport { BaseComponentOptionsWithPayload } from '../utils/interfaces'\nimport type {\n  VideoStreamContract,\n  VideoStreamEventNames,\n  VideoStreamEventParams,\n  VideoStreamMethods,\n} from '../types/videoStream'\n\n/**\n * Represents a specific Stream of a room session.\n */\nexport interface RoomSessionStream extends VideoStreamContract {\n  setPayload(payload: VideoStreamEventParams): void\n}\n\nexport type RoomSessionStreamEventsHandlerMapping = Record<\n  VideoStreamEventNames,\n  (stream: RoomSessionStream) => void\n>\n\nexport interface RoomSessionStreamOptions\n  extends BaseComponentOptionsWithPayload<VideoStreamEventParams> {}\n\nexport class RoomSessionStreamAPI\n  extends BaseComponent<RoomSessionStreamEventsHandlerMapping>\n  implements VideoStreamMethods\n{\n  private _payload: VideoStreamEventParams\n\n  constructor(options: RoomSessionStreamOptions) {\n    super(options)\n\n    this._payload = options.payload\n  }\n\n  get id() {\n    return this._payload.stream.id\n  }\n\n  get roomId() {\n    return this._payload.room_id\n  }\n\n  get roomSessionId() {\n    return this._payload.room_session_id\n  }\n\n  get state() {\n    return this._payload.stream.state\n  }\n\n  get duration() {\n    return this._payload.stream.duration\n  }\n\n  get url() {\n    return this._payload.stream.url\n  }\n\n  get startedAt() {\n    if (!this._payload.stream.started_at) return undefined\n    return new Date(\n      (this._payload.stream.started_at as unknown as number) * 1000\n    )\n  }\n\n  get endedAt() {\n    if (!this._payload.stream.ended_at) return undefined\n    return new Date((this._payload.stream.ended_at as unknown as number) * 1000)\n  }\n\n  /** @internal */\n  protected setPayload(payload: VideoStreamEventParams) {\n    this._payload = payload\n  }\n\n  async stop() {\n    await this.execute({\n      method: 'video.stream.stop',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        stream_id: this.getStateProperty('id'),\n      },\n    })\n  }\n}\n\nexport const createRoomSessionStreamObject = (\n  params: RoomSessionStreamOptions\n): RoomSessionStream => {\n  const stream = connect<\n    RoomSessionStreamEventsHandlerMapping,\n    RoomSessionStreamAPI,\n    RoomSessionStream\n  >({\n    store: params.store,\n    Component: RoomSessionStreamAPI,\n  })(params)\n\n  return stream\n}\n", "export * from './methods'\nexport * from './BaseChat'\nexport * from './ChatMessage'\nexport * from './ChatMember'\n", "import { InternalChatChannel } from '../..'\n\nexport const toInternalChatChannels = (\n  channels: string | string[] | undefined\n): InternalChatChannel[] => {\n  const list = !channels || Array.isArray(channels) ? channels : [channels]\n\n  if (Array.isArray(list)) {\n    return list.map((name) => {\n      return {\n        name,\n      }\n    })\n  }\n\n  return []\n}\n", "export * from './toInternalChatChannels'\n\nexport const isValidChannels = (input: unknown): input is string | string[] => {\n  return Array.isArray(input) || typeof input === 'string'\n}\n", "import type {\n  ChatJSONRPCMethod,\n  InternalChatMessageEntity,\n  ChatMessageEntity,\n  InternalChatMemberEntity,\n  ChatMemberEntity,\n} from '../types/chat'\nimport type { PaginationCursor } from '../types/common'\nimport type { BaseChatConsumer } from './BaseChat'\nimport type { ExecuteExtendedOptions, BaseRPCResult } from '../utils/interfaces'\nimport { toExternalJSON } from '../utils'\nimport { toInternalChatChannels, isValidChannels } from './utils'\n\ntype ChatMethodParams = Record<string, unknown>\n\ninterface ChatMethodPropertyDescriptor<OutputType, ParamsType>\n  extends PropertyDescriptor {\n  value: (params: ParamsType) => Promise<OutputType>\n}\ntype ChatMethodDescriptor<\n  OutputType = unknown,\n  ParamsType = ChatMethodParams\n> = ChatMethodPropertyDescriptor<OutputType, ParamsType> &\n  ThisType<BaseChatConsumer>\n\n/**\n * Transform for returning `undefined` for `execute`s that were\n * successully resolved. If the `execute` failed for some reason, then\n * the promise will be rejected and this transform will never be\n * executed.\n */\nconst baseCodeTransform = () => {}\n\nconst createChatMethod = <\n  InputType,\n  OutputType = InputType,\n  ParamsType extends ChatMethodParams = ChatMethodParams\n>(\n  method: ChatJSONRPCMethod,\n  options: ExecuteExtendedOptions<InputType, OutputType, ParamsType> = {}\n): ChatMethodDescriptor<OutputType> => ({\n  value: function (params = {}): Promise<OutputType> {\n    return this.execute(\n      {\n        method,\n        params,\n      },\n      options\n    )\n  },\n})\n\n/**\n * Type the params for each chat method that requires a memberId.\n * Additional params can be passed.\n */\ninterface ChatMemberMethodParams extends Record<string, unknown> {\n  memberId?: string\n}\n\nconst createChatMemberMethod = <\n  InputType,\n  OutputType = InputType,\n  ParamsType extends ChatMemberMethodParams = ChatMemberMethodParams\n>(\n  method: ChatJSONRPCMethod,\n  options: ExecuteExtendedOptions<InputType, OutputType, ParamsType> = {}\n): ChatMethodDescriptor<OutputType> => ({\n  value: function ({ memberId, ...rest } = {}) {\n    return this.execute(\n      {\n        method,\n        params: {\n          member_id: memberId,\n          ...rest,\n        },\n      },\n      options\n    )\n  },\n})\n\n/**\n * Chat Methods\n */\nexport const publish = createChatMethod<BaseRPCResult, void>('chat.publish', {\n  transformResolve: baseCodeTransform,\n})\n\ninterface GetMessagesInput extends BaseRPCResult {\n  messages: InternalChatMessageEntity[]\n  cursor: PaginationCursor\n}\ninterface GetMessagesOutput {\n  messages: ChatMessageEntity[]\n  cursor: PaginationCursor\n}\nexport const getMessages = createChatMethod<\n  GetMessagesInput,\n  GetMessagesOutput\n>('chat.messages.get', {\n  transformResolve: (payload) => ({\n    messages: payload.messages.map((message) => toExternalJSON(message)),\n    cursor: payload.cursor,\n  }),\n})\n\ninterface GetMembersInput extends BaseRPCResult {\n  members: InternalChatMemberEntity[]\n}\ninterface GetMembersOutput {\n  members: ChatMemberEntity[]\n}\nexport const getMembers = createChatMethod<GetMembersInput, GetMembersOutput>(\n  'chat.members.get',\n  {\n    transformResolve: (payload) => ({\n      members: payload.members.map((member) => toExternalJSON(member)),\n    }),\n  }\n)\n\nconst transformParamChannels = (params: ChatMemberMethodParams) => {\n  const channels = isValidChannels(params?.channels)\n    ? toInternalChatChannels(params.channels)\n    : undefined\n\n  return {\n    ...params,\n    channels,\n  }\n}\n/**\n * Chat Member Methods\n */\nexport const setMemberState = createChatMemberMethod<BaseRPCResult, void>(\n  'chat.member.set_state',\n  {\n    transformResolve: baseCodeTransform,\n    transformParams: transformParamChannels,\n  }\n)\n\ninterface GetMemberStateInput extends BaseRPCResult {\n  channels: any\n}\ninterface GetMemberStateOutput {\n  channels: any\n}\nexport const getMemberState = createChatMemberMethod<\n  GetMemberStateInput,\n  GetMemberStateOutput\n>('chat.member.get_state', {\n  transformResolve: (payload) => ({ channels: payload.channels }),\n  transformParams: transformParamChannels,\n})\n", "export * from './BasePubSub'\nexport * from './PubSubMessage'\n", "import { SagaIterator } from '@redux-saga/core'\nimport { BasePubSubConsumer } from '../BasePubSub'\nimport { PRODUCT_PREFIX_PUBSUB } from '../../utils/constants'\nimport {\n  sagaEffects,\n  PubSubEventAction,\n  SDKWorker,\n  getLogger,\n  PubSubMessage,\n  toExternalJSON,\n} from '../../index'\n\nexport const pubSubWorker: SDKWorker<BasePubSubConsumer> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('pubSubWorker started')\n  const {\n    instance: client,\n    channels: { swEventChannel },\n  } = options\n\n  function* worker(action: PubSubEventAction) {\n    const { type, payload } = action\n\n    switch (type) {\n      case `${PRODUCT_PREFIX_PUBSUB}.channel.message`: {\n        const {\n          channel,\n          /**\n           * Since we're using the same event as `Chat`\n           * the payload comes with a `member` prop. To\n           * avoid confusion (since `PubSub` doesn't\n           * have members) we'll remove it from the\n           * payload sent to the end user.\n           */\n          // @ts-expect-error\n          message: { member, ...restMessage },\n        } = payload\n        const externalJSON = toExternalJSON({\n          ...restMessage,\n          channel,\n        })\n        const pubSubMessage = new PubSubMessage(externalJSON)\n\n        client.emit('message', pubSubMessage)\n        break\n      }\n      default:\n        getLogger().warn(`Unknown pubsub event: \"${type}\"`)\n        break\n    }\n  }\n\n  const isPubSubEvent = (action: any) =>\n    action.type.startsWith(`${PRODUCT_PREFIX_PUBSUB}.`)\n\n  while (true) {\n    const action: PubSubEventAction = yield sagaEffects.take(\n      swEventChannel,\n      isPubSubEvent\n    )\n\n    yield sagaEffects.fork(worker, action)\n  }\n\n  getLogger().trace('pubSubWorker ended')\n}\n", "import {\n  BaseComponentOptions,\n  connect,\n  JSONRPCSubscribeMethod,\n  ExecuteParams,\n  actions,\n  EventEmitter,\n  validateEventsToSubscribe,\n  BaseConsumer,\n} from '..'\nimport { getAuthState } from '../redux/features/session/sessionSelectors'\nimport type {\n  PubSubChannel,\n  InternalPubSubChannel,\n  PubSubPublishParams,\n  PubSubMessageEventName,\n} from '../types/pubSub'\nimport { PRODUCT_PREFIX_PUBSUB } from '../utils/constants'\nimport { PubSubMessage } from './PubSubMessage'\nimport { pubSubWorker } from './workers/pubSubWorker'\n\nexport type BasePubSubApiEventsHandlerMapping = Record<\n  PubSubMessageEventName,\n  (message: PubSubMessage) => void\n>\n\n/**\n * @privateRemarks\n *\n * Each package will have the option to either extend this\n * type or provide their own event mapping.\n */\nexport type BasePubSubApiEvents<T = BasePubSubApiEventsHandlerMapping> = {\n  [k in keyof T]: T[k]\n}\n\nconst toInternalPubSubChannels = (\n  channels: string[]\n): InternalPubSubChannel[] => {\n  return channels.map((name) => {\n    return {\n      name,\n    }\n  })\n}\n\nexport class BasePubSubConsumer<\n  EventTypes extends EventEmitter.ValidEventTypes = BasePubSubApiEvents\n> extends BaseConsumer<EventTypes> {\n  protected override subscribeMethod: JSONRPCSubscribeMethod = `${PRODUCT_PREFIX_PUBSUB}.subscribe`\n\n  constructor(options: BaseComponentOptions) {\n    super(options)\n\n    // Initialize worker through a function so that it can be override by the BaseChatConsumer\n    this.initWorker()\n  }\n\n  protected initWorker() {\n    this.runWorker('pubSub', { worker: pubSubWorker })\n  }\n\n  private _getChannelsParam(\n    channels: string | string[] | undefined,\n    method: 'subscribe' | 'unsubscribe'\n  ) {\n    const _channels =\n      !channels || Array.isArray(channels) ? channels : [channels]\n\n    if (!Array.isArray(_channels) || _channels.length === 0) {\n      throw new Error(\n        `Please specify one or more channels when calling .${method}()`\n      )\n    }\n\n    return {\n      channels: toInternalPubSubChannels(_channels),\n    }\n  }\n\n  /** @internal */\n  protected _setSubscribeParams(params: Record<string, any>) {\n    this.subscribeParams = {\n      ...this.subscribeParams,\n      ...params,\n    }\n  }\n\n  /** @internal */\n  protected _getSubscribeParams({ channels }: { channels?: PubSubChannel }) {\n    return {\n      ...this._getChannelsParam(channels, 'subscribe'),\n    }\n  }\n\n  /** @internal */\n  protected _getUnsubscribeParams({ channels }: { channels?: PubSubChannel }) {\n    const channelsParam = this._getChannelsParam(channels, 'unsubscribe')\n\n    return {\n      ...channelsParam,\n    }\n  }\n\n  private _checkMissingSubscriptions() {\n    const subscriptions = this.getSubscriptions()\n    if (subscriptions.length === 0) {\n      this.logger.info(\n        'Subscribe was called before any listeners were attached. Move `.subscribe()` right after your event listeners to suppress this message.'\n      )\n      // @ts-ignore\n      this.once('message', () => {})\n    }\n  }\n\n  /** @internal */\n  protected override getSubscriptions() {\n    const eventNamesWithPrefix = this.eventNames().map(\n      (event) => `${PRODUCT_PREFIX_PUBSUB}.${String(event)}`\n    ) as EventEmitter.EventNames<EventTypes>[]\n    return validateEventsToSubscribe(eventNamesWithPrefix)\n  }\n\n  async subscribe(channels?: PubSubChannel) {\n    this._checkMissingSubscriptions()\n\n    const params = this._getSubscribeParams({ channels })\n\n    this._setSubscribeParams(params)\n\n    return super.subscribe()\n  }\n\n  async unsubscribe(channels: PubSubChannel): Promise<void> {\n    if (\n      this._sessionAuthStatus === 'unknown' ||\n      this._sessionAuthStatus === 'unauthorized'\n    ) {\n      throw new Error('You must be authenticated to unsubscribe from a channel')\n    }\n\n    const params = this._getUnsubscribeParams({ channels })\n\n    return new Promise(async (resolve, reject) => {\n      const subscriptions = this.getSubscriptions()\n\n      if (subscriptions.length > 0) {\n        const execParams: ExecuteParams = {\n          method: `${PRODUCT_PREFIX_PUBSUB}.unsubscribe`,\n          params: {\n            ...params,\n            events: subscriptions,\n          },\n        }\n\n        try {\n          await this.execute(execParams)\n        } catch (error) {\n          return reject(error)\n        }\n      } else {\n        this.logger.warn(\n          '`unsubscribe()` was called without any listeners attached.'\n        )\n      }\n\n      return resolve()\n    })\n  }\n\n  // Currently only `js` supports this features and it's\n  // being ignored (filtered at the Proxy level) within\n  // `realtime-api`\n  updateToken(token: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.session.once('session.auth_error', (error) => {\n        reject(error)\n      })\n      this.session.once('session.connected', () => {\n        resolve()\n      })\n\n      this.store.dispatch(actions.reauthAction({ token }))\n    })\n  }\n\n  publish(params: PubSubPublishParams) {\n    return this.execute({\n      method: `${PRODUCT_PREFIX_PUBSUB}.publish`,\n      params,\n    })\n  }\n\n  // Currently only `js` supports this features and it's\n  // being ignored (filtered at the Proxy level) within\n  // `realtime-api`\n  async getAllowedChannels() {\n    await this._waitUntilSessionAuthorized()\n    const authState = this.select(getAuthState)\n    if (authState && 'channels' in authState && authState.channels) {\n      return authState.channels\n    }\n    return {}\n  }\n}\n\nexport const createBasePubSubObject = <PubSubType>(\n  params: BaseComponentOptions\n) => {\n  const pubSub = connect<BasePubSubApiEvents, BasePubSubConsumer, PubSubType>({\n    store: params.store,\n    Component: BasePubSubConsumer,\n  })(params)\n\n  return pubSub\n}\n", "import { PubSubMessageContract } from '..'\n\n/**\n * Represents a message in a pubSub context.\n */\nexport class PubSubMessage<\n  PayloadType extends PubSubMessageContract = PubSubMessageContract\n> implements PubSubMessageContract\n{\n  constructor(protected payload: PayloadType) {}\n\n  /** The id of this message */\n  get id(): string {\n    return this.payload.id\n  }\n\n  /** The channel in which this message was sent */\n  get channel(): string {\n    return this.payload.channel\n  }\n\n  /** The content of this message */\n  get content(): string {\n    return this.payload.content\n  }\n\n  /** Any metadata associated to this message */\n  get meta(): any {\n    return this.payload.meta\n  }\n\n  /** The date at which this message was published */\n  get publishedAt(): Date {\n    return this.payload.publishedAt\n  }\n}\n", "import { SagaIterator } from '@redux-saga/core'\nimport { BaseChatConsumer } from '../BaseChat'\nimport {\n  sagaEffects,\n  SDKWorker,\n  getLogger,\n  ChatAction,\n  toExternalJSON,\n  ChatMessage,\n  ChatMember,\n  SDKActions,\n  stripNamespacePrefix,\n  ChatMemberEventNames,\n} from '../../index'\n\nexport const chatWorker: SDKWorker<BaseChatConsumer> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('chatWorker started')\n  const {\n    instance: client,\n    channels: { swEventChannel },\n  } = options\n\n  function* worker(action: ChatAction) {\n    const { type, payload } = action\n\n    switch (type) {\n      case 'chat.channel.message': {\n        const { channel, message } = payload\n        const externalJSON = toExternalJSON({\n          ...message,\n          channel,\n        })\n        const chatMessage = new ChatMessage(externalJSON)\n\n        client.emit('message', chatMessage)\n        break\n      }\n      case 'chat.member.joined':\n      case 'chat.member.updated':\n      case 'chat.member.left': {\n        const { member } = payload\n        const externalJSON = toExternalJSON(member)\n        const chatMessage = new ChatMember(externalJSON)\n\n        const event = stripNamespacePrefix(type) as ChatMemberEventNames\n        client.emit(event, chatMessage)\n        break\n      }\n      default:\n        getLogger().warn(`Unknown chat event: \"${type}\"`)\n        break\n    }\n  }\n\n  const isChatEvent = (action: SDKActions) => action.type.startsWith('chat.')\n\n  while (true) {\n    const action: ChatAction = yield sagaEffects.take(\n      swEventChannel,\n      isChatEvent\n    )\n\n    yield sagaEffects.fork(worker, action)\n  }\n\n  getLogger().trace('chatWorker ended')\n}\n", "import {\n  BaseComponentOptions,\n  connect,\n  extendComponent,\n  JSONRPCSubscribeMethod,\n} from '..'\nimport { BasePubSubConsumer } from '../pubSub'\nimport type {\n  ChatMemberEventNames,\n  ChatMessageEventName,\n  ChatMethods,\n} from '../types/chat'\nimport { PRODUCT_PREFIX_CHAT } from '../utils/constants'\nimport { ChatMember } from './ChatMember'\nimport { ChatMessage } from './ChatMessage'\nimport * as chatMethods from './methods'\nimport { chatWorker } from './workers/chatWorker'\n\nexport type BaseChatApiEventsHandlerMapping = Record<\n  ChatMessageEventName,\n  (message: ChatMessage) => void\n> &\n  Record<ChatMemberEventNames, (member: ChatMember) => void>\n\n/**\n * @privateRemarks\n *\n * Each package will have the option to either extend this\n * type or provide their own event mapping.\n */\nexport type BaseChatApiEvents<T = BaseChatApiEventsHandlerMapping> = {\n  [k in keyof T]: T[k]\n}\n\nexport class BaseChatConsumer extends BasePubSubConsumer<BaseChatApiEvents> {\n  protected override subscribeMethod: JSONRPCSubscribeMethod = `${PRODUCT_PREFIX_CHAT}.subscribe`\n\n  constructor(options: BaseComponentOptions) {\n    super(options)\n  }\n\n  protected override initWorker() {\n    this.runWorker('chat', { worker: chatWorker })\n  }\n}\n\nexport const BaseChatAPI = extendComponent<BaseChatConsumer, ChatMethods>(\n  BaseChatConsumer,\n  {\n    publish: chatMethods.publish,\n    getMembers: chatMethods.getMembers,\n    getMessages: chatMethods.getMessages,\n    setMemberState: chatMethods.setMemberState,\n    getMemberState: chatMethods.getMemberState,\n  }\n)\n\nexport const createBaseChatObject = <ChatType>(\n  params: BaseComponentOptions\n) => {\n  const chat = connect<BaseChatApiEvents, BaseChatConsumer, ChatType>({\n    store: params.store,\n    Component: BaseChatAPI,\n  })(params)\n\n  return chat\n}\n", "import { ChatMessageContract, ChatMemberContract } from '..'\nimport { PubSubMessage } from '../pubSub'\n\n/**\n * Represents a message in a chat.\n */\nexport class ChatMessage extends PubSubMessage<ChatMessageContract> {\n  /** The member which sent this message */\n  get member(): ChatMemberContract {\n    return this.payload.member\n  }\n}\n", "import { ChatMemberContract } from '..'\n\n/**\n * Represents a member in a chat.\n */\nexport class ChatMember implements ChatMemberContract {\n  constructor(private payload: ChatMemberContract) {}\n\n  /** The id of this member */\n  get id(): string {\n    return this.payload.id\n  }\n\n  /** The channel of this member */\n  get channel(): string {\n    return this.payload.channel\n  }\n\n  /** The state of this member */\n  get state(): any {\n    return this.payload.state ?? {}\n  }\n}\n", "export * from './workers'\n", "import { fork } from '@redux-saga/core/effects'\nimport {\n  InternalMemberUpdatedEventNames,\n  sagaEffects,\n  SagaIterator,\n  SDKWorker,\n  SDKWorkerParams,\n  stripNamespacePrefix,\n  VideoMemberUpdatedEventParams,\n  VideoPosition,\n  VideoRoomSubscribedEventParams,\n} from '..'\n\n/**\n * These workers are shared between the realtime-api and the browser SDK\n * For the realtime-api: we pass the dispatcher function since we emit RoomSessionMember instance\n * For the browser SDK: we use the default dispatcher function since we emit whatever we get from the server\n */\n\nconst defaultDispatcher = function* (\n  type: string,\n  payload: any,\n  instance?: any\n) {\n  instance.emit(type, payload)\n}\n\nfunction* memberPositionLayoutChangedWorker(options: any) {\n  const {\n    action,\n    memberList,\n    instance,\n    dispatcher = defaultDispatcher,\n  } = options\n  const layers = action.payload.layout.layers\n  const processedMembers: Record<string, boolean> = {}\n\n  layers.forEach((layer: any) => {\n    const memberId = layer.member_id\n    if (!memberId) {\n      return\n    }\n\n    const memberEventParams = memberList.get(memberId)\n\n    if (\n      memberEventParams &&\n      layer.position !== memberEventParams.member?.current_position\n    ) {\n      mutateMemberCurrentPosition({\n        memberList,\n        memberId,\n        currentPosition: layer.position,\n      })\n      processedMembers[memberId] = true\n    } else {\n      // Values marked as false won't be put to `pubSubChannel`\n      processedMembers[memberId] = false\n    }\n  })\n\n  for (const [memberId, payload] of memberList) {\n    if (processedMembers[memberId]) {\n      yield dispatcher?.('member.updated', payload, instance)\n\n      /**\n       * `undefined` means that we couldn't find the\n       * `memberId` inside the `layout.layers` array, which\n       * implies that the user should now be off-canvas\n       */\n    } else if (processedMembers[memberId] === undefined) {\n      const updatedMemberEventParams = mutateMemberCurrentPosition({\n        memberList,\n        memberId,\n        currentPosition: 'off-canvas',\n      })\n\n      if (!updatedMemberEventParams) {\n        return\n      }\n\n      yield dispatcher?.('member.updated', updatedMemberEventParams, instance)\n    }\n  }\n}\n\nexport function* memberUpdatedWorker({\n  action,\n  memberList,\n  instance,\n  dispatcher = defaultDispatcher,\n}: Omit<SDKWorkerParams<any>, 'runSaga'> & {\n  memberList: MemberEventParamsList\n  action: any\n}) {\n  const memberId = action.payload.member.id\n  const updatedMemberEventParams = mutateMemberCurrentPosition({\n    memberList,\n    memberId,\n    currentPosition: memberList.get(memberId)?.member?.current_position,\n  })\n\n  if (!updatedMemberEventParams) {\n    return\n  }\n\n  const {\n    member: { updated = [] },\n  } = action.payload\n\n  const memberUpdatedPayload = {\n    ...updatedMemberEventParams,\n    member: {\n      ...updatedMemberEventParams.member,\n      ...action.payload.member,\n    },\n  }\n  /** member.updated event is the only one updating the memberList payload */\n  memberList.set(memberId, memberUpdatedPayload)\n\n  const event = stripNamespacePrefix(action.type)\n  for (const key of updated) {\n    const type = `${event}.${key}` as InternalMemberUpdatedEventNames\n    yield dispatcher?.(type, memberUpdatedPayload, instance)\n  }\n\n  yield dispatcher?.(event, memberUpdatedPayload, instance)\n}\n\nexport const MEMBER_POSITION_COMPOUND_EVENTS = new Map<any, any>([\n  [\n    'video.member.updated',\n    [\n      'video.layout.changed',\n      // `member.joined` and `member.left` are needed to\n      // keep the member list up to date\n      'video.member.joined',\n      'video.member.left',\n    ],\n  ],\n])\n\nexport const memberPositionWorker: SDKWorker<any> =\n  function* memberPositionWorker({\n    instance,\n    channels,\n    initialState,\n    getSession,\n    instanceMap,\n    dispatcher = defaultDispatcher,\n  }): SagaIterator {\n    if (!initialState) {\n      return\n    }\n\n    const { swEventChannel } = channels\n    let memberList = initializeMemberList(initialState)\n\n    const addToMemberList = (payload: VideoMemberUpdatedEventParams) => {\n      /**\n       * Add to memberList for both `member.joined` and `member.updated`\n       * note: changes made for audience users.\n       */\n      if (!memberList.has(payload.member.id)) {\n        memberList.set(payload.member.id, payload)\n      }\n    }\n\n    while (true) {\n      const action = yield sagaEffects.take(swEventChannel, (action: any) => {\n        const istargetEvent =\n          action.type === 'video.member.updated' ||\n          action.type === 'video.layout.changed' ||\n          action.type === 'video.member.joined' ||\n          action.type === 'video.member.left'\n\n        return istargetEvent\n      })\n\n      switch (action.type) {\n        case 'video.member.updated': {\n          addToMemberList(action.payload)\n          yield fork(memberUpdatedWorker, {\n            action,\n            channels,\n            memberList,\n            instance,\n            getSession,\n            instanceMap,\n            dispatcher,\n          })\n          break\n        }\n        case 'video.member.joined': {\n          addToMemberList(action.payload)\n          break\n        }\n        case 'video.member.left': {\n          const member = action.payload.member\n          memberList.delete(member.id)\n          break\n        }\n        case 'video.layout.changed': {\n          yield fork(memberPositionLayoutChangedWorker, {\n            action,\n            channels,\n            memberList,\n            instance,\n            dispatcher,\n          })\n          break\n        }\n      }\n    }\n  }\n\ntype MemberEventParamsList = Map<string, VideoMemberUpdatedEventParams>\n\nconst mutateMemberCurrentPosition = ({\n  memberList,\n  memberId,\n  currentPosition,\n}: {\n  memberList: MemberEventParamsList\n  memberId: string\n  currentPosition?: VideoPosition\n}) => {\n  const memberEventParams = memberList.get(memberId)\n\n  if (!memberEventParams) {\n    return\n\n    // This is to avoid setting an undefined property\n  } else if (!currentPosition) {\n    return memberEventParams\n  }\n\n  const updatedMemberEventParams: VideoMemberUpdatedEventParams = {\n    ...memberEventParams,\n    member: {\n      ...memberEventParams?.member,\n      current_position: currentPosition,\n    },\n  }\n  memberList.set(memberId, updatedMemberEventParams)\n\n  return updatedMemberEventParams\n}\n\nconst initializeMemberList = (payload: VideoRoomSubscribedEventParams) => {\n  const members = payload.room_session.members\n  const memberList: MemberEventParamsList = new Map()\n\n  members.forEach((member) => {\n    memberList.set(member.id, {\n      room_id: payload.room_session.room_id,\n      room_session_id: payload.room_session.id,\n      // At this point we don't have `member.updated`\n      // @ts-expect-error\n      member,\n    })\n  })\n\n  return memberList\n}\n", "import { channel, multicastChannel } from '@redux-saga/core'\nimport { configureStore, ConfigureStoreOptions, SDKStore } from './redux'\nimport { SwEventChannel, SessionChannel } from './redux/interfaces'\nimport { BaseSession } from './BaseSession'\nimport { RPCConnectResult, InternalSDKLogger } from './utils/interfaces'\nimport { EventEmitter } from './utils/EventEmitter'\nimport { actions } from '.'\n\nconst PROJECT_ID = '8f0a119a-cda7-4497-a47d-c81493b824d4'\nconst TOKEN = '<VRT>'\n\nexport const createMockedLogger = (): InternalSDKLogger => ({\n  fatal: jest.fn(),\n  error: jest.fn(),\n  warn: jest.fn(),\n  info: jest.fn(),\n  debug: jest.fn(),\n  trace: jest.fn(),\n  wsTraffic: jest.fn(),\n})\n\n/**\n * Helper method to configure a Store w/o Saga middleware.\n * Useful to test slices and reducers logic.\n *\n * @returns Redux Store\n */\nexport const configureJestStore = (\n  options?: Partial<ConfigureStoreOptions>\n) => {\n  return configureStore({\n    userOptions: {\n      project: PROJECT_ID,\n      token: TOKEN,\n      devTools: false,\n      emitter: new EventEmitter(),\n    },\n    SessionConstructor: BaseSession,\n    runSagaMiddleware: false,\n    ...options,\n  }) as SDKStore\n}\n\n/**\n * Helper method to configure a Store with a rootSaga\n * and a mocked Session object.\n * This allow to write integration tests.\n *\n * @returns { store, session, emitter, destroy }\n */\nexport const configureFullStack = () => {\n  const session = {\n    dispatch: console.log,\n    connect: jest.fn(),\n    disconnect: jest.fn(),\n    execute: jest.fn(),\n  }\n  const emitter = new EventEmitter()\n  const store = configureStore({\n    userOptions: {\n      project: PROJECT_ID,\n      token: TOKEN,\n      devTools: false,\n      emitter,\n    },\n    SessionConstructor: jest.fn().mockImplementation(() => {\n      return session\n    }),\n  })\n\n  store.dispatch(actions.initAction())\n  store.dispatch(actions.authSuccessAction())\n\n  return {\n    store,\n    session,\n    emitter,\n    destroy: () => store.dispatch(actions.destroyAction()),\n  }\n}\n\nexport const wait = (ms: number) => {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms)\n  })\n}\n\nexport const rpcConnectResultVRT: RPCConnectResult = {\n  identity:\n    'f3bc99df-2c3d-4fa4-b1dc-e8a8ffc579e6@e3fefa44-1bad-4be9-ad9b-1cbb9abd60c7.west-us',\n  authorization: {\n    type: 'video',\n    project_id: '8f0a119a-cda7-4497-a47d-c81493b824d4',\n    project: '8f0a119a-cda7-4497-a47d-c81493b824d4',\n    scopes: ['video'],\n    scope_id: '26675883-8499-4ee9-85eb-691c4aa209f8',\n    resource: '9c80f1e8-9430-4070-a043-937eb3a96b38',\n    join_as: 'member',\n    user_name: 'Joe',\n    room: {\n      name: 'lobby',\n      display_name: 'Lobby',\n      scopes: ['room.self.audio_mute', 'room.self.audio_unmute'],\n      meta: {},\n    },\n    signature:\n      'SGZtkRD9fvuBAOUp1UF56zESxdEvGT6qSGZtkRD9fvuBAOUp1UF56zESxdEvGT6q',\n    media_allowed: 'all',\n    audio_allowed: 'both',\n    video_allowed: 'both',\n    meta: {},\n  },\n  protocol:\n    'signalwire_SGZtkRD9fvuBAOUp1UF56zESxdEvGT6qSGZtkRD9fvuBAOUp1UF56zESxdEvGT6q_03e8c927-8ea3-4661-86d5-778c3e03296a_8f0a119a-cda7-4497-a47d-c81493b824d4',\n  ice_servers: [\n    {\n      urls: 'turn.swire.io:443',\n      credential: 'sFTwvi8ShXcYNOcyYjFy3ATIUpQ=',\n      credentialType: 'password',\n      username: '1619521908:8f0a119a-cda7-4497-a47d-c81493b824d4',\n    },\n  ],\n}\n\nexport const createSwEventChannel = (): SwEventChannel => multicastChannel()\nexport const createSessionChannel = (): SessionChannel => channel()\n"],
  "mappings": "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",
  "names": []
}
