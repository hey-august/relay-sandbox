import type { Task } from '@redux-saga/types';
import { Action } from './redux';
import { ExecuteParams, BaseComponentOptions, ExecuteExtendedOptions, SDKWorker, SDKWorkerDefinition, SessionAuthStatus, SDKWorkerHooks, Authorization } from './utils/interfaces';
import { EventEmitter } from './utils/EventEmitter';
import { SDKState } from './redux/interfaces';
import { OnlyStateProperties, EmitterContract, BaseComponentContract } from './types';
export declare const SW_SYMBOL: unique symbol;
export declare class BaseComponent<EventTypes extends EventEmitter.ValidEventTypes, StateProperties = Record<string, unknown>> implements EmitterContract<EventTypes>, BaseComponentContract {
    options: BaseComponentOptions;
    /** @internal */
    __sw_symbol: symbol;
    /** @internal */
    private readonly uuid;
    /** @internal */
    get __uuid(): string;
    private _customSagaTriggers;
    private _destroyer?;
    private eventEmitter;
    /**
     * List of running Tasks to be cancelled on `destroy`.
     */
    private _runningWorkers;
    protected get logger(): import("./utils/interfaces").InternalSDKLogger;
    /**
     * Map of Sagas that will be attached to the Store to
     * handle events or perform side-effects. This Map will
     * behave as a queue and will be emptied once the workers
     * have been attached. See `this.attachWorkers` for
     * details.
     */
    protected _workers: Map<string, {
        worker: SDKWorker<any>;
    }>;
    constructor(options: BaseComponentOptions);
    /** @internal */
    set destroyer(d: () => void);
    /** @internal */
    get store(): {
        runSaga: <T>(saga: import("@redux-saga/types").Saga<any[]>, args: {
            instance: T;
            runSaga: any;
        }) => Task<any>;
        channels: import("./utils/interfaces").InternalChannels;
        instanceMap: {
            get: <T_1 extends unknown>(key: string) => T_1;
            set: <T_2 extends unknown>(key: string, value: T_2) => Map<string, unknown>;
            remove: (key: string) => Map<string, unknown>;
        };
        sessionEmitter: EventEmitter<import("./utils/interfaces").ClientEvents, any>;
        dispatch: import("redux").Dispatch<import("redux").AnyAction>;
        getState(): any;
        subscribe(listener: () => void): import("redux").Unsubscribe;
        replaceReducer(nextReducer: import("redux").Reducer<any, import("redux").AnyAction>): void;
        [Symbol.observable](): import("redux").Observable<any>;
    };
    /** @internal */
    get instanceMap(): {
        get: <T extends unknown>(key: string) => T;
        set: <T_1 extends unknown>(key: string, value: T_1) => Map<string, unknown>;
        remove: (key: string) => Map<string, unknown>;
    };
    /** @internal */
    get emitter(): EventEmitter<EventTypes, any>;
    /** @internal */
    get sessionEmitter(): EventEmitter<import("./utils/interfaces").ClientEvents, any>;
    /** @internal */
    get session(): EventEmitter<import("./utils/interfaces").ClientEvents, any>;
    on<T extends EventEmitter.EventNames<EventTypes>>(event: T, fn: EventEmitter.EventListener<EventTypes, T>): EventEmitter<EventTypes, any>;
    once<T extends EventEmitter.EventNames<EventTypes>>(event: T, fn: EventEmitter.EventListener<EventTypes, T>): EventEmitter<EventTypes, any>;
    off<T extends EventEmitter.EventNames<EventTypes>>(event: T, fn?: EventEmitter.EventListener<EventTypes, T>): EventEmitter<EventTypes, any>;
    removeAllListeners<T extends EventEmitter.EventNames<EventTypes>>(event?: T): EventEmitter<EventTypes, any>;
    /** @internal */
    eventNames(): EventEmitter.EventNames<EventTypes>[];
    /** @internal */
    sessionEventNames(): ("session.unknown" | "session.idle" | "session.reconnecting" | "session.connected" | "session.disconnecting" | "session.disconnected" | "session.auth_error" | "session.expiring")[];
    protected getSubscriptions(): EventEmitter.EventNames<EventTypes>[];
    /** @internal */
    emit(event: EventEmitter.EventNames<EventTypes>, ...args: any[]): boolean;
    /** @internal */
    listenerCount<T extends EventEmitter.EventNames<EventTypes>>(event: T): number;
    destroy(): void;
    /** @internal */
    execute<InputType = unknown, OutputType = unknown, ParamsType = Record<string, any>>({ method, params }: ExecuteParams, { transformParams, transformResolve, transformReject, }?: ExecuteExtendedOptions<InputType, OutputType, ParamsType>): Promise<OutputType>;
    /** @internal */
    triggerCustomSaga<T>(action: Action): Promise<T>;
    /** @internal */
    settleCustomSagaTrigger<T>({ dispatchId, payload, kind, }: {
        dispatchId: string;
        payload?: T;
        kind: 'resolve' | 'reject';
    }): void;
    /** @internal */
    select<T>(selectorFn: (state: SDKState) => T): T;
    /** @internal */
    getStateProperty(param: keyof OnlyStateProperties<StateProperties>): any;
    /** @internal */
    protected get _sessionAuthStatus(): SessionAuthStatus;
    /** @internal */
    protected get _sessionAuthState(): Authorization | undefined;
    /** @internal */
    protected _waitUntilSessionAuthorized(): Promise<this>;
    /** @internal */
    protected runWorker<Hooks extends SDKWorkerHooks = SDKWorkerHooks>(name: string, def: SDKWorkerDefinition<Hooks>): Task<any>;
    private _setWorker;
    private _attachWorker;
    private detachWorkers;
}
//# sourceMappingURL=BaseComponent.d.ts.map