"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBasePubSubObject = exports.BasePubSubConsumer = void 0;
const tslib_1 = require("tslib");
const __1 = require("..");
const sessionSelectors_1 = require("../redux/features/session/sessionSelectors");
const constants_1 = require("../utils/constants");
const pubSubWorker_1 = require("./workers/pubSubWorker");
const toInternalPubSubChannels = (channels) => {
    return channels.map((name) => {
        return {
            name,
        };
    });
};
class BasePubSubConsumer extends __1.BaseConsumer {
    constructor(options) {
        super(options);
        this.subscribeMethod = `${constants_1.PRODUCT_PREFIX_PUBSUB}.subscribe`;
        // Initialize worker through a function so that it can be override by the BaseChatConsumer
        this.initWorker();
    }
    initWorker() {
        this.runWorker('pubSub', { worker: pubSubWorker_1.pubSubWorker });
    }
    _getChannelsParam(channels, method) {
        const _channels = !channels || Array.isArray(channels) ? channels : [channels];
        if (!Array.isArray(_channels) || _channels.length === 0) {
            throw new Error(`Please specify one or more channels when calling .${method}()`);
        }
        return {
            channels: toInternalPubSubChannels(_channels),
        };
    }
    /** @internal */
    _setSubscribeParams(params) {
        this.subscribeParams = Object.assign(Object.assign({}, this.subscribeParams), params);
    }
    /** @internal */
    _getSubscribeParams({ channels }) {
        return Object.assign({}, this._getChannelsParam(channels, 'subscribe'));
    }
    /** @internal */
    _getUnsubscribeParams({ channels }) {
        const channelsParam = this._getChannelsParam(channels, 'unsubscribe');
        return Object.assign({}, channelsParam);
    }
    _checkMissingSubscriptions() {
        const subscriptions = this.getSubscriptions();
        if (subscriptions.length === 0) {
            this.logger.info('Subscribe was called before any listeners were attached. Move `.subscribe()` right after your event listeners to suppress this message.');
            // @ts-ignore
            this.once('message', () => { });
        }
    }
    /** @internal */
    getSubscriptions() {
        const eventNamesWithPrefix = this.eventNames().map((event) => `${constants_1.PRODUCT_PREFIX_PUBSUB}.${String(event)}`);
        return (0, __1.validateEventsToSubscribe)(eventNamesWithPrefix);
    }
    subscribe(channels) {
        const _super = Object.create(null, {
            subscribe: { get: () => super.subscribe }
        });
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this._checkMissingSubscriptions();
            const params = this._getSubscribeParams({ channels });
            this._setSubscribeParams(params);
            return _super.subscribe.call(this);
        });
    }
    unsubscribe(channels) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this._sessionAuthStatus === 'unknown' ||
                this._sessionAuthStatus === 'unauthorized') {
                throw new Error('You must be authenticated to unsubscribe from a channel');
            }
            const params = this._getUnsubscribeParams({ channels });
            return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const subscriptions = this.getSubscriptions();
                if (subscriptions.length > 0) {
                    const execParams = {
                        method: `${constants_1.PRODUCT_PREFIX_PUBSUB}.unsubscribe`,
                        params: Object.assign(Object.assign({}, params), { events: subscriptions }),
                    };
                    try {
                        yield this.execute(execParams);
                    }
                    catch (error) {
                        return reject(error);
                    }
                }
                else {
                    this.logger.warn('`unsubscribe()` was called without any listeners attached.');
                }
                return resolve();
            }));
        });
    }
    // Currently only `js` supports this features and it's
    // being ignored (filtered at the Proxy level) within
    // `realtime-api`
    updateToken(token) {
        return new Promise((resolve, reject) => {
            this.session.once('session.auth_error', (error) => {
                reject(error);
            });
            this.session.once('session.connected', () => {
                resolve();
            });
            this.store.dispatch(__1.actions.reauthAction({ token }));
        });
    }
    publish(params) {
        return this.execute({
            method: `${constants_1.PRODUCT_PREFIX_PUBSUB}.publish`,
            params,
        });
    }
    // Currently only `js` supports this features and it's
    // being ignored (filtered at the Proxy level) within
    // `realtime-api`
    getAllowedChannels() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this._waitUntilSessionAuthorized();
            const authState = this.select(sessionSelectors_1.getAuthState);
            if (authState && 'channels' in authState && authState.channels) {
                return authState.channels;
            }
            return {};
        });
    }
}
exports.BasePubSubConsumer = BasePubSubConsumer;
const createBasePubSubObject = (params) => {
    const pubSub = (0, __1.connect)({
        store: params.store,
        Component: BasePubSubConsumer,
    })(params);
    return pubSub;
};
exports.createBasePubSubObject = createBasePubSubObject;
//# sourceMappingURL=BasePubSub.js.map