"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseConsumer = void 0;
const tslib_1 = require("tslib");
const _1 = require(".");
/**
 * Instances of this class are meant to be wrapped by a
 * Proxy that intercepts the `_eventsNamespace` (to tell the
 * BaseComponent it's fine to attach the event listeners)
 * and the `eventChannel`
 * @internal
 */
class BaseConsumer extends _1.BaseComponent {
    constructor(options) {
        super(options);
        this.options = options;
        this.subscribeMethod = 'signalwire.subscribe';
        this.subscribeParams = {};
        /**
         * TODO: To Review
         * Reset _latestExecuteParams when on session connect/disconnet
         * so a reconnected client can send subscribe again.
         */
        const resetLatestExecuteParams = () => {
            this._latestExecuteParams = undefined;
        };
        super.session.on('session.connected', resetLatestExecuteParams);
        super.session.on('session.disconnected', resetLatestExecuteParams);
        super.session.on('session.reconnecting', resetLatestExecuteParams);
    }
    shouldExecuteSubscribe(execParams) {
        return (!this._latestExecuteParams ||
            JSON.stringify(execParams) !== JSON.stringify(this._latestExecuteParams));
    }
    subscribe() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this._waitUntilSessionAuthorized();
            const subscriptions = this.getSubscriptions();
            if (subscriptions.length === 0) {
                this.logger.debug('`subscribe()` was called without any listeners attached.');
                return;
            }
            const execParams = {
                method: this.subscribeMethod,
                params: Object.assign(Object.assign({}, this.subscribeParams), { event_channel: this.getStateProperty('eventChannel'), events: subscriptions }),
            };
            if (!this.shouldExecuteSubscribe(execParams)) {
                this.logger.debug('BaseConsumer.subscribe() - Skipped .execute() since the execParams are exactly the same as last time');
                return;
            }
            this._latestExecuteParams = execParams;
            return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield this.execute(execParams);
                    return resolve(undefined);
                }
                catch (error) {
                    return reject(error);
                }
            }));
        });
    }
}
exports.BaseConsumer = BaseConsumer;
//# sourceMappingURL=BaseConsumer.js.map