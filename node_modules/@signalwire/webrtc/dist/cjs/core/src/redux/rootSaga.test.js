"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const redux_saga_test_plan_1 = require("redux-saga-test-plan");
const testing_utils_1 = require("@redux-saga/testing-utils");
const rootSaga_1 = tslib_1.__importStar(require("./rootSaga"));
const sessionSaga_1 = require("./features/session/sessionSaga");
const features_1 = require("./features");
const actions_1 = require("./actions");
const CustomErrors_1 = require("../CustomErrors");
const testUtils_1 = require("../testUtils");
describe('sessionStatusWatcher', () => {
    const actions = [
        actions_1.authSuccessAction.type,
        actions_1.authErrorAction.type,
        actions_1.authExpiringAction.type,
        actions_1.reauthAction.type,
        actions_1.sessionReconnectingAction.type,
        actions_1.sessionForceCloseAction.type,
    ];
    const session = {
        closed: true,
        connect: jest.fn(),
        disconnect: jest.fn(),
    };
    const sessionChannel = (0, testUtils_1.createSessionChannel)();
    const mockEmitter = { emit: jest.fn() };
    const sessionEmitter = { emit: jest.fn() };
    const userOptions = { token: '', emitter: mockEmitter };
    const options = {
        session,
        sessionChannel,
        sessionEmitter,
        userOptions,
    };
    it('should fork startSaga on authSuccess action', () => {
        const saga = (0, redux_saga_test_plan_1.testSaga)(rootSaga_1.sessionStatusWatcher, options);
        saga.next().take(actions);
        saga
            .next((0, actions_1.authSuccessAction)())
            .put(features_1.sessionActions.connected(session.rpcConnectResult))
            .next();
        expect(sessionEmitter.emit).toHaveBeenCalledWith('session.connected');
        // Saga waits again for actions due to the while loop
        const firstSagaTask = (0, testing_utils_1.createMockTask)();
        saga.next(firstSagaTask).take(actions);
    });
    it('should fork sessionAuthErrorSaga on authError action and emit destroyAction', () => {
        let runSaga = true;
        const action = (0, actions_1.authErrorAction)({
            error: { code: 123, message: 'Protocol Error' },
        });
        const error = new CustomErrors_1.AuthError(123, 'Protocol Error');
        return (0, redux_saga_test_plan_1.expectSaga)(rootSaga_1.sessionStatusWatcher, options)
            .provide([
            {
                take(_opts, next) {
                    if (runSaga) {
                        runSaga = false;
                        return action;
                    }
                    return next();
                },
            },
        ])
            .fork(rootSaga_1.sessionAuthErrorSaga, Object.assign(Object.assign({}, options), { action }))
            .silentRun()
            .then(() => {
            expect(sessionEmitter.emit).toHaveBeenCalledWith('session.auth_error', error);
        });
    });
    it('should emit session.expiring on session emitter', () => {
        const saga = (0, redux_saga_test_plan_1.testSaga)(rootSaga_1.sessionStatusWatcher, options);
        saga.next().take(actions);
        saga.next((0, actions_1.authExpiringAction)());
        expect(sessionEmitter.emit).toHaveBeenCalledWith('session.expiring');
        // Saga waits again for actions due to the while loop
        saga.next();
    });
    it('should emit sessionReconnectingAction on the session emitter', () => {
        const saga = (0, redux_saga_test_plan_1.testSaga)(rootSaga_1.sessionStatusWatcher, options);
        saga.next().take(actions);
        saga.next((0, actions_1.sessionReconnectingAction)());
        expect(sessionEmitter.emit).toHaveBeenCalledWith('session.reconnecting');
        // Saga waits again for actions due to the while loop
        saga.next();
    });
});
describe('initSessionSaga', () => {
    const session = {
        connect: jest.fn(),
        disconnect: jest.fn(),
    };
    const initSession = jest.fn().mockImplementation(() => session);
    const sessionEmitter = { emit: jest.fn() };
    const userOptions = {
        token: '',
        emitter: jest.fn(),
    };
    beforeEach(() => {
        session.connect.mockClear();
        session.disconnect.mockClear();
        sessionEmitter.emit.mockClear();
    });
    it('should create the session, the sessionChannel and fork watchers', () => {
        const swEventChannel = (0, testUtils_1.createSwEventChannel)();
        swEventChannel.close = jest.fn();
        const sessionChannel = (0, testUtils_1.createSessionChannel)();
        sessionChannel.close = jest.fn();
        const saga = (0, redux_saga_test_plan_1.testSaga)(rootSaga_1.initSessionSaga, {
            initSession,
            userOptions,
            channels: { swEventChannel, sessionChannel },
            sessionEmitter,
        });
        saga.next(sessionChannel).fork(sessionSaga_1.sessionChannelWatcher, {
            session,
            sessionChannel,
            swEventChannel,
        });
        const sessionStatusTask = (0, testing_utils_1.createMockTask)();
        sessionStatusTask.cancel = jest.fn();
        saga.next();
        saga.next(sessionStatusTask).take(actions_1.destroyAction.type);
        saga.next().take(actions_1.sessionDisconnectedAction.type);
        saga.next();
        expect(sessionEmitter.emit).toHaveBeenCalledWith('session.disconnected');
        saga.next().isDone();
        expect(sessionStatusTask.cancel).toHaveBeenCalledTimes(1);
        expect(swEventChannel.close).not.toHaveBeenCalled();
        expect(session.connect).toHaveBeenCalledTimes(1);
        expect(session.disconnect).toHaveBeenCalledTimes(1);
    });
});
describe('rootSaga as restartable', () => {
    const swEventChannel = (0, testUtils_1.createSwEventChannel)();
    const sessionChannel = (0, testUtils_1.createSessionChannel)();
    const sessionEmitter = jest.fn();
    it('wait for initAction and fork initSessionSaga', () => {
        const session = {
            connect: jest.fn(),
        };
        const initSession = jest.fn().mockImplementation(() => session);
        const userOptions = { token: '', emitter: jest.fn() };
        const channels = { swEventChannel, sessionChannel };
        const saga = (0, redux_saga_test_plan_1.testSaga)((0, rootSaga_1.default)({
            initSession,
            // @ts-expect-error
            sessionEmitter,
        }), {
            userOptions,
            channels,
        });
        saga.next().take([actions_1.initAction.type, actions_1.reauthAction.type]);
        saga.next().call(rootSaga_1.initSessionSaga, {
            initSession,
            userOptions,
            channels,
            sessionEmitter,
        });
        saga.next().cancelled();
        saga.next().take([actions_1.initAction.type, actions_1.reauthAction.type]);
    });
});
//# sourceMappingURL=rootSaga.test.js.map