"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sessionChannelWatcher = void 0;
const effects_1 = require("@redux-saga/core/effects");
const sagaHelpers_1 = require("../../utils/sagaHelpers");
const actions_1 = require("../../actions");
const utils_1 = require("../../../utils");
// TODO: Move TypeGuards to its own module
const isWebrtcEvent = (e) => {
    return (0, utils_1.isWebrtcEventType)(e === null || e === void 0 ? void 0 : e.event_type);
};
const isVideoEvent = (e) => {
    var _a;
    return !!((_a = e === null || e === void 0 ? void 0 : e.event_type) === null || _a === void 0 ? void 0 : _a.startsWith('video.'));
};
const isSwAuthorizationState = (e) => {
    return (e === null || e === void 0 ? void 0 : e.event_type) === 'signalwire.authorization.state';
};
function* sessionChannelWatcher({ sessionChannel, swEventChannel, session, }) {
    function* swEventWorker(broadcastParams) {
        yield (0, effects_1.put)(swEventChannel, (0, utils_1.toInternalAction)(broadcastParams));
        if (isWebrtcEvent(broadcastParams) || isVideoEvent(broadcastParams)) {
            /**
             * Skip `webrtc.*` & `video.*` events.
             * There are custom workers handling them through `swEventChannel`
             */
            return;
        }
        if (isSwAuthorizationState(broadcastParams)) {
            session.onSwAuthorizationState(broadcastParams.params.authorization_state);
            return;
        }
        /**
         * Put actions with `event_type` to trigger all the children sagas
         * This should replace all the isWebrtcEvent/isVideoEvent guards below
         * since we'll move that logic on a separate package.
         */
        yield (0, effects_1.put)({ type: broadcastParams.event_type, payload: broadcastParams });
    }
    function* sessionChannelWorker(action) {
        if (action.type !== actions_1.socketMessageAction.type) {
            yield (0, effects_1.put)(action);
            return;
        }
        const { method, params } = action.payload;
        switch (method) {
            case 'signalwire.event':
                yield (0, effects_1.fork)(swEventWorker, params);
                break;
            default:
                return (0, utils_1.getLogger)().debug(`Unknown message: ${method}`, action);
        }
    }
    const sessionChannelWorkerCatchable = (0, sagaHelpers_1.createCatchableSaga)(sessionChannelWorker, (error) => {
        (0, utils_1.getLogger)().error('Channel Error', error);
    });
    /**
     * Make the watcher restartable
     */
    while (true) {
        try {
            while (true) {
                const action = yield (0, effects_1.take)(sessionChannel);
                yield (0, effects_1.fork)(sessionChannelWorkerCatchable, action);
            }
        }
        catch (error) {
            (0, utils_1.getLogger)().error('sessionChannelWorker error:', error);
        }
        finally {
            (0, utils_1.getLogger)().debug('sessionChannelWorker finally');
        }
    }
}
exports.sessionChannelWatcher = sessionChannelWatcher;
//# sourceMappingURL=sessionSaga.js.map