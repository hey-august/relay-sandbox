"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const testUtils_1 = require("../../../testUtils");
const sessionSlice_1 = require("./sessionSlice");
const sessionSelectors_1 = require("./sessionSelectors");
const actions_1 = require("../../actions");
describe('SessionState Tests', () => {
    let store;
    beforeEach(() => {
        store = (0, testUtils_1.configureJestStore)();
    });
    it('should seed SessionState on sessionActions.connected action', () => {
        store.dispatch(sessionSlice_1.sessionActions.connected(testUtils_1.rpcConnectResultVRT));
        expect(store.getState().session).toStrictEqual({
            protocol: testUtils_1.rpcConnectResultVRT.protocol,
            iceServers: testUtils_1.rpcConnectResultVRT.ice_servers,
            authStatus: 'authorized',
            authState: {
                media_allowed: 'all',
                audio_allowed: 'both',
                join_as: 'member',
                project: '8f0a119a-cda7-4497-a47d-c81493b824d4',
                project_id: '8f0a119a-cda7-4497-a47d-c81493b824d4',
                resource: '9c80f1e8-9430-4070-a043-937eb3a96b38',
                room: {
                    name: 'lobby',
                    display_name: 'Lobby',
                    scopes: ['room.self.audio_mute', 'room.self.audio_unmute'],
                    meta: {},
                },
                scope_id: '26675883-8499-4ee9-85eb-691c4aa209f8',
                scopes: ['video'],
                signature: 'SGZtkRD9fvuBAOUp1UF56zESxdEvGT6qSGZtkRD9fvuBAOUp1UF56zESxdEvGT6q',
                type: 'video',
                user_name: 'Joe',
                video_allowed: 'both',
                meta: {},
            },
            authError: undefined,
            authCount: 1,
        });
    });
    it('should reset to initial on destroyAction', () => {
        store.dispatch(sessionSlice_1.sessionActions.connected(testUtils_1.rpcConnectResultVRT));
        store.dispatch((0, actions_1.destroyAction)());
        expect(store.getState().session).toStrictEqual(sessionSlice_1.initialSessionState);
    });
    it('should set authStatus to authorizing on initAction and reauthAction', () => {
        store.dispatch((0, actions_1.initAction)());
        expect((0, sessionSelectors_1.getAuthStatus)(store.getState())).toEqual('authorizing');
        store.dispatch(sessionSlice_1.sessionActions.connected(testUtils_1.rpcConnectResultVRT));
        expect((0, sessionSelectors_1.getAuthStatus)(store.getState())).toEqual('authorized');
        store.dispatch((0, actions_1.reauthAction)({ token: 'foo' }));
        expect((0, sessionSelectors_1.getAuthStatus)(store.getState())).toEqual('authorizing');
    });
});
//# sourceMappingURL=sessionSlice.test.js.map