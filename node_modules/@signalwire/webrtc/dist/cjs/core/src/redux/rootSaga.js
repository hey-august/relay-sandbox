"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sessionAuthErrorSaga = exports.sessionStatusWatcher = exports.reauthenticateWorker = exports.initSessionSaga = void 0;
const effects_1 = require("@redux-saga/core/effects");
const utils_1 = require("../utils");
const sessionSaga_1 = require("./features/session/sessionSaga");
const actions_1 = require("./actions");
const features_1 = require("./features");
const actions_2 = require("./actions");
const CustomErrors_1 = require("../CustomErrors");
const sagaHelpers_1 = require("./utils/sagaHelpers");
function* initSessionSaga({ initSession, sessionEmitter, userOptions, channels, }) {
    var _a;
    const session = initSession();
    /**
     * Channel to broadcast all the events sent by the server
     */
    const swEventChannel = channels.swEventChannel;
    /**
     * Channel to communicate with base session
     */
    const sessionChannel = channels.sessionChannel;
    /**
     * Start all the custom workers on startup
     */
    let customTasks = [];
    if ((_a = userOptions.workers) === null || _a === void 0 ? void 0 : _a.length) {
        try {
            const effects = userOptions.workers.map((saga) => {
                return (0, effects_1.call)((0, sagaHelpers_1.createRestartableSaga)(saga));
            });
            customTasks = yield (0, effects_1.all)(effects);
        }
        catch (error) {
            (0, utils_1.getLogger)().error('Error running custom workers', error);
        }
    }
    yield (0, effects_1.fork)(sessionSaga_1.sessionChannelWatcher, {
        session,
        sessionChannel,
        swEventChannel,
    });
    /**
     * Fork the watcher for the session status
     */
    const sessionStatusTask = yield (0, effects_1.fork)(sessionStatusWatcher, {
        session,
        sessionEmitter,
        sessionChannel,
        userOptions,
    });
    session.connect();
    yield (0, effects_1.take)(actions_1.destroyAction.type);
    session.disconnect();
    yield (0, effects_1.take)(actions_1.sessionDisconnectedAction.type);
    sessionEmitter.emit('session.disconnected');
    /**
     * We have to manually cancel the fork because it is not
     * being automatically cleaned up when the session is
     * destroyed, most likely because it's using a timer.
     */
    sessionStatusTask.cancel();
    customTasks.forEach((task) => task.cancel());
    /**
     * Do not close swEventChannel, and sessionChannel
     * since we may need them again in case of reauth/reconnect
     * swEventChannel.close()
     * sessionChannel.close()
     */
}
exports.initSessionSaga = initSessionSaga;
function* reauthenticateWorker({ session, token, sessionEmitter, }) {
    try {
        if (session.reauthenticate) {
            session.token = token;
            yield (0, effects_1.call)(session.reauthenticate);
            // Update the store with the new "connect result"
            yield (0, effects_1.put)(features_1.sessionActions.connected(session.rpcConnectResult));
            sessionEmitter.emit('session.connected');
        }
    }
    catch (error) {
        (0, utils_1.getLogger)().error('Reauthenticate Error', error);
        session.authError(error);
    }
}
exports.reauthenticateWorker = reauthenticateWorker;
function* sessionStatusWatcher(options) {
    (0, utils_1.getLogger)().debug('sessionStatusWatcher [started]');
    const { session, sessionEmitter } = options;
    try {
        while (true) {
            const action = yield (0, effects_1.take)([
                actions_2.authSuccessAction.type,
                actions_2.authErrorAction.type,
                actions_2.authExpiringAction.type,
                actions_1.reauthAction.type,
                actions_1.sessionReconnectingAction.type,
                actions_1.sessionForceCloseAction.type,
            ]);
            (0, utils_1.getLogger)().trace('sessionStatusWatcher', action.type, action.payload);
            switch (action.type) {
                case actions_2.authSuccessAction.type: {
                    yield (0, effects_1.put)(features_1.sessionActions.connected(session.rpcConnectResult));
                    sessionEmitter.emit('session.connected');
                    break;
                }
                case actions_2.authErrorAction.type: {
                    yield (0, effects_1.fork)(sessionAuthErrorSaga, Object.assign(Object.assign({}, options), { action }));
                    break;
                }
                case actions_2.authExpiringAction.type: {
                    sessionEmitter.emit('session.expiring');
                    break;
                }
                case actions_1.reauthAction.type: {
                    yield (0, effects_1.fork)(reauthenticateWorker, {
                        session: session,
                        token: action.payload.token,
                        sessionEmitter,
                    });
                    break;
                }
                case actions_1.sessionReconnectingAction.type: {
                    sessionEmitter.emit('session.reconnecting');
                    break;
                }
                case actions_1.sessionForceCloseAction.type: {
                    session.forceClose();
                    break;
                }
            }
        }
    }
    finally {
        if (yield (0, effects_1.cancelled)()) {
            (0, utils_1.getLogger)().debug('sessionStatusWatcher [cancelled]');
        }
    }
}
exports.sessionStatusWatcher = sessionStatusWatcher;
function* sessionAuthErrorSaga(options) {
    (0, utils_1.getLogger)().debug('sessionAuthErrorSaga [started]');
    try {
        const { action, sessionEmitter } = options;
        const { error: authError } = action.payload;
        const error = authError
            ? new CustomErrors_1.AuthError(authError.code, authError.message)
            : new Error('Unauthorized');
        sessionEmitter.emit('session.auth_error', error);
    }
    finally {
        if (yield (0, effects_1.cancelled)()) {
            (0, utils_1.getLogger)().debug('sessionAuthErrorSaga [cancelled]');
        }
    }
}
exports.sessionAuthErrorSaga = sessionAuthErrorSaga;
exports.default = (options) => {
    return function* root({ userOptions, channels, }) {
        var _a;
        if (userOptions.logger) {
            (0, utils_1.setLogger)(userOptions.logger);
        }
        if (userOptions.debug) {
            (0, utils_1.setDebugOptions)(userOptions.debug);
        }
        while (true) {
            /**
             * Wait for an initAction to start
             */
            const action = yield (0, effects_1.take)([actions_1.initAction.type, actions_1.reauthAction.type]);
            /**
             * Update token only if the action contains a `token`
             * (case of reauthAction with a new token)
             */
            if ((_a = action === null || action === void 0 ? void 0 : action.payload) === null || _a === void 0 ? void 0 : _a.token) {
                userOptions.token = action.payload.token;
            }
            /**
             * Create Session and related sessionChannel to
             * send/receive websocket messages
             */
            try {
                yield (0, effects_1.call)(initSessionSaga, Object.assign(Object.assign({}, options), { userOptions,
                    channels }));
            }
            catch (error) {
                (0, utils_1.getLogger)().error('RootSaga Error:', error);
            }
            finally {
                if (yield (0, effects_1.cancelled)()) {
                    (0, utils_1.getLogger)().debug('rootSaga [cancelled]');
                }
                (0, utils_1.getLogger)().debug('Reboot rootSaga');
            }
        }
    };
};
//# sourceMappingURL=rootSaga.js.map