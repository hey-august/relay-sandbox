"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseJWTSession = void 0;
const tslib_1 = require("tslib");
const RPCMessages_1 = require("./RPCMessages");
const BaseSession_1 = require("./BaseSession");
const actions_1 = require("./redux/actions");
const utils_1 = require("./utils");
class BaseJWTSession extends BaseSession_1.BaseSession {
    constructor(options) {
        super(options);
        this.options = options;
        /**
         * Can be set a value different then zero
         * to force the JWT as expired within X seconds.
         * TODO: Remove this workaround.
         */
        this._expiredDiffSeconds = 0;
        this._refreshTokenNotificationDiff = 120;
        /**
         * Check the JWT expiration every 20seconds
         */
        this._checkTokenExpirationDelay = 20 * 1000;
        this._checkTokenExpirationTimer = null;
        this._checkTokenExpiration = this._checkTokenExpiration.bind(this);
        this.reauthenticate = this.reauthenticate.bind(this);
    }
    get expiresAt() {
        var _a;
        if (!(this === null || this === void 0 ? void 0 : this._rpcConnectResult)) {
            return 0;
        }
        const { authorization } = this._rpcConnectResult;
        const expiresAt = (_a = ((0, utils_1.isSATAuth)(authorization)
            ? authorization.fabric_subscriber.expires_at
            : authorization === null || authorization === void 0 ? void 0 : authorization.expires_at)) !== null && _a !== void 0 ? _a : 0;
        if (typeof expiresAt === 'string') {
            const parsed = Date.parse(expiresAt);
            if (!isNaN(parsed)) {
                return Math.floor(parsed / 1000);
            }
        }
        return expiresAt;
    }
    get expiresIn() {
        const now = Math.floor(Date.now() / 1000);
        return this.expiresAt - now;
    }
    get expired() {
        return this.expiresAt > 0 && this.expiresIn <= this._expiredDiffSeconds;
    }
    /**
     * Authenticate with the SignalWire Network
     * using JWT
     * @return Promise<void>
     */
    authenticate() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const params = {
                agent: this.agent,
                version: this.connectVersion,
                authentication: {
                    jwt_token: this.options.token,
                },
            };
            if (this._relayProtocolIsValid()) {
                params.protocol = this.relayProtocol;
            }
            else {
                /**
                 * TODO: Find out a better way to get the prevProtocol
                 */
                const prevProtocol = yield this.retrieveRelayProtocol();
                if (prevProtocol) {
                    params.protocol = prevProtocol;
                }
            }
            // Try to set authorization_state only if we have a valid protocol
            if (params.protocol) {
                const authorizationState = yield this.retrieveSwAuthorizationState();
                if (authorizationState) {
                    params.authorization_state = authorizationState;
                }
            }
            try {
                this._rpcConnectResult = yield this.execute((0, RPCMessages_1.RPCConnect)(params));
                yield this.persistRelayProtocol();
                yield this._checkTokenExpiration();
            }
            catch (error) {
                this.logger.debug('BaseJWTSession authenticate error', error);
                throw error;
            }
        });
    }
    retrieveRelayProtocol() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // no-op
            return '';
        });
    }
    persistRelayProtocol() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // no-op
        });
    }
    /**
     * Reauthenticate with the SignalWire Network
     * using a newer JWT. If the session has expired
     * will reconnect it.
     * @return Promise<void>
     */
    reauthenticate() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug('Session Reauthenticate', {
                ready: this.ready,
                expired: this.expired,
            });
            if (!this.ready || this.expired) {
                return this.connect();
            }
            const params = {
                project: this._rpcConnectResult.authorization.project_id,
                jwt_token: this.options.token,
            };
            try {
                this._rpcConnectResult = yield this.execute((0, RPCMessages_1.RPCReauthenticate)(params));
            }
            catch (error) {
                clearTimeout(this._checkTokenExpirationTimer);
                throw error;
            }
        });
    }
    _onSocketClose(event) {
        clearTimeout(this._checkTokenExpirationTimer);
        super._onSocketClose(event);
    }
    /**
     * Set a timer to dispatch a notification when the JWT is going to expire.
     * @return void
     */
    _checkTokenExpiration() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.expiresAt) {
                return;
            }
            const refreshTokenFn = this.options._onRefreshToken || this.options.onRefreshToken;
            if (this.expiresIn <= this._refreshTokenNotificationDiff) {
                this.dispatch((0, actions_1.authExpiringAction)());
                if (typeof refreshTokenFn === 'function') {
                    try {
                        yield refreshTokenFn();
                    }
                    catch (error) {
                        this.logger.error(error);
                    }
                }
                else {
                    this.logger.warn('The token is going to expire!');
                }
            }
            clearTimeout(this._checkTokenExpirationTimer);
            if (!this.expired) {
                this._checkTokenExpirationTimer = setTimeout(this._checkTokenExpiration, this._checkTokenExpirationDelay);
            }
        });
    }
}
exports.BaseJWTSession = BaseJWTSession;
//# sourceMappingURL=BaseJWTSession.js.map