"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSATAuth = exports.isJSONRPCResponse = exports.isJSONRPCRequest = exports.toSyntheticEvent = exports.toLocalEvent = exports.isLocalEvent = exports.validateEventsToSubscribe = exports.getGlobalEvents = exports.isSessionEvent = exports.isSyntheticEvent = exports.isInternalGlobalEvent = exports.isGlobalEvent = exports.timeoutPromise = exports.checkWebSocketHost = exports.safeParseJson = exports.mutateStorageKey = exports.LOCAL_EVENT_PREFIX = exports.uuid = exports.WEBRTC_EVENT_TYPES = exports.isWebrtcEventType = exports.setDebugOptions = exports.getLogger = exports.setLogger = void 0;
const tslib_1 = require("tslib");
const constants_1 = require("./constants");
Object.defineProperty(exports, "LOCAL_EVENT_PREFIX", { enumerable: true, get: function () { return constants_1.LOCAL_EVENT_PREFIX; } });
var logger_1 = require("./logger");
Object.defineProperty(exports, "setLogger", { enumerable: true, get: function () { return logger_1.setLogger; } });
Object.defineProperty(exports, "getLogger", { enumerable: true, get: function () { return logger_1.getLogger; } });
Object.defineProperty(exports, "setDebugOptions", { enumerable: true, get: function () { return logger_1.setDebugOptions; } });
var common_1 = require("./common");
Object.defineProperty(exports, "isWebrtcEventType", { enumerable: true, get: function () { return common_1.isWebrtcEventType; } });
Object.defineProperty(exports, "WEBRTC_EVENT_TYPES", { enumerable: true, get: function () { return common_1.WEBRTC_EVENT_TYPES; } });
var uuid_1 = require("uuid");
Object.defineProperty(exports, "uuid", { enumerable: true, get: function () { return uuid_1.v4; } });
tslib_1.__exportStar(require("./parseRPCResponse"), exports);
tslib_1.__exportStar(require("./toExternalJSON"), exports);
tslib_1.__exportStar(require("./toInternalEventName"), exports);
tslib_1.__exportStar(require("./toInternalAction"), exports);
tslib_1.__exportStar(require("./toSnakeCaseKeys"), exports);
tslib_1.__exportStar(require("./extendComponent"), exports);
tslib_1.__exportStar(require("./debounce"), exports);
tslib_1.__exportStar(require("./SWCloseEvent"), exports);
tslib_1.__exportStar(require("./eventUtils"), exports);
const mutateStorageKey = (key) => `${constants_1.STORAGE_PREFIX}${key}`;
exports.mutateStorageKey = mutateStorageKey;
const safeParseJson = (value) => {
    if (typeof value !== 'string') {
        return value;
    }
    try {
        return JSON.parse(value);
    }
    catch (error) {
        return value;
    }
};
exports.safeParseJson = safeParseJson;
const PROTOCOL_PATTERN = /^(ws|wss):\/\//;
const checkWebSocketHost = (host) => {
    const protocol = PROTOCOL_PATTERN.test(host) ? '' : 'wss://';
    return `${protocol}${host}`;
};
exports.checkWebSocketHost = checkWebSocketHost;
const timeoutPromise = (promise, time, exception) => {
    let timer = null;
    return Promise.race([
        promise,
        new Promise((_resolve, reject) => (timer = setTimeout(reject, time, exception))),
    ]).finally(() => clearTimeout(timer));
};
exports.timeoutPromise = timeoutPromise;
/** @internal */
const isGlobalEvent = (event) => {
    // @ts-ignore
    return constants_1.GLOBAL_VIDEO_EVENTS.includes(event);
};
exports.isGlobalEvent = isGlobalEvent;
/** @internal */
const isInternalGlobalEvent = (event) => {
    // @ts-ignore
    return constants_1.INTERNAL_GLOBAL_VIDEO_EVENTS.includes(event);
};
exports.isInternalGlobalEvent = isInternalGlobalEvent;
const isSyntheticEvent = (event) => {
    return event.includes(constants_1.SYNTHETIC_EVENT_PREFIX);
};
exports.isSyntheticEvent = isSyntheticEvent;
const isSessionEvent = (event) => {
    return event.includes('session.');
};
exports.isSessionEvent = isSessionEvent;
const getGlobalEvents = (kind = 'all') => {
    switch (kind) {
        case 'video':
            return constants_1.GLOBAL_VIDEO_EVENTS;
        default:
            // prettier-ignore
            return [
                ...constants_1.GLOBAL_VIDEO_EVENTS,
            ];
    }
};
exports.getGlobalEvents = getGlobalEvents;
const cleanupEventNamespace = (event) => {
    const eventParts = event.split(constants_1.EVENT_NAMESPACE_DIVIDER);
    return eventParts[eventParts.length - 1];
};
/**
 * These events have derived events generated by the SDK
 * i.e. member.updated.audioMuted or member.talking.started
 */
const WITH_CUSTOM_EVENT_NAMES = [
    'video.member.updated',
    'video.member.talking',
];
/**
 * These events are generated by the SDK to make them
 * more "user-friendly" while others are client-side only
 * like the WebRTC ones: `track`/`active`/`destroy` for Call objects.
 */
const CLIENT_SIDE_EVENT_NAMES = [
    'video.room.joined',
    'video.track',
    'video.active',
    'video.answering',
    'video.destroy',
    'video.early',
    'video.hangup',
    'video.held',
    'video.new',
    'video.purge',
    'video.recovering',
    'video.requesting',
    'video.ringing',
    'video.trying',
    'video.media.connected',
    'video.media.reconnecting',
    'video.media.disconnected',
    'video.microphone.updated',
    'video.camera.updated',
    'video.speaker.updated',
    'video.microphone.disconnected',
    'video.camera.disconnected',
    'video.speaker.disconnected',
];
/**
 * Check and filter the events the user attached returning only the valid ones
 * for the server.
 * IE: `member.updated.audioMuted` means `member.updated` for the server.
 * @internal
 */
const validateEventsToSubscribe = (events) => {
    const valid = events.map((internalEvent) => {
        if (typeof internalEvent === 'string') {
            const event = cleanupEventNamespace(internalEvent);
            if (CLIENT_SIDE_EVENT_NAMES.includes(event) ||
                (0, exports.isSyntheticEvent)(event) ||
                (0, exports.isLocalEvent)(event) ||
                (0, exports.isSessionEvent)(event)) {
                return null;
            }
            const found = WITH_CUSTOM_EVENT_NAMES.find((withCustomName) => {
                return event.startsWith(withCustomName);
            });
            return found || event;
        }
        return internalEvent;
    });
    return Array.from(new Set(valid)).filter(Boolean);
};
exports.validateEventsToSubscribe = validateEventsToSubscribe;
/**
 * "Local" events are events controlled by the SDK and the
 * server has no knowledge about them.
 */
const isLocalEvent = (event) => {
    return event.includes(constants_1.LOCAL_EVENT_PREFIX);
};
exports.isLocalEvent = isLocalEvent;
const toLocalEvent = (event) => {
    const eventParts = event.split('.');
    const prefix = eventParts[0];
    return event
        .split('.')
        .reduce((reducer, item) => {
        reducer.push(item);
        if (item === prefix) {
            reducer.push(constants_1.LOCAL_EVENT_PREFIX);
        }
        return reducer;
    }, [])
        .join('.');
};
exports.toLocalEvent = toLocalEvent;
const toSyntheticEvent = (event) => {
    const eventParts = event.split('.');
    const prefix = eventParts[0];
    return event
        .split('.')
        .reduce((reducer, item) => {
        reducer.push(item);
        if (item === prefix) {
            reducer.push(constants_1.SYNTHETIC_EVENT_PREFIX);
        }
        return reducer;
    }, [])
        .join('.');
};
exports.toSyntheticEvent = toSyntheticEvent;
const isJSONRPCRequest = (e) => {
    return Boolean(e.method);
};
exports.isJSONRPCRequest = isJSONRPCRequest;
const isJSONRPCResponse = (e) => {
    return !(0, exports.isJSONRPCRequest)(e);
};
exports.isJSONRPCResponse = isJSONRPCResponse;
const isSATAuth = (e) => {
    return typeof e !== 'undefined' && 'jti' in e;
};
exports.isSATAuth = isSATAuth;
//# sourceMappingURL=index.js.map