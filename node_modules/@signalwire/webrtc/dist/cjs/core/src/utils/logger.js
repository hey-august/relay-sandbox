"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setDebugOptions = exports.getLogger = exports.setLogger = void 0;
const tslib_1 = require("tslib");
const loglevel_1 = tslib_1.__importDefault(require("loglevel"));
const datetime = () => new Date().toISOString();
const defaultLogger = loglevel_1.default.getLogger('signalwire');
const originalFactory = defaultLogger.methodFactory;
defaultLogger.methodFactory = (methodName, logLevel, loggerName) => {
    const rawMethod = originalFactory(methodName, logLevel, loggerName);
    return function (...args) {
        args.unshift(datetime(), '-');
        rawMethod.apply(undefined, args);
    };
};
const defaultLoggerLevel = 
// @ts-ignore
'development' === process.env.NODE_ENV
    ? defaultLogger.levels.DEBUG
    : defaultLogger.getLevel();
defaultLogger.setLevel(defaultLoggerLevel);
let userLogger;
const setLogger = (logger) => {
    userLogger = logger;
};
exports.setLogger = setLogger;
let debugOptions = {};
const setDebugOptions = (options) => {
    if (options == null) {
        debugOptions = {};
        return;
    }
    Object.assign(debugOptions, options);
};
exports.setDebugOptions = setDebugOptions;
const getLoggerInstance = () => {
    return userLogger !== null && userLogger !== void 0 ? userLogger : defaultLogger;
};
const shouldStringify = (payload) => {
    if ('method' in payload && payload.method === 'signalwire.ping') {
        return false;
    }
    return true;
};
const wsTraffic = ({ type, payload }) => {
    const logger = getLoggerInstance();
    const { logWsTraffic } = debugOptions || {};
    if (!logWsTraffic) {
        return undefined;
    }
    const msg = shouldStringify(payload)
        ? JSON.stringify(payload, null, 2)
        : payload;
    return logger.info(`${type.toUpperCase()}: \n`, msg, '\n');
};
const getLogger = () => {
    const logger = getLoggerInstance();
    return new Proxy(logger, {
        get(target, prop, receiver) {
            if (prop === 'wsTraffic') {
                return wsTraffic;
            }
            return Reflect.get(target, prop, receiver);
        },
    });
};
exports.getLogger = getLogger;
//# sourceMappingURL=logger.js.map