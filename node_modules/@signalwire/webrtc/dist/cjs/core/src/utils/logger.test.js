"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("./logger");
const testUtils_1 = require("../testUtils");
describe('logger', () => {
    describe('getLogger', () => {
        it('should use the default logger if no logger was set', () => {
            const logger = (0, logger_1.getLogger)();
            // @ts-expect-error
            expect(typeof logger.setLevel).toBe('function');
        });
    });
    describe('setLogger', () => {
        afterEach(() => {
            (0, logger_1.setLogger)(null);
        });
        it('should allow us to pass a customer logger', () => {
            const mockedLogger = (0, testUtils_1.createMockedLogger)();
            (0, logger_1.setLogger)(mockedLogger);
            const logger = (0, logger_1.getLogger)();
            logger.info('info');
            logger.debug('debug');
            logger.error('error');
            logger.trace('trace');
            logger.warn('warn');
            expect(mockedLogger.info).toHaveBeenCalledWith('info');
            expect(mockedLogger.debug).toHaveBeenCalledWith('debug');
            expect(mockedLogger.error).toHaveBeenCalledWith('error');
            expect(mockedLogger.trace).toHaveBeenCalledWith('trace');
            expect(mockedLogger.warn).toHaveBeenCalledWith('warn');
        });
    });
    describe('WS Traffic', () => {
        let mockedLogger;
        beforeEach(() => {
            mockedLogger = (0, testUtils_1.createMockedLogger)();
            (0, logger_1.setLogger)(mockedLogger);
        });
        afterEach(() => {
            (0, logger_1.setLogger)(null);
            (0, logger_1.setDebugOptions)(null);
        });
        it('should be a noop unless `debug.logWsTraffic: true`', () => {
            const logger = (0, logger_1.getLogger)();
            logger.wsTraffic({ type: 'send', payload: {} });
            expect(mockedLogger.info).not.toHaveBeenCalled();
        });
        it('should expose a `wsTraffic` method', () => {
            (0, logger_1.setDebugOptions)({
                logWsTraffic: true,
            });
            const logger = (0, logger_1.getLogger)();
            const payload = {
                jsonrpc: '2.0',
                id: 'uuid',
                method: 'signalwire.event',
                params: {
                    key: 'value',
                },
            };
            logger.wsTraffic({ type: 'send', payload });
            logger.wsTraffic({ type: 'recv', payload });
            expect(mockedLogger.info).toHaveBeenNthCalledWith(1, `SEND: \n`, JSON.stringify(payload, null, 2), '\n');
            expect(mockedLogger.info).toHaveBeenNthCalledWith(2, `RECV: \n`, JSON.stringify(payload, null, 2), '\n');
        });
        it('should not stringify ping events', () => {
            (0, logger_1.setDebugOptions)({
                logWsTraffic: true,
            });
            const logger = (0, logger_1.getLogger)();
            const payload = {
                jsonrpc: '2.0',
                id: 'uuid',
                method: 'signalwire.ping',
                params: {
                    key: 'value',
                },
            };
            logger.wsTraffic({ type: 'send', payload });
            expect(mockedLogger.info).toHaveBeenCalledWith(`SEND: \n`, payload, '\n');
        });
    });
});
//# sourceMappingURL=logger.test.js.map