"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseSession = exports.SW_SYMBOL = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("./utils");
const constants_1 = require("./utils/constants");
const RPCMessages_1 = require("./RPCMessages");
const actions_1 = require("./redux/actions");
const sessionSlice_1 = require("./redux/features/session/sessionSlice");
exports.SW_SYMBOL = Symbol('BaseSession');
const randomInt = (min, max) => {
    return Math.floor(Math.random() * (max - min + 1) + min);
};
const reconnectDelay = () => {
    return randomInt(1, 4) * 1000;
};
class BaseSession {
    constructor(options) {
        var _a, _b;
        this.options = options;
        /** @internal */
        this.__sw_symbol = exports.SW_SYMBOL;
        this.uuid = (0, utils_1.uuid)();
        this.connectVersion = RPCMessages_1.DEFAULT_CONNECT_VERSION;
        this._requests = new Map();
        this._socket = null;
        this._host = constants_1.DEFAULT_HOST;
        this._executeTimeoutMs = 10 * 1000;
        this._executeTimeoutError = Symbol.for('sw-execute-timeout');
        this._executeQueue = new Set();
        this._swConnectError = Symbol.for('sw-connect-error');
        this._executeConnectionClosed = Symbol.for('sw-execute-connection-closed');
        this._checkPingDelay = 15 * 1000;
        this._checkPingTimer = null;
        this._status = 'unknown';
        const { host, logLevel = 'info', sessionChannel } = options;
        if (host) {
            this._host = (0, utils_1.checkWebSocketHost)(host);
        }
        if (sessionChannel) {
            this._sessionChannel = sessionChannel;
        }
        if (logLevel) {
            /**
             * `setLevel` only makes sense when dealing with our
             * default logger. The error is expected because we
             * don't expose `setLevel` as part of our public
             * SDKLogger since there's no standard API across
             * loggers to do this.
             */
            // @ts-expect-error
            (_b = (_a = this.logger).setLevel) === null || _b === void 0 ? void 0 : _b.call(_a, logLevel);
        }
        this._onSocketOpen = this._onSocketOpen.bind(this);
        this._onSocketError = this._onSocketError.bind(this);
        this._onSocketClose = this._onSocketClose.bind(this);
        this._onSocketMessage = this._onSocketMessage.bind(this);
        this.execute = this.execute.bind(this);
        this.connect = this.connect.bind(this);
        /** Listen on socket events once */
        this.wsOpenHandler = (event) => {
            var _a;
            (_a = this._socket) === null || _a === void 0 ? void 0 : _a.removeEventListener('open', this.wsOpenHandler);
            this._onSocketOpen(event);
        };
        this.wsCloseHandler = (event) => {
            var _a;
            (_a = this._socket) === null || _a === void 0 ? void 0 : _a.removeEventListener('close', this.wsCloseHandler);
            this._onSocketClose(event);
        };
        this.wsErrorHandler = (event) => {
            var _a;
            (_a = this._socket) === null || _a === void 0 ? void 0 : _a.removeEventListener('error', this.wsErrorHandler);
            this._onSocketError(event);
        };
    }
    get host() {
        return this._host;
    }
    get rpcConnectResult() {
        return this._rpcConnectResult;
    }
    get relayProtocol() {
        var _a, _b;
        return (_b = (_a = this._rpcConnectResult) === null || _a === void 0 ? void 0 : _a.protocol) !== null && _b !== void 0 ? _b : '';
    }
    get signature() {
        if (this._rpcConnectResult) {
            const { authorization } = this._rpcConnectResult;
            return (0, utils_1.isSATAuth)(authorization)
                ? authorization.jti
                : authorization.signature;
        }
        return undefined;
    }
    get logger() {
        return (0, utils_1.getLogger)();
    }
    get connecting() {
        var _a;
        return ((_a = this._socket) === null || _a === void 0 ? void 0 : _a.readyState) === constants_1.WebSocketState.CONNECTING;
    }
    get connected() {
        var _a;
        return ((_a = this._socket) === null || _a === void 0 ? void 0 : _a.readyState) === constants_1.WebSocketState.OPEN;
    }
    get closing() {
        var _a;
        return ((_a = this._socket) === null || _a === void 0 ? void 0 : _a.readyState) === constants_1.WebSocketState.CLOSING;
    }
    get closed() {
        return this._socket
            ? this._socket.readyState === constants_1.WebSocketState.CLOSED
            : true;
    }
    get status() {
        return this._status;
    }
    get idle() {
        return this._status === 'idle';
    }
    get ready() {
        return !Boolean(this.idle || !this.connected);
    }
    set token(token) {
        this.options.token = token;
    }
    /**
     * Connect the websocket
     *
     * @return void
     */
    connect() {
        if (!(this === null || this === void 0 ? void 0 : this.WebSocketConstructor)) {
            throw new Error('Missing WebSocketConstructor');
        }
        if (!(this === null || this === void 0 ? void 0 : this.CloseEventConstructor)) {
            throw new Error('Missing CloseEventConstructor');
        }
        this._clearTimers();
        /**
         * Return if already connecting or connected
         * This prevents issues if "connect()" is called multiple times.
         */
        if (this.connecting || this.connected) {
            this.logger.warn('Session already connected.');
            return;
        }
        /** In case of reconnect: remove listeners and then destroy it */
        this._removeSocketListeners();
        this.destroySocket();
        this._clearCheckPingTimer();
        this._socket = this._createSocket();
        this._addSocketListeners();
    }
    /**
     * Allow children classes to override it.
     * @return WebSocket instance
     */
    _createSocket() {
        return new this.WebSocketConstructor(this._host);
    }
    /** Allow children classes to override it. */
    destroySocket() {
        if (this._socket) {
            this._socket.close();
            this._socket = null;
        }
    }
    _addSocketListeners() {
        if (!this._socket) {
            return this.logger.debug('Invalid socket instance to add listeners');
        }
        this._removeSocketListeners();
        this._socket.addEventListener('open', this.wsOpenHandler);
        this._socket.addEventListener('close', this.wsCloseHandler);
        this._socket.addEventListener('error', this.wsErrorHandler);
        this._socket.addEventListener('message', this._onSocketMessage);
    }
    _removeSocketListeners() {
        if (!this._socket) {
            return this.logger.debug('Invalid socket instance to remove listeners');
        }
        this._socket.removeEventListener('open', this.wsOpenHandler);
        this._socket.removeEventListener('close', this.wsCloseHandler);
        this._socket.removeEventListener('error', this.wsErrorHandler);
        this._socket.removeEventListener('message', this._onSocketMessage);
    }
    /**
     * Clear the Session and close the WS connection.
     * @return void
     */
    disconnect() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            /**
             * Return if there is not a _socket instance or
             * if it's already in closing state.
             */
            if (!this._socket || this.closing) {
                this.logger.debug('Session not connected or already in closing state.');
                return;
            }
            this._status = 'disconnecting';
            this._checkCurrentStatus();
        });
    }
    /**
     * Send a JSON object to the server.
     * @return Promise that will resolve/reject depending on the server response
     */
    execute(msg) {
        if (this._status === 'disconnecting') {
            this.logger.warn('Reject request because the session is disconnecting', msg);
            return Promise.reject({
                code: '400',
                message: 'The SDK session is disconnecting',
            });
        }
        // In case of a response don't wait for a result
        let promise = Promise.resolve();
        if ('params' in msg) {
            // This is a request so save the "id" to resolve the Promise later
            promise = new Promise((resolve, reject) => {
                this._requests.set(msg.id, { rpcRequest: msg, resolve, reject });
            });
        }
        if (!this.ready) {
            this._addToExecuteQueue(msg);
            this.connect();
            return promise;
        }
        this._send(msg);
        return (0, utils_1.timeoutPromise)(promise, this._executeTimeoutMs, this._executeTimeoutError).catch((error) => {
            if (error === this._executeConnectionClosed) {
                throw this._executeConnectionClosed;
            }
            else if (error === this._executeTimeoutError) {
                if ('method' in msg && msg.method === 'signalwire.connect') {
                    throw this._swConnectError;
                }
                this._checkCurrentStatus();
                this.logger.error('Request Timeout', msg);
                if (this.status === 'disconnected') {
                    return this.logger.debug('Request failed because the session is disconnected', this.status, this._socket);
                }
                // Possibly half-open connection so force close our side
                this._closeConnection('reconnecting');
            }
            else {
                throw error;
            }
        });
    }
    /**
     * Authenticate with the SignalWire Network
     * @return Promise<void>
     */
    authenticate() {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const params = {
                agent: this.agent,
                version: this.connectVersion,
                authentication: {
                    project: this.options.project,
                    token: this.options.token,
                },
            };
            if (this._relayProtocolIsValid()) {
                params.protocol = this.relayProtocol;
            }
            if ((_a = this.options.topics) === null || _a === void 0 ? void 0 : _a.length) {
                params.contexts = this.options.topics;
            }
            else if ((_b = this.options.contexts) === null || _b === void 0 ? void 0 : _b.length) {
                params.contexts = this.options.contexts;
            }
            this._rpcConnectResult = yield this.execute((0, RPCMessages_1.RPCConnect)(params));
        });
    }
    authError(error) {
        /** Ignore WS events after the auth error and just disconnect */
        this._removeSocketListeners();
        this.dispatch((0, actions_1.authErrorAction)({ error }));
    }
    forceClose() {
        this._removeSocketListeners();
        return this._closeConnection('reconnecting');
    }
    _onSocketOpen(event) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug('_onSocketOpen', event.type);
            try {
                // Reset to "unknown" in case of reconnect
                this._status = 'unknown';
                this._clearTimers();
                yield this.authenticate();
                this._status = 'connected';
                this._flushExecuteQueue();
                this.dispatch((0, actions_1.authSuccessAction)());
            }
            catch (error) {
                if (error === this._swConnectError ||
                    error === this._executeConnectionClosed) {
                    this.logger.debug('Invalid connect or connection closed. Waiting for retry.');
                    return;
                }
                this.logger.error('Auth Error', error);
                this.authError(error);
            }
        });
    }
    _onSocketError(event) {
        this.logger.debug('_onSocketError', event);
    }
    _onSocketClose(event) {
        this.logger.debug('_onSocketClose', event.type, event.code, event.reason);
        if (this._status !== 'disconnected') {
            this._status = 'reconnecting';
            this.dispatch((0, actions_1.sessionReconnectingAction)());
            this._clearTimers();
            this._clearPendingRequests();
            this._reconnectTimer = setTimeout(() => {
                this.connect();
            }, reconnectDelay());
        }
        this._socket = null;
    }
    _clearTimers() {
        clearTimeout(this._reconnectTimer);
    }
    _clearPendingRequests() {
        this.logger.debug('_clearPendingRequests', this._requests.size);
        this._requests.forEach(({ reject }) => {
            reject(this._executeConnectionClosed);
        });
    }
    _onSocketMessage(event) {
        const payload = this.decode(event.data);
        this.logger.wsTraffic({ type: 'recv', payload });
        if ((0, utils_1.isJSONRPCResponse)(payload)) {
            const request = this._requests.get(payload.id);
            if (request) {
                const { rpcRequest, resolve, reject } = request;
                this._requests.delete(payload.id);
                const { result, error } = (0, utils_1.parseRPCResponse)({
                    response: payload,
                    request: rpcRequest,
                });
                this._checkCurrentStatus();
                return error ? reject(error) : resolve(result);
            }
            return this.logger.warn('Unknown request for', payload);
        }
        switch (payload.method) {
            case 'signalwire.ping':
                return this._pingHandler(payload);
            case 'signalwire.disconnect': {
                /**
                 * Set this._status = 'idle' because the server
                 * will close the connection soon.
                 */
                this.execute((0, RPCMessages_1.RPCDisconnectResponse)(payload.id))
                    .catch((error) => {
                    this.logger.error('SwDisconnect Error', error);
                })
                    .finally(() => {
                    this._status = 'idle';
                });
                break;
            }
            default:
                // If it's not a response, trigger the dispatch.
                this.dispatch((0, actions_1.socketMessageAction)(payload));
        }
    }
    dispatch(_payload) {
        if (!this._sessionChannel) {
            throw new Error('Session channel does not exist');
        }
        this._sessionChannel.put(_payload);
    }
    /**
     * Check the current relayProtocol against the signature
     * to make sure is still valid.
     * @return boolean
     */
    _relayProtocolIsValid() {
        var _a;
        return (this.signature && ((_a = this === null || this === void 0 ? void 0 : this.relayProtocol) === null || _a === void 0 ? void 0 : _a.split('_')[1]) === this.signature);
    }
    encode(input) {
        return JSON.stringify(input);
    }
    decode(input) {
        return (0, utils_1.safeParseJson)(input);
    }
    onSwAuthorizationState(state) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.persistSwAuthorizationState(state);
        });
    }
    retrieveSwAuthorizationState() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // no-op : allow override
            return '';
        });
    }
    persistSwAuthorizationState(_) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // no-op : allow override
        });
    }
    _send(msg) {
        this.logger.wsTraffic({ type: 'send', payload: msg });
        this._socket.send(this.encode(msg));
    }
    _addToExecuteQueue(msg) {
        this.logger.warn('Request queued waiting for session to reconnect', msg);
        this._executeQueue.add(msg);
    }
    _flushExecuteQueue() {
        if (!this._executeQueue.size) {
            return;
        }
        if (!this.ready) {
            this.logger.warn(`Session not ready to flush the queue.`);
            this._closeConnection('reconnecting');
            return;
        }
        this.logger.debug(`${this._executeQueue.size} messages to flush`);
        this._executeQueue.forEach((msg) => {
            this._send(msg);
            this._executeQueue.delete(msg);
        });
        this._executeQueue.clear();
    }
    _clearCheckPingTimer() {
        clearTimeout(this._checkPingTimer);
    }
    _pingHandler(payload) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this._clearCheckPingTimer();
            this._checkPingTimer = setTimeout(() => {
                // Possibly half-open connection so force close our side
                this.logger.debug('Timeout waiting for ping');
                this._closeConnection('reconnecting');
            }, this._checkPingDelay);
            yield this.execute((0, RPCMessages_1.RPCPingResponse)(payload.id, (_a = payload === null || payload === void 0 ? void 0 : payload.params) === null || _a === void 0 ? void 0 : _a.timestamp));
        });
    }
    /**
     * Do something based on the current `this._status`
     */
    _checkCurrentStatus() {
        switch (this._status) {
            // Only close the WS connection if there are no pending requests
            case 'disconnecting':
                if (this._requests.size > 0) {
                    return;
                }
                this._requests.clear();
                this._closeConnection('disconnected');
                break;
            case 'disconnected':
                // Will destroy the rootSaga too
                this.dispatch((0, actions_1.sessionDisconnectedAction)());
                break;
            case 'reconnecting':
                /**
                 * Since the real `close` event can be delayed by OS/Browser,
                 * trigger it manually to start the reconnect process if required.
                 */
                this.wsCloseHandler(new this.CloseEventConstructor('close', {
                    reason: 'Client-side closed',
                }));
                break;
        }
    }
    _closeConnection(status) {
        this._clearCheckPingTimer();
        this.logger.debug('Close Connection:', status);
        this._status = status;
        this.dispatch(sessionSlice_1.sessionActions.authStatus(status === 'disconnected' ? 'unauthorized' : 'unknown'));
        this._removeSocketListeners();
        this.destroySocket();
        this._checkCurrentStatus();
    }
}
exports.BaseSession = BaseSession;
//# sourceMappingURL=BaseSession.js.map