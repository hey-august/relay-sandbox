"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const jest_websocket_mock_1 = tslib_1.__importDefault(require("jest-websocket-mock"));
const BaseSession_1 = require("./BaseSession");
const actions_1 = require("./redux/actions");
const RPCMessages_1 = require("./RPCMessages");
const utils_1 = require("./utils");
const testUtils_1 = require("./testUtils");
jest.mock('uuid', () => {
    return {
        v4: jest.fn(() => 'mocked-uuid'),
    };
});
describe('BaseSession', () => {
    const host = 'ws://localhost:8080';
    const project = '2506edbc-35c4-4d9f-a5f0-45a03d82dab1';
    const token = 'PT1234abc';
    const rpcConnect = (0, RPCMessages_1.RPCConnect)({
        authentication: {
            project,
            token,
        },
    });
    let ws;
    let session;
    beforeEach(() => {
        ws = new jest_websocket_mock_1.default(host);
        // Respond to RPCs
        ws.on('connection', (socket) => {
            socket.on('message', (data) => {
                const parsedData = JSON.parse(data);
                socket.send(JSON.stringify({
                    jsonrpc: '2.0',
                    id: parsedData.id,
                    result: {},
                }));
            });
        });
        session = new BaseSession_1.BaseSession({
            host,
            project,
            token,
        });
        session.WebSocketConstructor = WebSocket;
        session.CloseEventConstructor = utils_1.SWCloseEvent;
        session.dispatch = jest.fn();
    });
    afterEach(() => {
        jest_websocket_mock_1.default.clean();
    });
    it('should connect and disconnect to/from the provided host', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        session.connect();
        yield ws.connected;
        expect(session.connected).toBe(true);
        yield expect(ws).toReceiveMessage(JSON.stringify(rpcConnect));
        session.disconnect();
        expect(session.connected).toBe(false);
        expect(session.closed).toBe(true);
    }));
    it('should try to connect with normal token on socket open', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        session.connect();
        yield ws.connected;
        yield expect(ws).toReceiveMessage(JSON.stringify(rpcConnect));
    }));
    it('should set idle mode on signalwire.disconnect', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        session.connect();
        yield ws.connected;
        yield expect(ws).toReceiveMessage(JSON.stringify(rpcConnect));
        const request = {
            jsonrpc: '2.0',
            id: 'uuid',
            method: 'signalwire.disconnect',
            params: {},
        };
        ws.send(JSON.stringify(request));
        expect(session.status).toEqual('unknown');
        const response = (0, RPCMessages_1.RPCDisconnectResponse)(request.id);
        yield expect(ws).toReceiveMessage(JSON.stringify(response));
        expect(session.status).toEqual('idle');
    }));
    it('should invoke dispatch with socketMessage action for any other message', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        session.connect();
        yield ws.connected;
        yield expect(ws).toReceiveMessage(JSON.stringify(rpcConnect));
        const request = {
            jsonrpc: '2.0',
            id: 'uuid',
            method: 'signalwire.event',
            params: {
                key: 'value',
            },
        };
        ws.send(JSON.stringify(request));
        expect(session.dispatch).toHaveBeenCalledTimes(1);
        expect(session.dispatch).toHaveBeenCalledWith((0, actions_1.socketMessageAction)(request));
    }));
    describe('signalwire.ping messages', () => {
        it('should response to signalwire.ping', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            session.connect();
            yield ws.connected;
            yield expect(ws).toReceiveMessage(JSON.stringify(rpcConnect));
            const ping = (0, RPCMessages_1.RPCPing)();
            ping.id = 'ping-uuid';
            ws.send(JSON.stringify(ping));
            const response = (0, RPCMessages_1.RPCPingResponse)(ping.id, ping.params.timestamp);
            yield expect(ws).toReceiveMessage(JSON.stringify(response));
        }));
        it('should close the connection if no signalwire.ping comes within _checkPingDelay', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            // Force _checkPingDelay to 5ms
            session['_checkPingDelay'] = 5;
            session.connect();
            yield ws.connected;
            const ping = (0, RPCMessages_1.RPCPing)();
            ping.id = 'ping-uuid';
            ws.send(JSON.stringify(ping));
            // Expect the session to be closed after 10ms
            yield (0, testUtils_1.wait)(10);
            expect(session.connected).toBe(false);
            expect(session.closed).toBe(true);
        }));
    });
});
//# sourceMappingURL=BaseSession.test.js.map