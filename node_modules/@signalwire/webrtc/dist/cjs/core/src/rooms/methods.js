"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setRaisedHand = exports.deleteMemberMeta = exports.updateMemberMeta = exports.setMemberMeta = exports.getMemberMeta = exports.removeAllMembers = exports.removeMember = exports.setMemberPosition = exports.demote = exports.promote = exports.setInputSensitivityMember = exports.setOutputVolumeMember = exports.setInputVolumeMember = exports.setDeaf = exports.undeafMember = exports.deafMember = exports.videoUnmuteMember = exports.videoMuteMember = exports.audioUnmuteMember = exports.audioMuteMember = exports.setPrioritizeHandraise = exports.startStream = exports.getStreams = exports.deleteMeta = exports.updateMeta = exports.setMeta = exports.getMeta = exports.play = exports.getPlaybacks = exports.startRecording = exports.getRecordings = exports.setHideVideoMuted = exports.unlock = exports.lock = exports.showVideoMuted = exports.hideVideoMuted = exports.setPositions = exports.setLayout = exports.getMembers = exports.getLayouts = void 0;
const tslib_1 = require("tslib");
const _1 = require(".");
/**
 * Transform for returning `undefined` for `execute`s that were
 * successully resolved. If the `execute` failed for some reason, then
 * the promise will be rejected and this transform will never be
 * executed.
 */
const baseCodeTransform = () => { };
const createRoomMethod = (method, options = {}) => ({
    value: function (params = {}) {
        return this.execute({
            method,
            params: Object.assign({ room_session_id: this.roomSessionId }, params),
        }, options);
    },
});
const createRoomMemberMethod = (method, options = {}) => ({
    value: function (_a = {}) {
        var { memberId } = _a, rest = tslib_1.__rest(_a, ["memberId"]);
        return this.execute({
            method,
            params: Object.assign({ room_session_id: this.roomSessionId, member_id: memberId || this.memberId }, rest),
        }, options);
    },
});
/**
 * Room Methods
 */
exports.getLayouts = createRoomMethod('video.list_available_layouts', {
    transformResolve: (payload) => ({ layouts: payload.layouts }),
});
exports.getMembers = createRoomMethod('video.members.get', {
    transformResolve: (payload) => ({ members: payload.members }),
});
exports.setLayout = createRoomMethod('video.set_layout', {
    transformResolve: baseCodeTransform,
});
exports.setPositions = createRoomMethod('video.set_position', {
    transformResolve: baseCodeTransform,
});
exports.hideVideoMuted = createRoomMethod('video.hide_video_muted', {
    transformResolve: baseCodeTransform,
});
exports.showVideoMuted = createRoomMethod('video.show_video_muted', {
    transformResolve: baseCodeTransform,
});
exports.lock = createRoomMethod('video.lock', {
    transformResolve: baseCodeTransform,
});
exports.unlock = createRoomMethod('video.unlock', {
    transformResolve: baseCodeTransform,
});
exports.setHideVideoMuted = {
    value: function (value) {
        return this.execute({
            method: value ? 'video.hide_video_muted' : 'video.show_video_muted',
            params: {
                room_session_id: this.roomSessionId,
            },
        }, {
            transformResolve: baseCodeTransform,
        });
    },
};
exports.getRecordings = {
    value: function () {
        return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { recordings } = yield this.execute({
                    method: 'video.recording.list',
                    params: {
                        room_session_id: this.roomSessionId,
                    },
                });
                const recordingInstances = [];
                recordings.forEach((recording) => {
                    let recordingInstance = this.instanceMap.get(recording.id);
                    if (!recordingInstance) {
                        recordingInstance = (0, _1.createRoomSessionRecordingObject)({
                            store: this.store,
                            payload: {
                                room_id: this.roomId,
                                room_session_id: this.roomSessionId,
                                recording,
                            },
                        });
                    }
                    else {
                        recordingInstance.setPayload({
                            room_id: this.roomId,
                            room_session_id: this.roomSessionId,
                            recording,
                        });
                    }
                    recordingInstances.push(recordingInstance);
                    this.instanceMap.set(recordingInstance.id, recordingInstance);
                });
                resolve({ recordings: recordingInstances });
            }
            catch (error) {
                reject(error);
            }
        }));
    },
};
exports.startRecording = {
    value: function () {
        return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { recording } = yield this.execute({
                    method: 'video.recording.start',
                    params: {
                        room_session_id: this.roomSessionId,
                    },
                });
                const recordingInstance = (0, _1.createRoomSessionRecordingObject)({
                    store: this.store,
                    payload: {
                        room_id: this.roomId,
                        room_session_id: this.roomSessionId,
                        recording,
                    },
                });
                this.instanceMap.set(recordingInstance.id, recordingInstance);
                resolve(recordingInstance);
            }
            catch (error) {
                reject(error);
            }
        }));
    },
};
exports.getPlaybacks = {
    value: function () {
        return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { playbacks } = yield this.execute({
                    method: 'video.playback.list',
                    params: {
                        room_session_id: this.roomSessionId,
                    },
                });
                const playbackInstances = [];
                playbacks.forEach((playback) => {
                    let playbackInstance = this.instanceMap.get(playback.id);
                    if (!playbackInstance) {
                        playbackInstance = (0, _1.createRoomSessionPlaybackObject)({
                            store: this.store,
                            payload: {
                                room_id: this.roomId,
                                room_session_id: this.roomSessionId,
                                playback,
                            },
                        });
                    }
                    else {
                        playbackInstance.setPayload({
                            room_id: this.roomId,
                            room_session_id: this.roomSessionId,
                            playback,
                        });
                    }
                    playbackInstances.push(playbackInstance);
                    this.instanceMap.set(playbackInstance.id, playbackInstance);
                });
                resolve({ playbacks: playbackInstances });
            }
            catch (error) {
                reject(error);
            }
        }));
    },
};
exports.play = {
    value: function (_a) {
        var { seekPosition, currentTimecode } = _a, params = tslib_1.__rest(_a, ["seekPosition", "currentTimecode"]);
        return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const seek_position = seekPosition || currentTimecode;
                const { playback } = yield this.execute({
                    method: 'video.playback.start',
                    params: Object.assign({ room_session_id: this.roomSessionId, seek_position }, params),
                });
                const playbackInstance = (0, _1.createRoomSessionPlaybackObject)({
                    store: this.store,
                    payload: {
                        room_id: this.roomId,
                        room_session_id: this.roomSessionId,
                        playback,
                    },
                });
                this.instanceMap.set(playbackInstance.id, playbackInstance);
                resolve(playbackInstance);
            }
            catch (error) {
                reject(error);
            }
        }));
    },
};
const createRoomMetaMethod = (method) => {
    return createRoomMethod(method, {
        transformResolve: baseCodeTransform,
        transformParams: (params) => {
            const { room_session_id } = params, meta = tslib_1.__rest(params, ["room_session_id"]);
            return { room_session_id, meta };
        },
    });
};
exports.getMeta = createRoomMethod('video.get_meta', {
    transformResolve: ({ meta }) => ({ meta }),
});
exports.setMeta = createRoomMetaMethod('video.set_meta');
exports.updateMeta = createRoomMetaMethod('video.update_meta');
exports.deleteMeta = {
    value: function (params) {
        return this.execute({
            method: 'video.delete_meta',
            params: {
                room_session_id: this.roomSessionId,
                keys: params,
            },
        });
    },
};
exports.getStreams = {
    value: function () {
        return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { streams } = yield this.execute({
                    method: 'video.stream.list',
                    params: {
                        room_session_id: this.roomSessionId,
                    },
                });
                const streamInstances = [];
                streams.forEach((stream) => {
                    let streamInstance = this.instanceMap.get(stream.id);
                    if (!streamInstance) {
                        streamInstance = (0, _1.createRoomSessionStreamObject)({
                            store: this.store,
                            payload: {
                                room_id: this.roomId,
                                room_session_id: this.roomSessionId,
                                stream,
                            },
                        });
                    }
                    else {
                        streamInstance.setPayload({
                            room_id: this.roomId,
                            room_session_id: this.roomSessionId,
                            stream,
                        });
                    }
                    streamInstances.push(streamInstance);
                    this.instanceMap.set(streamInstance.id, streamInstance);
                });
                resolve({ streams: streamInstances });
            }
            catch (error) {
                reject(error);
            }
        }));
    },
};
exports.startStream = {
    value: function (params) {
        return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { stream } = yield this.execute({
                    method: 'video.stream.start',
                    params: Object.assign({ room_session_id: this.roomSessionId }, params),
                });
                const streamInstance = (0, _1.createRoomSessionStreamObject)({
                    store: this.store,
                    payload: {
                        room_id: this.roomId,
                        room_session_id: this.roomSessionId,
                        stream,
                    },
                });
                this.instanceMap.set(streamInstance.id, streamInstance);
                resolve({ stream: streamInstance });
            }
            catch (error) {
                reject(error);
            }
        }));
    },
};
exports.setPrioritizeHandraise = {
    value: function (params) {
        return this.execute({
            method: 'video.prioritize_handraise',
            params: {
                room_session_id: this.roomSessionId,
                enable: params,
            },
        });
    },
};
// End Room Methods
/**
 * Room Member Methods
 */
exports.audioMuteMember = createRoomMemberMethod('video.member.audio_mute', {
    transformResolve: baseCodeTransform,
});
exports.audioUnmuteMember = createRoomMemberMethod('video.member.audio_unmute', {
    transformResolve: baseCodeTransform,
});
exports.videoMuteMember = createRoomMemberMethod('video.member.video_mute', {
    transformResolve: baseCodeTransform,
});
exports.videoUnmuteMember = createRoomMemberMethod('video.member.video_unmute', {
    transformResolve: baseCodeTransform,
});
exports.deafMember = createRoomMemberMethod('video.member.deaf', {
    transformResolve: baseCodeTransform,
});
exports.undeafMember = createRoomMemberMethod('video.member.undeaf', {
    transformResolve: baseCodeTransform,
});
// This is used on a RoomSessionMember instance where we have
// `this.roomSessionId` and `this.memberId`
exports.setDeaf = {
    value: function (value) {
        return this.execute({
            method: value ? 'video.member.deaf' : 'video.member.undeaf',
            params: {
                room_session_id: this.roomSessionId,
                member_id: this.memberId,
            },
        }, {
            transformResolve: baseCodeTransform,
        });
    },
};
exports.setInputVolumeMember = createRoomMemberMethod('video.member.set_input_volume', {
    transformResolve: baseCodeTransform,
});
exports.setOutputVolumeMember = createRoomMemberMethod('video.member.set_output_volume', {
    transformResolve: baseCodeTransform,
});
exports.setInputSensitivityMember = createRoomMemberMethod('video.member.set_input_sensitivity', {
    transformResolve: baseCodeTransform,
});
exports.promote = {
    value: function (_a) {
        var { memberId, mediaAllowed, joinAudioMuted, joinVideoMuted } = _a, rest = tslib_1.__rest(_a, ["memberId", "mediaAllowed", "joinAudioMuted", "joinVideoMuted"]);
        return this.execute({
            method: 'video.member.promote',
            params: Object.assign({ room_session_id: this.roomSessionId, member_id: memberId, media_allowed: mediaAllowed, join_audio_muted: joinAudioMuted, join_video_muted: joinVideoMuted }, rest),
        }, {
            transformResolve: baseCodeTransform,
        });
    },
};
exports.demote = {
    value: function ({ memberId, mediaAllowed }) {
        return this.execute({
            method: 'video.member.demote',
            params: {
                room_session_id: this.roomSessionId,
                member_id: memberId,
                media_allowed: mediaAllowed,
            },
        }, {
            transformResolve: baseCodeTransform,
        });
    },
};
exports.setMemberPosition = createRoomMemberMethod('video.member.set_position', {
    transformResolve: baseCodeTransform,
});
exports.removeMember = {
    value: function (_a) {
        var { memberId } = _a, rest = tslib_1.__rest(_a, ["memberId"]);
        if (!memberId) {
            throw new TypeError('Invalid or missing "memberId" argument');
        }
        return this.execute({
            method: 'video.member.remove',
            params: Object.assign({ room_session_id: this.roomSessionId, member_id: memberId }, rest),
        }, {
            transformResolve: baseCodeTransform,
        });
    },
};
exports.removeAllMembers = {
    value: function () {
        return this.execute({
            method: 'video.member.remove',
            params: {
                room_session_id: this.roomSessionId,
                member_id: 'all',
            },
        }, {
            transformResolve: baseCodeTransform,
        });
    },
};
exports.getMemberMeta = createRoomMemberMethod('video.member.get_meta', {
    transformResolve: ({ meta }) => ({ meta }),
});
exports.setMemberMeta = createRoomMemberMethod('video.member.set_meta', {
    transformResolve: baseCodeTransform,
});
exports.updateMemberMeta = createRoomMemberMethod('video.member.update_meta', {
    transformResolve: baseCodeTransform,
});
exports.deleteMemberMeta = createRoomMemberMethod('video.member.delete_meta', {
    transformResolve: baseCodeTransform,
});
exports.setRaisedHand = {
    value: function (value) {
        const { raised = true, memberId = this.memberId } = value || {};
        if (!memberId) {
            throw new TypeError('Invalid or missing "memberId" argument');
        }
        return this.execute({
            method: raised ? 'video.member.raisehand' : 'video.member.lowerhand',
            params: {
                room_session_id: this.roomSessionId,
                member_id: memberId,
            },
        }, {
            transformResolve: baseCodeTransform,
        });
    },
};
// End Room Member Methods
//# sourceMappingURL=methods.js.map