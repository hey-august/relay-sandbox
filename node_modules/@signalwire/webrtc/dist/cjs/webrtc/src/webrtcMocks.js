"use strict";
// @ts-nocheck
Object.defineProperty(exports, "__esModule", { value: true });
exports.RTCPeerConnectionMock = exports.MediaStreamTrackMock = exports.MediaStreamMock = void 0;
// These are mocked objects to test WebRTC logic.
// Ignore TS checking for now since all the methods arguments are "unused".
class MediaStreamMock {
    constructor() {
        this._tracks = [];
    }
    addTrack(track) {
        this._tracks.push(track);
    }
    clone() {
        throw new Error('Method not implemented: clone');
    }
    getTrackById(trackId) {
        throw new Error('Method not implemented: getTrackById');
    }
    removeTrack(track) {
        throw new Error('Method not implemented: removeTrack');
    }
    stop() {
        throw new Error('Method not implemented: stop');
    }
    addEventListener(type, listener, options) {
        throw new Error('Method not implemented: addEventListener');
    }
    removeEventListener(type, listener, options) {
        throw new Error('Method not implemented: removeEventListener');
    }
    dispatchEvent(event) {
        throw new Error('Method not implemented: dispatchEvent');
    }
    getTracks() {
        return this._tracks;
    }
    getVideoTracks() {
        return this._tracks.filter((t) => t.kind === 'video');
    }
    getAudioTracks() {
        return this._tracks.filter((t) => t.kind === 'audio');
    }
}
exports.MediaStreamMock = MediaStreamMock;
class MediaStreamTrackMock {
    constructor() {
        this.enabled = true;
        this.id = 'uuid';
        this.label = 'Track Label';
    }
    applyConstraints(constraints) {
        throw new Error('Method not implemented: applyConstraints');
    }
    clone() {
        throw new Error('Method not implemented: clone');
    }
    getCapabilities() {
        throw new Error('Method not implemented: getCapabilities');
    }
    getConstraints() {
        throw new Error('Method not implemented: getConstraints');
    }
    getSettings() {
        throw new Error('Method not implemented: getSettings');
    }
    stop() {
        this.enabled = false;
        this.readyState = 'ended';
    }
    addEventListener(type, listener, options) {
        // throw new Error("Method not implemented: addEventListener")
    }
    removeEventListener(type, listener, options) {
        // throw new Error("Method not implemented: removeEventListener")
    }
    dispatchEvent(event) {
        throw new Error('Method not implemented: dispatchEvent');
    }
}
exports.MediaStreamTrackMock = MediaStreamTrackMock;
class RTCRtpSenderMock {
    getParameters() {
        throw new Error('Method not implemented: getParameters');
    }
    getStats() {
        throw new Error('Method not implemented: getStats');
    }
    replaceTrack(withTrack) {
        throw new Error('Method not implemented: replaceTrack');
    }
    setParameters(parameters) {
        throw new Error('Method not implemented: setParameters');
    }
    setStreams(...streams) {
        throw new Error('Method not implemented: setStreams');
    }
}
class RTCPeerConnectionMock {
    // addIceCandidate(candidate: RTCIceCandidateInit | RTCIceCandidate): Promise<void>
    // addIceCandidate(candidate?: RTCIceCandidateInit | RTCIceCandidate): Promise<void>
    // addIceCandidate(candidate: RTCIceCandidateInit | RTCIceCandidate, successCallback: () => void, failureCallback: RTCPeerConnectionErrorCallback): Promise<void>
    addIceCandidate(candidate) {
        throw new Error('Method not implemented: addIceCandidate');
    }
    addTrack(track, ...streams) {
        // throw new Error('Method not implemented: addTrack')
        return new RTCRtpSenderMock();
    }
    addTransceiver(trackOrKind, init) {
        return {};
    }
    close() {
        throw new Error('Method not implemented: close');
    }
    createAnswer(successCallback, failureCallback) {
        throw new Error('Method not implemented: createAnswer');
    }
    createDataChannel(label, dataChannelDict) {
        throw new Error('Method not implemented: createDataChannel');
    }
    createOffer(successCallback, failureCallback, options) {
        throw new Error('Method not implemented: createOffer');
    }
    getConfiguration() {
        throw new Error('Method not implemented: getConfiguration');
    }
    getIdentityAssertion() {
        throw new Error('Method not implemented: getIdentityAssertion');
    }
    getReceivers() {
        throw new Error('Method not implemented: getReceivers');
    }
    getSenders() {
        throw new Error('Method not implemented: getSenders');
    }
    getStats(selector, successCallback, failureCallback) {
        throw new Error('Method not implemented: getStats');
    }
    getTransceivers() {
        return [];
    }
    removeTrack(sender) {
        throw new Error('Method not implemented: removeTrack');
    }
    setConfiguration(configuration) {
        throw new Error('Method not implemented: setConfiguration');
    }
    setIdentityProvider(provider, options) {
        throw new Error('Method not implemented: setIdentityProvider');
    }
    setLocalDescription(description, successCallback, failureCallback) {
        throw new Error('Method not implemented: setLocalDescription');
    }
    setRemoteDescription(description, successCallback, failureCallback) {
        throw new Error('Method not implemented: setRemoteDescription');
    }
    addEventListener(type, listener, options) {
        // throw new Error('Method not implemented: addEventListener')
    }
    removeEventListener(type, listener, options) {
        throw new Error('Method not implemented: removeEventListener');
    }
    dispatchEvent(event) {
        throw new Error('Method not implemented: dispatchEvent');
    }
}
exports.RTCPeerConnectionMock = RTCPeerConnectionMock;
//# sourceMappingURL=webrtcMocks.js.map