"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._getMediaDeviceKindByName = exports.stopTrack = exports.stopStream = exports.sdpToJsonHack = exports.setMediaElementSinkId = exports.supportsMediaOutput = exports.streamIsValid = exports.getSupportedConstraints = exports.supportsGetDisplayMedia = exports.supportsGetUserMedia = exports.getMediaDevicesApi = exports.supportsMediaDevices = exports.RTCPeerConnection = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@signalwire/core");
const RTCPeerConnection = (config) => {
    return new window.RTCPeerConnection(config);
};
exports.RTCPeerConnection = RTCPeerConnection;
/**
 * Returns whether the current environment supports the media devices API.
 */
const supportsMediaDevices = () => {
    return typeof navigator !== 'undefined' && !!navigator.mediaDevices;
};
exports.supportsMediaDevices = supportsMediaDevices;
/**
 * Returns the mediaDevices object if supported, otherwise throws an error.
 */
const getMediaDevicesApi = () => {
    if (!(0, exports.supportsMediaDevices)()) {
        throw new Error("The media devices API isn't supported in this environment");
    }
    return navigator.mediaDevices;
};
exports.getMediaDevicesApi = getMediaDevicesApi;
/**
 * Returns whether the current environment supports `getUserMedia`.
 */
const supportsGetUserMedia = () => {
    return typeof (0, exports.getMediaDevicesApi)().getUserMedia === 'function';
};
exports.supportsGetUserMedia = supportsGetUserMedia;
/**
 * Returns whether the current environment supports `getDisplayMedia`.
 */
const supportsGetDisplayMedia = () => {
    return typeof (0, exports.getMediaDevicesApi)().getDisplayMedia === 'function';
};
exports.supportsGetDisplayMedia = supportsGetDisplayMedia;
/**
 * Returns a dictionary whose fields specify the constrainable properties the user agent understands.
 */
const getSupportedConstraints = () => {
    return (0, exports.getMediaDevicesApi)().getSupportedConstraints();
};
exports.getSupportedConstraints = getSupportedConstraints;
const streamIsValid = (stream) => stream && stream instanceof MediaStream;
exports.streamIsValid = streamIsValid;
/**
 * Returns whether the current environment supports the selection of a media output device.
 */
const supportsMediaOutput = () => {
    return 'sinkId' in HTMLMediaElement.prototype;
};
exports.supportsMediaOutput = supportsMediaOutput;
/**
 * Assigns the specified audio output device to the specified HTMLMediaElement.
 * The device with id `deviceId` must be an audio output device. Asynchronously
 * returns whether the operation had success.
 *
 * > ðŸ“˜
 * > Some browsers do not support output device selection. You can check by
 * > calling [`supportsMediaOutput`](supportsmediaoutput).
 *
 * @param el target element
 * @param deviceId id of the audio output device
 * @returns a promise of whether the operation had success
 *
 * @example
 * ```typescript
 * const el = document.querySelector('video')
 * const outDevices = await SignalWire.WebRTC.getSpeakerDevicesWithPermissions()
 * await SignalWire.WebRTC.setMediaElementSinkId(el, outDevices[0].deviceId)
 * // true
```
 */
const setMediaElementSinkId = (el, deviceId) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    if (el === null) {
        (0, core_1.getLogger)().warn('No HTMLMediaElement to attach the speakerId');
        return;
    }
    else if (typeof deviceId !== 'string') {
        (0, core_1.getLogger)().warn(`Invalid speaker deviceId: '${deviceId}'`);
        return;
    }
    else if (!(0, exports.supportsMediaOutput)()) {
        (0, core_1.getLogger)().warn('Browser does not support output device selection.');
        return;
    }
    try {
        // @ts-ignore
        return yield el.setSinkId(deviceId);
    }
    catch (error) {
        if (error.name === 'SecurityError') {
            (0, core_1.getLogger)().error(`You need to use HTTPS for selecting audio output device: ${error}`);
        }
        else {
            (0, core_1.getLogger)().error(`Error: ${error}`);
        }
        throw error;
    }
});
exports.setMediaElementSinkId = setMediaElementSinkId;
const sdpToJsonHack = (sdp) => sdp;
exports.sdpToJsonHack = sdpToJsonHack;
const stopStream = (stream) => {
    var _a;
    if ((0, exports.streamIsValid)(stream)) {
        (_a = stream === null || stream === void 0 ? void 0 : stream.getTracks()) === null || _a === void 0 ? void 0 : _a.forEach(exports.stopTrack);
    }
};
exports.stopStream = stopStream;
const stopTrack = (track) => {
    if (track && track.readyState === 'live') {
        track.stop();
        track.dispatchEvent(new Event('ended'));
    }
};
exports.stopTrack = stopTrack;
/**
 * Maps permission's names from `DevicePermissionDescriptor["name"]`
 * to `MediaDeviceKind`
 */
const PERMISSIONS_MAPPING = {
    camera: 'videoinput',
    microphone: 'audioinput',
    speaker: 'audiooutput',
};
const _getMediaDeviceKindByName = (name) => {
    if (!name) {
        return undefined;
    }
    return PERMISSIONS_MAPPING[name];
};
exports._getMediaDeviceKindByName = _getMediaDeviceKindByName;
//# sourceMappingURL=primitives.js.map