"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.watchRTCPeerMediaPackets = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@signalwire/core");
const watchRTCPeerMediaPackets = (rtcPeer) => {
    if (!rtcPeer.hasAudioReceiver && !rtcPeer.hasVideoReceiver) {
        (0, core_1.getLogger)().warn(`Missing receivers to inspect media for RTCPeer "${rtcPeer.uuid}"`);
        return;
    }
    (0, core_1.getLogger)().debug(`Start watching media for RTCPeer "${rtcPeer.uuid}"`);
    let previousAudioValue = 0;
    let previousVideoValue = 0;
    let run = true;
    let timer;
    const clearTimer = () => {
        clearTimeout(timer);
    };
    const meter = () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        var _a, _b;
        let audioPacketsReceived = 0;
        let videoPacketsReceived = 0;
        try {
            const stats = yield rtcPeer.instance.getStats(null);
            const audioTrackId = (_a = rtcPeer.remoteAudioTrack) === null || _a === void 0 ? void 0 : _a.id;
            const videoTrackId = (_b = rtcPeer.remoteVideoTrack) === null || _b === void 0 ? void 0 : _b.id;
            stats.forEach((report) => {
                if (report.type === 'inbound-rtp' &&
                    report.kind === 'audio' &&
                    report.trackIdentifier === audioTrackId) {
                    (0, core_1.getLogger)().trace(`audio inbound-rtp: packetsReceived: ${report.packetsReceived} (at ${report.lastPacketReceivedTimestamp})`);
                    audioPacketsReceived = report.packetsReceived;
                }
                if (report.type === 'inbound-rtp' &&
                    report.kind === 'video' &&
                    report.trackIdentifier === videoTrackId) {
                    (0, core_1.getLogger)().trace(`video inbound-rtp: packetsReceived: ${report.packetsReceived} (at ${report.lastPacketReceivedTimestamp})`);
                    videoPacketsReceived = report.packetsReceived;
                }
            });
        }
        catch (error) {
            (0, core_1.getLogger)().warn('getStats error', error);
        }
        finally {
            const noAudioChanged = audioPacketsReceived && audioPacketsReceived <= previousAudioValue;
            const noVideoChanged = videoPacketsReceived && videoPacketsReceived <= previousVideoValue;
            if (noAudioChanged && noVideoChanged) {
                (0, core_1.getLogger)().warn(`audioPacketsReceived: ${audioPacketsReceived} - previousAudioValue: ${previousAudioValue}`);
                (0, core_1.getLogger)().warn(`videoPacketsReceived: ${videoPacketsReceived} - previousVideoValue: ${previousVideoValue}`);
                rtcPeer.triggerResume();
            }
            else {
                previousAudioValue = audioPacketsReceived !== null && audioPacketsReceived !== void 0 ? audioPacketsReceived : previousAudioValue;
                previousVideoValue = videoPacketsReceived !== null && videoPacketsReceived !== void 0 ? videoPacketsReceived : previousVideoValue;
                clearTimer();
                if (run && rtcPeer.instance.connectionState !== 'closed') {
                    timer = setTimeout(() => meter(), rtcPeer.watchMediaPacketsTimeout);
                }
            }
        }
    });
    return {
        start: () => {
            clearTimer();
            meter();
        },
        stop: () => {
            run = false;
            clearTimer();
        },
    };
};
exports.watchRTCPeerMediaPackets = watchRTCPeerMediaPackets;
//# sourceMappingURL=watchRTCPeerMediaPackets.js.map