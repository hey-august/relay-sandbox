"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseConnection = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@signalwire/core");
const RTCPeer_1 = tslib_1.__importDefault(require("./RTCPeer"));
const utils_1 = require("./utils");
const sdpHelpers_1 = require("./utils/sdpHelpers");
const workers = tslib_1.__importStar(require("./workers"));
const INVITE_VERSION = 1000;
const AUDIO_CONSTRAINTS = {
    echoCancellation: true,
    noiseSuppression: true,
    autoGainControl: true,
};
const AUDIO_CONSTRAINTS_SCREENSHARE = Object.assign(Object.assign({}, AUDIO_CONSTRAINTS), { noiseSuppression: false, autoGainControl: false, 
    // @ts-expect-error
    googAutoGainControl: false });
const VIDEO_CONSTRAINTS = {
    width: { ideal: 1280, min: 320 },
    height: { ideal: 720, min: 180 },
    aspectRatio: { ideal: 16 / 9 },
};
const DEFAULT_CALL_OPTIONS = {
    destinationNumber: 'room',
    remoteCallerName: 'Outbound Call',
    remoteCallerNumber: '',
    callerName: '',
    callerNumber: '',
    audio: AUDIO_CONSTRAINTS,
    video: VIDEO_CONSTRAINTS,
    useStereo: false,
    attach: false,
    screenShare: false,
    additionalDevice: false,
    userVariables: {},
    requestTimeout: 10 * 1000,
    autoApplyMediaParams: true,
    iceGatheringTimeout: 2 * 1000,
    maxIceGatheringTimeout: 5 * 1000,
    maxConnectionStateTimeout: 3 * 1000,
    watchMediaPackets: true,
    watchMediaPacketsTimeout: 2 * 1000,
};
class BaseConnection extends core_1.BaseComponent {
    constructor(options) {
        super(options);
        /** @internal */
        this.leaveReason = undefined;
        /** @internal */
        this.gotEarly = false;
        /** @internal */
        this.doReinvite = false;
        this.state = 'new';
        this.prevState = 'new';
        this.rtcPeerMap = new Map();
        this.resuming = false;
        /** @internal */
        this.onVertoBye = (params) => {
            this.logger.debug('onVertoBye', params);
            const { rtcPeerId, byeCause = 'NORMAL_CLEARING', byeCauseCode = '16', redirectDestination, } = params;
            this.cause = String(byeCause);
            this.causeCode = String(byeCauseCode);
            const rtcPeer = this.getRTCPeerById(rtcPeerId);
            if (!rtcPeer) {
                return this.logger.warn('Invalid RTCPeer to hangup', params);
            }
            if (redirectDestination && rtcPeer.localSdp) {
                this.logger.debug('Redirect Destination to:', redirectDestination, 'for RTCPeer:', rtcPeer.uuid);
                // Force nodeId to redirectDestination
                this.executeInvite(rtcPeer.localSdp, rtcPeer.uuid, redirectDestination);
                return;
            }
            // Notify RTCPeer for the bad signaling error
            rtcPeer.onRemoteBye({ code: this.causeCode, message: this.cause });
            // Set state to hangup only if the rtcPeer is the current one
            if (this.activeRTCPeerId === (rtcPeer === null || rtcPeer === void 0 ? void 0 : rtcPeer.uuid)) {
                this.logger.debug('onVertoBye go hangup');
                this.setState('hangup');
            }
        };
        this.options = Object.assign(Object.assign({}, DEFAULT_CALL_OPTIONS), options);
        this._checkDefaultMediaConstraints();
        this.setState('new');
        this.logger.trace('New Call with Options:', this.options);
        this._initPeer();
    }
    get id() {
        return this.__uuid;
    }
    get active() {
        return this.state === 'active';
    }
    get trying() {
        return this.state === 'trying';
    }
    get memberId() {
        // @ts-expect-error
        return this.component.memberId;
    }
    get previewUrl() {
        // @ts-expect-error
        return this.component.previewUrl;
    }
    get roomId() {
        // @ts-expect-error
        return this.component.roomId;
    }
    get roomSessionId() {
        // @ts-expect-error
        return this.component.roomSessionId;
    }
    get nodeId() {
        // @ts-expect-error
        return this.component.nodeId || this.options.nodeId;
    }
    get callId() {
        var _a;
        return ((_a = this.peer) === null || _a === void 0 ? void 0 : _a.uuid) || '';
    }
    get localStream() {
        var _a;
        return (_a = this.peer) === null || _a === void 0 ? void 0 : _a.localStream;
    }
    set localStream(stream) {
        if (this.peer) {
            this.peer.localStream = stream;
        }
    }
    get remoteStream() {
        var _a;
        return (_a = this.peer) === null || _a === void 0 ? void 0 : _a.remoteStream;
    }
    get iceServers() {
        var _a, _b;
        return (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.iceServers) !== null && _b !== void 0 ? _b : this.select(core_1.selectors.getIceServers);
    }
    get component() {
        return (this.select((state) => core_1.componentSelectors.getComponent(state, this.callId)) || {});
    }
    /** @internal */
    dialogParams(rtcPeerId) {
        const { destinationNumber, attach, callerName, callerNumber, remoteCallerName, remoteCallerNumber, userVariables, screenShare, additionalDevice, pingSupported = true, } = this.options;
        return {
            dialogParams: {
                id: rtcPeerId,
                destinationNumber,
                attach,
                callerName,
                callerNumber,
                remoteCallerName,
                remoteCallerNumber,
                userVariables,
                screenShare,
                additionalDevice,
                pingSupported,
                version: INVITE_VERSION,
            },
        };
    }
    get cameraId() {
        return this.peer ? this.peer.getDeviceId('video') : null;
    }
    get cameraLabel() {
        return this.peer ? this.peer.getDeviceLabel('video') : null;
    }
    get microphoneId() {
        return this.peer ? this.peer.getDeviceId('audio') : null;
    }
    get microphoneLabel() {
        return this.peer ? this.peer.getDeviceLabel('audio') : null;
    }
    /** @internal */
    get withAudio() {
        var _a;
        return Boolean((_a = this.peer) === null || _a === void 0 ? void 0 : _a.hasAudioReceiver);
    }
    /** @internal */
    get withVideo() {
        var _a;
        return Boolean((_a = this.peer) === null || _a === void 0 ? void 0 : _a.hasVideoReceiver);
    }
    get localVideoTrack() {
        return this.peer ? this.peer.localVideoTrack : null;
    }
    get localAudioTrack() {
        return this.peer ? this.peer.localAudioTrack : null;
    }
    get peer() {
        return this.getRTCPeerById(this.activeRTCPeerId);
    }
    set peer(rtcPeer) {
        if (!rtcPeer) {
            this.logger.warn('Invalid RTCPeer', rtcPeer);
            return;
        }
        this.logger.debug('Set RTCPeer', rtcPeer.uuid, rtcPeer);
        this.rtcPeerMap.set(rtcPeer.uuid, rtcPeer);
        if (this.peer && this.peer.instance && this.callId !== rtcPeer.uuid) {
            const oldPeerId = this.peer.uuid;
            this.logger.debug('>>> Stop old RTCPeer', oldPeerId);
            // Hangup the previous RTCPeer
            this.hangup(oldPeerId).catch(console.error);
            this.peer.detachAndStop();
            // Remove RTCPeer from local cache to stop answering to ping/pong
            // this.rtcPeerMap.delete(oldPeerId)
        }
        this.logger.debug('>>> Replace RTCPeer with', rtcPeer.uuid);
        this.activeRTCPeerId = rtcPeer.uuid;
    }
    getRTCPeerById(rtcPeerId) {
        return this.rtcPeerMap.get(rtcPeerId);
    }
    appendRTCPeer(rtcPeer) {
        return this.rtcPeerMap.set(rtcPeer.uuid, rtcPeer);
    }
    setActiveRTCPeer(rtcPeerId) {
        this.peer = this.getRTCPeerById(rtcPeerId);
    }
    setLocalStream(stream) {
        return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.peer || !this.localStream) {
                    return reject(new Error('Invalid RTCPeerConnection.'));
                }
                if (!(0, utils_1.streamIsValid)(stream)) {
                    return reject(new Error('Invalid stream provided.'));
                }
                const prevAudioTracks = this.localStream.getAudioTracks();
                const newAudioTracks = stream.getAudioTracks();
                if (newAudioTracks.length <= 0) {
                    this.logger.info('No audio track found in the stream provided. Audio will be unaffected.');
                }
                else {
                    prevAudioTracks.forEach((track) => {
                        var _a;
                        (0, utils_1.stopTrack)(track);
                        (_a = this.localStream) === null || _a === void 0 ? void 0 : _a.removeTrack(track);
                    });
                    newAudioTracks.forEach((track) => {
                        var _a;
                        (_a = this.localStream) === null || _a === void 0 ? void 0 : _a.addTrack(track);
                    });
                }
                const prevVideoTracks = this.localStream.getVideoTracks();
                const newVideoTracks = stream.getVideoTracks();
                if (newVideoTracks.length <= 0) {
                    this.logger.info('No video track found in the stream provided. Video will be unaffected.');
                }
                else {
                    prevVideoTracks.forEach((track) => {
                        var _a;
                        (0, utils_1.stopTrack)(track);
                        (_a = this.localStream) === null || _a === void 0 ? void 0 : _a.removeTrack(track);
                    });
                    newVideoTracks.forEach((track) => {
                        var _a;
                        (_a = this.localStream) === null || _a === void 0 ? void 0 : _a.addTrack(track);
                    });
                }
                yield this.updateStream(this.localStream);
                this.logger.debug('setLocalStream done');
                resolve(this.localStream);
            }
            catch (error) {
                this.logger.error('setLocalStream', error);
                reject(error);
            }
        }));
    }
    /**
     * @internal
     * Verto messages have to be wrapped into an execute
     * request and sent using the proper RPC WebRTCMethod.
     */
    vertoExecute(params) {
        return this.execute({
            method: this._getRPCMethod(),
            params,
        });
    }
    /** @internal */
    _getRPCMethod() {
        const authState = this.select(core_1.selectors.getAuthState);
        if (authState && (0, core_1.isSATAuth)(authState)) {
            return 'webrtc.verto';
        }
        return 'video.message';
    }
    /** @internal */
    _triggerNewRTCPeer() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug('_triggerNewRTCPeer Start');
            try {
                this.logger.debug('Build a new RTCPeer');
                const rtcPeer = this._buildPeer('offer');
                this.logger.debug('Trigger start for the new RTCPeer!');
                yield rtcPeer.start();
            }
            catch (error) {
                this.logger.error('Error building new RTCPeer to promote/demote', error);
            }
        });
    }
    updateCamera(constraints) {
        return this.updateConstraints({
            video: Object.assign({ aspectRatio: 16 / 9 }, constraints),
        });
    }
    updateMicrophone(constraints) {
        return this.updateConstraints({
            audio: constraints,
        });
    }
    /** @internal */
    manageSendersWithConstraints(constraints) {
        if (constraints.audio === false) {
            this.logger.info('Switching off the microphone');
            this.stopOutboundAudio();
        }
        if (constraints.video === false) {
            this.logger.info('Switching off the camera');
            this.stopOutboundVideo();
        }
        return constraints.audio || constraints.video;
    }
    /**
     * @internal
     */
    updateConstraints(constraints, { attempt = 0 } = {}) {
        if (attempt > 1) {
            return Promise.reject(new Error('Failed to update constraints'));
        }
        return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            try {
                if (!this.peer) {
                    return reject(new Error('Invalid RTCPeerConnection.'));
                }
                if (!Object.keys(constraints).length) {
                    return reject(new Error('Invalid audio/video constraints.'));
                }
                this.logger.debug('updateConstraints trying constraints', this.__uuid, constraints);
                const shouldContinueWithUpdate = this.manageSendersWithConstraints(constraints);
                if (!shouldContinueWithUpdate) {
                    this.logger.debug('Either `video` and `audio` (or both) constraints were set to `false` so their corresponding senders (if any) were stopped');
                    return resolve();
                }
                /**
                 * On some devices/browsers you cannot open more than one MediaStream at
                 * a time, per process. When this happens we'll try to do the following:
                 * 1. Stop the current media tracks
                 * 2. Try to get new media tracks with the new constraints
                 * 3. If we get an error: restore the media tracks using the previous
                 *    constraints.
                 * @see
                 * https://bugzilla.mozilla.org/show_bug.cgi?id=1238038
                 *
                 * Instead of just replace the track, force-stop the current one to free
                 * up the device
                 */
                let oldConstraints = {};
                (_a = this.localStream) === null || _a === void 0 ? void 0 : _a.getTracks().forEach((track) => {
                    var _a;
                    /**
                     * We'll keep a reference of the original constraints so if something
                     * fails we should be able to restore them.
                     */
                    // @ts-expect-error
                    oldConstraints[track.kind] = track.getConstraints();
                    // @ts-expect-error
                    if (constraints[track.kind] !== undefined) {
                        this.logger.debug('updateConstraints stop old tracks first?');
                        this.logger.debug('Track readyState:', track.kind, track.readyState);
                        (0, utils_1.stopTrack)(track);
                        track.stop();
                        (_a = this.localStream) === null || _a === void 0 ? void 0 : _a.removeTrack(track);
                    }
                });
                let newStream;
                try {
                    this.logger.info('updateConstraints with', constraints);
                    newStream = yield (0, utils_1.getUserMedia)(constraints);
                }
                catch (error) {
                    this.logger.error('Error updating device constraints:', error.name, error.message, error);
                    this.logger.info('Restoring previous constraints', oldConstraints);
                    yield this.updateConstraints(oldConstraints, {
                        attempt: attempt + 1,
                    });
                    return reject(error);
                }
                yield this.updateStream(newStream);
                this.logger.debug('updateConstraints done');
                resolve();
            }
            catch (error) {
                this.logger.error('updateConstraints', error);
                reject(error);
            }
            finally {
                (_b = this.peer) === null || _b === void 0 ? void 0 : _b._attachAudioTrackListener();
                (_c = this.peer) === null || _c === void 0 ? void 0 : _c._attachVideoTrackListener();
            }
        }));
    }
    updateStream(stream) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.peer) {
                throw new Error('Invalid RTCPeerConnection.');
            }
            // Store the previous tracks for device.updated event
            const prevVideoTrack = this.localVideoTrack;
            const prevAudioTrack = this.localAudioTrack;
            // Detach listeners because updateStream will trigger the track ended event
            this.peer._detachAudioTrackListener();
            this.peer._detachVideoTrackListener();
            this.logger.debug('updateStream got stream', stream);
            if (!this.localStream) {
                this.localStream = new MediaStream();
            }
            const { instance } = this.peer;
            const tracks = stream.getTracks();
            this.logger.debug(`updateStream got ${tracks.length} tracks`);
            for (let i = 0; i < tracks.length; i++) {
                const newTrack = tracks[i];
                this.logger.debug('updateStream apply track: ', newTrack);
                const transceiver = instance
                    .getTransceivers()
                    .find(({ mid, sender, receiver }) => {
                    if (sender.track && sender.track.kind === newTrack.kind) {
                        this.logger.debug('Found transceiver by sender');
                        return true;
                    }
                    if (receiver.track && receiver.track.kind === newTrack.kind) {
                        this.logger.debug('Found transceiver by receiver');
                        return true;
                    }
                    if (mid === null) {
                        this.logger.debug('Found disassociated transceiver');
                        return true;
                    }
                    return false;
                });
                if (transceiver && transceiver.sender) {
                    this.logger.debug('updateStream got transceiver', transceiver.currentDirection, transceiver.mid);
                    yield transceiver.sender.replaceTrack(newTrack);
                    this.logger.debug('updateStream replaceTrack');
                    transceiver.direction = 'sendrecv';
                    this.logger.debug('updateStream set to sendrecv');
                    this.localStream.getTracks().forEach((track) => {
                        var _a;
                        if (track.kind === newTrack.kind && track.id !== newTrack.id) {
                            this.logger.debug('updateStream stop old track and apply new one - ');
                            (0, utils_1.stopTrack)(track);
                            (_a = this.localStream) === null || _a === void 0 ? void 0 : _a.removeTrack(track);
                        }
                    });
                    this.localStream.addTrack(newTrack);
                }
                else {
                    this.logger.debug('updateStream no transceiver found. addTrack and start dancing!');
                    this.peer.type = 'offer';
                    this.doReinvite = true;
                    this.localStream.addTrack(newTrack);
                    instance.addTrack(newTrack, this.localStream);
                }
                this.logger.debug('updateStream simply update mic/cam');
                if (newTrack.kind === 'audio') {
                    // @ts-expect-error
                    this.emit('microphone.updated', {
                        previous: {
                            deviceId: prevAudioTrack === null || prevAudioTrack === void 0 ? void 0 : prevAudioTrack.id,
                            label: prevAudioTrack === null || prevAudioTrack === void 0 ? void 0 : prevAudioTrack.label,
                        },
                        current: {
                            deviceId: newTrack === null || newTrack === void 0 ? void 0 : newTrack.id,
                            label: newTrack === null || newTrack === void 0 ? void 0 : newTrack.label,
                        },
                    });
                    this.options.micId = newTrack.getSettings().deviceId;
                }
                else if (newTrack.kind === 'video') {
                    // @ts-expect-error
                    this.emit('camera.updated', {
                        previous: {
                            deviceId: prevVideoTrack === null || prevVideoTrack === void 0 ? void 0 : prevVideoTrack.id,
                            label: prevVideoTrack === null || prevVideoTrack === void 0 ? void 0 : prevVideoTrack.label,
                        },
                        current: {
                            deviceId: newTrack === null || newTrack === void 0 ? void 0 : newTrack.id,
                            label: newTrack === null || newTrack === void 0 ? void 0 : newTrack.label,
                        },
                    });
                    this.options.camId = newTrack.getSettings().deviceId;
                }
            }
            this.logger.debug('updateStream done');
        });
    }
    runRTCPeerWorkers(rtcPeerId) {
        this.runWorker('vertoEventWorker', {
            worker: workers.vertoEventWorker,
            initialState: { rtcPeerId },
        });
        const main = !(this.options.additionalDevice || this.options.screenShare);
        if (main) {
            this.runWorker('roomSubscribedWorker', {
                worker: workers.roomSubscribedWorker,
                initialState: { rtcPeerId },
            });
            this.runWorker('promoteDemoteWorker', {
                worker: workers.promoteDemoteWorker,
                initialState: { rtcPeerId },
            });
        }
    }
    /** @internal */
    invite() {
        return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.direction = 'outbound';
            this.peer = this._buildPeer('offer');
            try {
                yield this.peer.start();
                resolve(this);
            }
            catch (error) {
                this.logger.error('Invite error', error);
                reject(error);
            }
        }));
    }
    /** @internal */
    answer() {
        return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.direction = 'inbound';
            if (!this.peer) {
                this.peer = this._buildPeer('answer');
            }
            try {
                yield this.peer.start();
                resolve(this);
            }
            catch (error) {
                this.logger.error('Answer error', error);
                reject(error);
            }
        }));
    }
    /** @internal */
    onLocalSDPReady(rtcPeer) {
        if (!rtcPeer.instance.localDescription) {
            this.logger.error('Missing localDescription', rtcPeer);
            throw new Error('Invalid RTCPeerConnection localDescription');
        }
        const { type, sdp } = rtcPeer.instance.localDescription;
        const mungedSDP = this._mungeSDP(sdp);
        this.logger.debug('LOCAL SDP \n', `Type: ${type}`, '\n\n', mungedSDP);
        switch (type) {
            case 'offer':
                this._watchSessionAuth();
                // If we have a remoteDescription already, send reinvite
                if (!this.resuming && rtcPeer.instance.remoteDescription) {
                    return this.executeUpdateMedia(mungedSDP, rtcPeer.uuid);
                }
                else {
                    return this.executeInvite(mungedSDP, rtcPeer.uuid);
                }
            case 'answer':
                return this.executeAnswer(mungedSDP, rtcPeer.uuid);
            default:
                return this.logger.error(`Unknown SDP type: '${type}' on call ${this.id}`);
        }
    }
    /** @internal */
    _closeWSConnection() {
        this._watchSessionAuth();
        this.store.dispatch(core_1.actions.sessionForceCloseAction());
    }
    _watchSessionAuth() {
        if (this.sessionAuthTask) {
            this.sessionAuthTask.cancel();
        }
        this.sessionAuthTask = this.runWorker('sessionAuthWorker', {
            worker: workers.sessionAuthWorker,
        });
    }
    /** @internal */
    resume() {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.warn(`[resume] Call ${this.id}`);
            if ((_a = this.peer) === null || _a === void 0 ? void 0 : _a.instance) {
                const { connectionState } = this.peer.instance;
                this.logger.debug(`[resume] connectionState for ${this.id} is '${connectionState}'`);
                if (connectionState !== 'closed') {
                    this.resuming = true;
                    this.peer.restartIce();
                }
            }
        });
    }
    /**
     * Send the `verto.invite` only if the state is either `new` or `requesting`
     *   - new: the first time we send out the offer.
     *   - requesting: we received a redirectDestination so need to send it again
     *     specifying nodeId.
     *
     * @internal
     */
    executeInvite(sdp, rtcPeerId, nodeId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rtcPeer = this.getRTCPeerById(rtcPeerId);
            if (!rtcPeer || (rtcPeer.instance.remoteDescription && !this.resuming)) {
                throw new Error(`RTCPeer '${rtcPeerId}' already has a remoteDescription. Invalid invite.`);
            }
            // Set state to `requesting` only when `new`, otherwise keep it as `requesting`.
            if (this.state === 'new') {
                this.setState('requesting');
            }
            try {
                const ssOpts = this.options.screenShare
                    ? {
                        layout: this.options.layout,
                        positions: this.options.positions,
                    }
                    : {};
                const message = (0, core_1.VertoInvite)(Object.assign(Object.assign(Object.assign({}, this.dialogParams(rtcPeerId)), ssOpts), { sdp }));
                let subscribe = [];
                if (this.options.screenShare) {
                    /** @ts-expect-error - Only being used for debugging purposes */
                    subscribe = ['video.room.screenshare'];
                }
                else if (this.options.additionalDevice) {
                    /** @ts-expect-error - Only being used for debugging purposes */
                    subscribe = ['video.room.additionaldevice'];
                }
                else {
                    subscribe = this.getSubscriptions();
                }
                const response = yield this.vertoExecute({
                    message,
                    callID: rtcPeerId,
                    node_id: nodeId !== null && nodeId !== void 0 ? nodeId : this.options.nodeId,
                    subscribe,
                });
                this.logger.debug('Invite response', response);
                this.resuming = false;
            }
            catch (error) {
                this.setState('hangup');
                throw error;
            }
        });
    }
    /**
     * Send the `verto.answer` only if the state is `new`
     *   - new: the first time we send out the answer.
     * @internal
     */
    executeAnswer(sdp, rtcPeerId, nodeId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Set state to `answering` only when `new`, otherwise keep it as `answering`.
            if (this.state === 'new') {
                this.setState('answering');
            }
            try {
                const message = (0, core_1.VertoAnswer)(Object.assign(Object.assign({}, this.dialogParams(rtcPeerId)), { sdp }));
                const response = yield this.vertoExecute({
                    message,
                    callID: rtcPeerId,
                    node_id: nodeId !== null && nodeId !== void 0 ? nodeId : this.options.nodeId,
                    subscribe: this.getSubscriptions(),
                });
                this.logger.debug('Answer response', response);
                this.resuming = false;
                /** Call is active so set the RTCPeer */
                this.setActiveRTCPeer(rtcPeerId);
            }
            catch (error) {
                this.setState('hangup');
                throw error;
            }
        });
    }
    /** @internal */
    executeUpdateMedia(sdp, rtcPeerId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const message = (0, core_1.VertoModify)(Object.assign(Object.assign({}, this.dialogParams(rtcPeerId)), { sdp, action: 'updateMedia' }));
                const response = yield this.vertoExecute({
                    message,
                    callID: rtcPeerId,
                    node_id: this.nodeId,
                });
                if (!response.sdp) {
                    this.logger.error('UpdateMedia invalid SDP answer', response);
                }
                this.logger.debug('UpdateMedia response', response);
                if (!this.peer) {
                    return this.logger.error('Invalid RTCPeer to updateMedia');
                }
                yield this.peer.onRemoteSdp(response.sdp);
            }
            catch (error) {
                this.logger.error('UpdateMedia error', error);
                // this.setState('hangup')
                throw error;
            }
        });
    }
    hangup(id) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rtcPeerId = id !== null && id !== void 0 ? id : this.callId;
            if (!rtcPeerId) {
                throw new Error('Invalid RTCPeer ID to hangup');
            }
            try {
                const message = (0, core_1.VertoBye)(this.dialogParams(rtcPeerId));
                yield this.vertoExecute({
                    message,
                    callID: rtcPeerId,
                    node_id: this.nodeId,
                });
            }
            catch (error) {
                this.logger.error('Hangup error:', error);
            }
            finally {
                if (rtcPeerId !== this.callId) {
                    return this.logger.warn('Prevent setState hangup', rtcPeerId, this.callId);
                }
                this.setState('hangup');
            }
        });
    }
    hangupAll() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rtcPeerId = this.callId;
            if (!rtcPeerId) {
                throw new Error('Invalid RTCPeer ID to hangup');
            }
            try {
                const message = (0, core_1.VertoBye)(Object.assign({ cause: 'REJECT_ALL', causeCode: '825' }, this.dialogParams(rtcPeerId)));
                yield this.vertoExecute({
                    message,
                    callID: rtcPeerId,
                    node_id: this.nodeId,
                });
            }
            catch (error) {
                this.logger.error('HangupAll error:', error);
            }
            finally {
                this.setState('hangup');
            }
        });
    }
    sendDigits(dtmf) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rtcPeerId = this.callId;
            if (!rtcPeerId) {
                throw new Error('Invalid RTCPeer ID to send DTMF');
            }
            const message = (0, core_1.VertoInfo)(Object.assign(Object.assign({}, this.dialogParams(rtcPeerId)), { dtmf }));
            yield this.vertoExecute({
                message,
                callID: rtcPeerId,
                node_id: this.nodeId,
            });
        });
    }
    /** @internal */
    doReinviteWithRelayOnly() {
        if (this.peer && this.active) {
            this.peer.restartIceWithRelayOnly();
        }
    }
    /** @internal */
    stopOutboundAudio() {
        if (this.peer && this.active) {
            this.peer.stopTrackSender('audio');
        }
    }
    /** @internal */
    restoreOutboundAudio() {
        if (this.peer && this.active) {
            this.peer.restoreTrackSender('audio');
        }
    }
    /** @internal */
    stopOutboundVideo() {
        if (this.peer && this.active) {
            this.peer.stopTrackSender('video');
        }
    }
    /** @internal */
    restoreOutboundVideo() {
        if (this.peer && this.active) {
            this.peer.restoreTrackSender('video');
        }
    }
    /** @internal */
    setState(state) {
        this.prevState = this.state;
        this.state = state;
        this.logger.trace(`Call ${this.id} state change from ${this.prevState} to ${this.state}`);
        // @ts-expect-error
        this.emitter.emit(this.state, this);
        switch (state) {
            case 'purge': {
                this._finalize();
                break;
            }
            case 'hangup': {
                this.setState('destroy');
                break;
            }
            case 'destroy':
                this._finalize();
                break;
        }
    }
    /** @internal */
    updateMediaOptions(options) {
        this.logger.debug('updateMediaOptions', Object.assign({}, options));
        this.options = Object.assign(Object.assign({}, this.options), options);
        this._checkDefaultMediaConstraints();
    }
    /**
     * Allow to define logic to munge the SDP
     *
     * @internal
     * */
    _mungeSDP(sdp) {
        return (0, sdpHelpers_1.sdpRemoveLocalCandidates)(sdp);
    }
    /**
     * Always use VIDEO_CONSTRAINTS if video: true
     * Always use AUDIO_CONSTRAINTS (or the SS one) if audio: true
     *
     * @internal
     */
    _checkDefaultMediaConstraints() {
        if (this.options.video === true) {
            this.options.video = VIDEO_CONSTRAINTS;
        }
        if (this.options.audio === true) {
            this.options.audio = this.options.screenShare
                ? AUDIO_CONSTRAINTS_SCREENSHARE
                : AUDIO_CONSTRAINTS;
        }
    }
    _initPeer() {
        // Build only for answer to be able to reject
        if (this.options.remoteSdp) {
            this.peer = this._buildPeer('answer');
        }
    }
    _buildPeer(type) {
        const rtcPeer = new RTCPeer_1.default(this, type);
        this.appendRTCPeer(rtcPeer);
        this.runRTCPeerWorkers(rtcPeer.uuid);
        return rtcPeer;
    }
    /** @internal */
    _finalize() {
        this.rtcPeerMap.forEach((rtcPeer) => {
            rtcPeer.stop();
        });
        this.rtcPeerMap.clear();
    }
}
exports.BaseConnection = BaseConnection;
//# sourceMappingURL=BaseConnection.js.map