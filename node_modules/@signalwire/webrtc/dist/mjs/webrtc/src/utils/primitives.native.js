import { RTCPeerConnection as RNRTCPeerConnection, mediaDevices as RNmediaDevices, MediaStream as RNMediaStream,
// @ts-ignore
 } from 'react-native-webrtc';
export const RTCPeerConnection = (config) => {
    var _a;
    const _config = ((_a = Object.keys(config)) === null || _a === void 0 ? void 0 : _a.length) ? config : null;
    return new RNRTCPeerConnection(_config);
};
/**
 * Returns whether the current environment supports the media devices API.
 */
export const supportsMediaDevices = () => {
    return !!RNmediaDevices;
};
/**
 * Returns the mediaDevices object if supported, otherwise throws an error.
 */
export const getMediaDevicesApi = () => {
    if (!supportsMediaDevices()) {
        throw new Error("The media devices API isn't supported in this environment");
    }
    return RNmediaDevices;
};
/**
 * Returns whether the current environment supports `getUserMedia`.
 */
export const supportsGetUserMedia = () => {
    return typeof getMediaDevicesApi().getUserMedia === 'function';
};
/**
 * Returns whether the current environment supports `getDisplayMedia`.
 */
export const supportsGetDisplayMedia = () => {
    return typeof getMediaDevicesApi().getDisplayMedia === 'function';
};
/**
 * Returns a dictionary whose fields specify the constrainable properties the user agent understands.
 * Not supported on React Native
 */
export const getSupportedConstraints = () => ({});
export const streamIsValid = (stream) => stream && stream instanceof RNMediaStream;
/**
 * Returns whether the current environment supports the selection of a media output device.
 * Not supported in React Native.
 */
export const supportsMediaOutput = () => {
    return false;
};
export const setMediaElementSinkId = (_htmlElementId, _deviceId) => Promise.resolve(false);
export const sdpToJsonHack = (sdp) => {
    Object.defineProperty(sdp, 'toJSON', { value: () => sdp });
    return sdp;
};
export const stopStream = (stream) => {
    var _a;
    if (streamIsValid(stream)) {
        (_a = stream === null || stream === void 0 ? void 0 : stream.getTracks()) === null || _a === void 0 ? void 0 : _a.forEach(stopTrack);
    }
    stream = null;
};
/**
 * This class in implemented by `react-native-webrtc` but
 * it's not exported directly. To avoid dealing with manual
 * file imports and having (potential) issues of mixing
 * commonjs/esm we ported it here since it's just a few
 * lines of code.
 */
class MediaStreamTrackEvent {
    constructor(type, eventInitDict) {
        this.type = type.toString();
        this.track = eventInitDict.track;
    }
}
export const stopTrack = (track) => {
    if (track && track.readyState === 'live') {
        track.stop();
        track.dispatchEvent(
        // @ts-expect-error
        new MediaStreamTrackEvent('ended', { track }));
    }
};
/**
 * Maps permission's names from `DevicePermissionDescriptor["name"]`
 * to `MediaDeviceKind`
 */
const PERMISSIONS_MAPPING = {
    camera: 'videoinput',
    microphone: 'audioinput',
    speaker: 'audiooutput',
};
export const _getMediaDeviceKindByName = (name) => {
    if (!name) {
        return undefined;
    }
    return PERMISSIONS_MAPPING[name];
};
//# sourceMappingURL=primitives.native.js.map