import { getLogger } from '@signalwire/core';
export const RTCPeerConnection = (config) => {
    return new window.RTCPeerConnection(config);
};
/**
 * Returns whether the current environment supports the media devices API.
 */
export const supportsMediaDevices = () => {
    return typeof navigator !== 'undefined' && !!navigator.mediaDevices;
};
/**
 * Returns the mediaDevices object if supported, otherwise throws an error.
 */
export const getMediaDevicesApi = () => {
    if (!supportsMediaDevices()) {
        throw new Error("The media devices API isn't supported in this environment");
    }
    return navigator.mediaDevices;
};
/**
 * Returns whether the current environment supports `getUserMedia`.
 */
export const supportsGetUserMedia = () => {
    return typeof getMediaDevicesApi().getUserMedia === 'function';
};
/**
 * Returns whether the current environment supports `getDisplayMedia`.
 */
export const supportsGetDisplayMedia = () => {
    return typeof getMediaDevicesApi().getDisplayMedia === 'function';
};
/**
 * Returns a dictionary whose fields specify the constrainable properties the user agent understands.
 */
export const getSupportedConstraints = () => {
    return getMediaDevicesApi().getSupportedConstraints();
};
export const streamIsValid = (stream) => stream && stream instanceof MediaStream;
/**
 * Returns whether the current environment supports the selection of a media output device.
 */
export const supportsMediaOutput = () => {
    return 'sinkId' in HTMLMediaElement.prototype;
};
/**
 * Assigns the specified audio output device to the specified HTMLMediaElement.
 * The device with id `deviceId` must be an audio output device. Asynchronously
 * returns whether the operation had success.
 *
 * > ðŸ“˜
 * > Some browsers do not support output device selection. You can check by
 * > calling [`supportsMediaOutput`](supportsmediaoutput).
 *
 * @param el target element
 * @param deviceId id of the audio output device
 * @returns a promise of whether the operation had success
 *
 * @example
 * ```typescript
 * const el = document.querySelector('video')
 * const outDevices = await SignalWire.WebRTC.getSpeakerDevicesWithPermissions()
 * await SignalWire.WebRTC.setMediaElementSinkId(el, outDevices[0].deviceId)
 * // true
```
 */
export const setMediaElementSinkId = async (el, deviceId) => {
    if (el === null) {
        getLogger().warn('No HTMLMediaElement to attach the speakerId');
        return;
    }
    else if (typeof deviceId !== 'string') {
        getLogger().warn(`Invalid speaker deviceId: '${deviceId}'`);
        return;
    }
    else if (!supportsMediaOutput()) {
        getLogger().warn('Browser does not support output device selection.');
        return;
    }
    try {
        // @ts-ignore
        return await el.setSinkId(deviceId);
    }
    catch (error) {
        if (error.name === 'SecurityError') {
            getLogger().error(`You need to use HTTPS for selecting audio output device: ${error}`);
        }
        else {
            getLogger().error(`Error: ${error}`);
        }
        throw error;
    }
};
export const sdpToJsonHack = (sdp) => sdp;
export const stopStream = (stream) => {
    var _a;
    if (streamIsValid(stream)) {
        (_a = stream === null || stream === void 0 ? void 0 : stream.getTracks()) === null || _a === void 0 ? void 0 : _a.forEach(stopTrack);
    }
};
export const stopTrack = (track) => {
    if (track && track.readyState === 'live') {
        track.stop();
        track.dispatchEvent(new Event('ended'));
    }
};
/**
 * Maps permission's names from `DevicePermissionDescriptor["name"]`
 * to `MediaDeviceKind`
 */
const PERMISSIONS_MAPPING = {
    camera: 'videoinput',
    microphone: 'audioinput',
    speaker: 'audiooutput',
};
export const _getMediaDeviceKindByName = (name) => {
    if (!name) {
        return undefined;
    }
    return PERMISSIONS_MAPPING[name];
};
//# sourceMappingURL=primitives.js.map