import { getLogger, sagaEffects, componentActions, Rooms, } from '@signalwire/core';
export const roomSubscribedWorker = function* (options) {
    getLogger().debug('roomSubscribedWorker started');
    const { channels, instance, initialState } = options;
    const { swEventChannel } = channels;
    const { rtcPeerId } = initialState;
    if (!rtcPeerId) {
        throw new Error('Missing rtcPeerId for roomSubscribedWorker');
    }
    const action = yield sagaEffects.take(swEventChannel, (action) => {
        if (action.type === 'video.room.subscribed') {
            return action.payload.call_id === rtcPeerId;
        }
        return false;
    });
    // New emitter should not change the payload by reference
    const clonedPayload = JSON.parse(JSON.stringify(action.payload));
    /**
     * In here we joined a room_session so we can swap between RTCPeers
     */
    instance.setActiveRTCPeer(rtcPeerId);
    /**
     * TODO: Replace the redux action/component with properties on RTCPeer instance?
     */
    yield sagaEffects.put(componentActions.upsert({
        id: action.payload.call_id,
        roomId: action.payload.room_session.room_id,
        roomSessionId: action.payload.room_session.id,
        memberId: action.payload.member_id,
        previewUrl: action.payload.room_session.preview_url,
    }));
    instance.emit('room.joined', transformPayload.call(instance, clonedPayload));
    getLogger().debug('roomSubscribedWorker ended', rtcPeerId);
};
function transformPayload(payload) {
    const keys = ['room_session', 'room'];
    keys.forEach((key) => {
        if (payload[key].recordings) {
            payload[key].recordings = (payload[key].recordings || []).map((recording) => {
                let recordingInstance = this.instanceMap.get(recording.id);
                if (!recordingInstance) {
                    recordingInstance = Rooms.createRoomSessionRecordingObject({
                        store: this.store,
                        payload: {
                            room_id: payload.room.room_id,
                            room_session_id: payload.room_session.id,
                            recording,
                        },
                    });
                }
                else {
                    recordingInstance.setPayload({
                        room_id: payload.room.room_id,
                        room_session_id: payload.room_session.id,
                        recording,
                    });
                }
                this.instanceMap.set(recording.id, recordingInstance);
                return recordingInstance;
            });
        }
        if (payload[key].playbacks) {
            payload[key].playbacks = (payload[key].playbacks || []).map((playback) => {
                let playbackInstance = this.instanceMap.get(playback.id);
                if (!playbackInstance) {
                    playbackInstance = Rooms.createRoomSessionPlaybackObject({
                        store: this.store,
                        payload: {
                            room_id: payload.room.room_id,
                            room_session_id: payload.room_session.id,
                            playback,
                        },
                    });
                }
                else {
                    playbackInstance.setPayload({
                        room_id: payload.room.room_id,
                        room_session_id: payload.room_session.id,
                        playback,
                    });
                }
                this.instanceMap.set(playback.id, playbackInstance);
                return playbackInstance;
            });
        }
        if (payload[key].streams) {
            payload[key].streams = (payload[key].streams || []).map((stream) => {
                let streamInstance = this.instanceMap.get(stream.id);
                if (!streamInstance) {
                    streamInstance = Rooms.createRoomSessionStreamObject({
                        store: this.store,
                        payload: {
                            room_id: payload.room.room_id,
                            room_session_id: payload.room_session.id,
                            stream,
                        },
                    });
                }
                else {
                    streamInstance.setPayload({
                        room_id: payload.room.room_id,
                        room_session_id: payload.room_session.id,
                        stream,
                    });
                }
                this.instanceMap.set(stream.id, streamInstance);
                return streamInstance;
            });
        }
    });
    return payload;
}
//# sourceMappingURL=roomSubscribedWorker.js.map