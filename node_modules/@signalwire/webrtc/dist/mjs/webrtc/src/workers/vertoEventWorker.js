import { __rest } from "tslib";
import { getLogger, sagaEffects, VertoResult, VertoPong, isWebrtcEventType, sagaHelpers, componentActions, } from '@signalwire/core';
const isWebrtcAction = (action) => {
    return isWebrtcEventType(action.type);
};
export const vertoEventWorker = function* (options) {
    getLogger().debug('vertoEventWorker started');
    const { channels, instance, initialState } = options;
    const { swEventChannel } = channels;
    const { rtcPeerId } = initialState;
    if (!rtcPeerId) {
        throw new Error('Missing rtcPeerId for roomSubscribedWorker');
    }
    const worker = function* (action) {
        var _a, _b;
        const { id: jsonrpcId, method, params = {} } = action.payload;
        const { callID, nodeId } = params;
        const peer = instance.getRTCPeerById(callID);
        if (!peer) {
            getLogger().warn(`RTCPeer '${callID}' not found for method: '${method}'`, params);
            return;
        }
        const activeRTCPeer = instance.peer;
        // getLogger().warn('vertoEventWorker', method, params)
        switch (method) {
            case 'verto.media':
            case 'verto.answer': {
                /**
                 * verto.media and verto.answer share the same logic
                 *
                 * Always invoke peer.onRemoteSdp(params.sdp) on the proper RTCPeer
                 * If the `params.callID` is the current ACTIVE peer, set the BaseConnection state to 'early' | 'active'
                 * If the `params.callID` is NOT the current peer just setup the media (ie: promote/demote)
                 */
                if (peer.uuid === (activeRTCPeer === null || activeRTCPeer === void 0 ? void 0 : activeRTCPeer.uuid)) {
                    const state = method === 'verto.media' ? 'early' : 'active';
                    instance.setState(state);
                }
                if (params === null || params === void 0 ? void 0 : params.sdp) {
                    peer.onRemoteSdp(params.sdp);
                }
                yield sagaEffects.put(componentActions.upsert({
                    id: (_a = action.payload.params) === null || _a === void 0 ? void 0 : _a.callID,
                    nodeId: (_b = action.payload.params) === null || _b === void 0 ? void 0 : _b.nodeId,
                }));
                yield sagaEffects.call([instance, instance.execute], {
                    method: instance._getRPCMethod(),
                    params: {
                        message: VertoResult(jsonrpcId, method),
                        node_id: nodeId,
                    },
                });
                break;
            }
            case 'verto.bye': {
                /**
                 * If the `params.callID` is the current ACTIVE peer, stop everything and destroy the BaseConnection
                 * If the `params.callID` is NOT the current peer, but is there from promote/demote process stop/destroy just the peer
                 */
                yield sagaEffects.call([instance, instance.onVertoBye], {
                    rtcPeerId: callID,
                    byeCause: params === null || params === void 0 ? void 0 : params.cause,
                    byeCauseCode: params === null || params === void 0 ? void 0 : params.causeCode,
                    redirectDestination: params === null || params === void 0 ? void 0 : params.redirectDestination,
                });
                yield sagaEffects.call([instance, instance.execute], {
                    method: instance._getRPCMethod(),
                    params: {
                        message: VertoResult(jsonrpcId, method),
                        node_id: nodeId,
                    },
                });
                break;
            }
            case 'verto.ping': {
                // Remove nodeId from params
                const { nodeId } = params, pongParams = __rest(params, ["nodeId"]);
                yield sagaEffects.call([instance, instance.execute], {
                    method: instance._getRPCMethod(),
                    params: {
                        message: VertoPong(pongParams),
                        node_id: nodeId,
                    },
                });
                break;
            }
            case 'verto.mediaParams': {
                if (!callID || !params.mediaParams) {
                    getLogger().warn(`Invalid mediaParams event`, params);
                    break;
                }
                const { audio, video } = params.mediaParams;
                if (peer && video) {
                    peer.applyMediaConstraints('video', video);
                }
                if (peer && audio) {
                    peer.applyMediaConstraints('audio', audio);
                }
                break;
            }
            case 'verto.display': {
                /** Call is active so set the RTCPeer */
                instance.setActiveRTCPeer(rtcPeerId);
                instance.emit('verto.display', action.payload.params);
                break;
            }
            default:
                return getLogger().warn(`Unknown Verto method: ${method}`, params);
        }
    };
    const catchableWorker = sagaHelpers.createCatchableSaga(worker, (error) => {
        getLogger().error('Verto Error', error);
    });
    while (true) {
        const action = yield sagaEffects.take(swEventChannel, (action) => {
            var _a;
            if (isWebrtcAction(action)) {
                return ((_a = action.payload.params) === null || _a === void 0 ? void 0 : _a.callID) === rtcPeerId;
            }
            return false;
        });
        yield sagaEffects.fork(catchableWorker, action);
    }
    getLogger().trace('vertoEventWorker ended');
};
//# sourceMappingURL=vertoEventWorker.js.map