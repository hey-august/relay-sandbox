import { __rest } from "tslib";
import { createRoomSessionPlaybackObject, createRoomSessionRecordingObject, createRoomSessionStreamObject, } from '.';
/**
 * Transform for returning `undefined` for `execute`s that were
 * successully resolved. If the `execute` failed for some reason, then
 * the promise will be rejected and this transform will never be
 * executed.
 */
const baseCodeTransform = () => { };
const createRoomMethod = (method, options = {}) => ({
    value: function (params = {}) {
        return this.execute({
            method,
            params: Object.assign({ room_session_id: this.roomSessionId }, params),
        }, options);
    },
});
const createRoomMemberMethod = (method, options = {}) => ({
    value: function (_a = {}) {
        var { memberId } = _a, rest = __rest(_a, ["memberId"]);
        return this.execute({
            method,
            params: Object.assign({ room_session_id: this.roomSessionId, member_id: memberId || this.memberId }, rest),
        }, options);
    },
});
/**
 * Room Methods
 */
export const getLayouts = createRoomMethod('video.list_available_layouts', {
    transformResolve: (payload) => ({ layouts: payload.layouts }),
});
export const getMembers = createRoomMethod('video.members.get', {
    transformResolve: (payload) => ({ members: payload.members }),
});
export const setLayout = createRoomMethod('video.set_layout', {
    transformResolve: baseCodeTransform,
});
export const setPositions = createRoomMethod('video.set_position', {
    transformResolve: baseCodeTransform,
});
export const hideVideoMuted = createRoomMethod('video.hide_video_muted', {
    transformResolve: baseCodeTransform,
});
export const showVideoMuted = createRoomMethod('video.show_video_muted', {
    transformResolve: baseCodeTransform,
});
export const lock = createRoomMethod('video.lock', {
    transformResolve: baseCodeTransform,
});
export const unlock = createRoomMethod('video.unlock', {
    transformResolve: baseCodeTransform,
});
export const setHideVideoMuted = {
    value: function (value) {
        return this.execute({
            method: value ? 'video.hide_video_muted' : 'video.show_video_muted',
            params: {
                room_session_id: this.roomSessionId,
            },
        }, {
            transformResolve: baseCodeTransform,
        });
    },
};
export const getRecordings = {
    value: function () {
        return new Promise(async (resolve, reject) => {
            try {
                const { recordings } = await this.execute({
                    method: 'video.recording.list',
                    params: {
                        room_session_id: this.roomSessionId,
                    },
                });
                const recordingInstances = [];
                recordings.forEach((recording) => {
                    let recordingInstance = this.instanceMap.get(recording.id);
                    if (!recordingInstance) {
                        recordingInstance = createRoomSessionRecordingObject({
                            store: this.store,
                            payload: {
                                room_id: this.roomId,
                                room_session_id: this.roomSessionId,
                                recording,
                            },
                        });
                    }
                    else {
                        recordingInstance.setPayload({
                            room_id: this.roomId,
                            room_session_id: this.roomSessionId,
                            recording,
                        });
                    }
                    recordingInstances.push(recordingInstance);
                    this.instanceMap.set(recordingInstance.id, recordingInstance);
                });
                resolve({ recordings: recordingInstances });
            }
            catch (error) {
                reject(error);
            }
        });
    },
};
export const startRecording = {
    value: function () {
        return new Promise(async (resolve, reject) => {
            try {
                const { recording } = await this.execute({
                    method: 'video.recording.start',
                    params: {
                        room_session_id: this.roomSessionId,
                    },
                });
                const recordingInstance = createRoomSessionRecordingObject({
                    store: this.store,
                    payload: {
                        room_id: this.roomId,
                        room_session_id: this.roomSessionId,
                        recording,
                    },
                });
                this.instanceMap.set(recordingInstance.id, recordingInstance);
                resolve(recordingInstance);
            }
            catch (error) {
                reject(error);
            }
        });
    },
};
export const getPlaybacks = {
    value: function () {
        return new Promise(async (resolve, reject) => {
            try {
                const { playbacks } = await this.execute({
                    method: 'video.playback.list',
                    params: {
                        room_session_id: this.roomSessionId,
                    },
                });
                const playbackInstances = [];
                playbacks.forEach((playback) => {
                    let playbackInstance = this.instanceMap.get(playback.id);
                    if (!playbackInstance) {
                        playbackInstance = createRoomSessionPlaybackObject({
                            store: this.store,
                            payload: {
                                room_id: this.roomId,
                                room_session_id: this.roomSessionId,
                                playback,
                            },
                        });
                    }
                    else {
                        playbackInstance.setPayload({
                            room_id: this.roomId,
                            room_session_id: this.roomSessionId,
                            playback,
                        });
                    }
                    playbackInstances.push(playbackInstance);
                    this.instanceMap.set(playbackInstance.id, playbackInstance);
                });
                resolve({ playbacks: playbackInstances });
            }
            catch (error) {
                reject(error);
            }
        });
    },
};
export const play = {
    value: function (_a) {
        var { seekPosition, currentTimecode } = _a, params = __rest(_a, ["seekPosition", "currentTimecode"]);
        return new Promise(async (resolve, reject) => {
            try {
                const seek_position = seekPosition || currentTimecode;
                const { playback } = await this.execute({
                    method: 'video.playback.start',
                    params: Object.assign({ room_session_id: this.roomSessionId, seek_position }, params),
                });
                const playbackInstance = createRoomSessionPlaybackObject({
                    store: this.store,
                    payload: {
                        room_id: this.roomId,
                        room_session_id: this.roomSessionId,
                        playback,
                    },
                });
                this.instanceMap.set(playbackInstance.id, playbackInstance);
                resolve(playbackInstance);
            }
            catch (error) {
                reject(error);
            }
        });
    },
};
const createRoomMetaMethod = (method) => {
    return createRoomMethod(method, {
        transformResolve: baseCodeTransform,
        transformParams: (params) => {
            const { room_session_id } = params, meta = __rest(params, ["room_session_id"]);
            return { room_session_id, meta };
        },
    });
};
export const getMeta = createRoomMethod('video.get_meta', {
    transformResolve: ({ meta }) => ({ meta }),
});
export const setMeta = createRoomMetaMethod('video.set_meta');
export const updateMeta = createRoomMetaMethod('video.update_meta');
export const deleteMeta = {
    value: function (params) {
        return this.execute({
            method: 'video.delete_meta',
            params: {
                room_session_id: this.roomSessionId,
                keys: params,
            },
        });
    },
};
export const getStreams = {
    value: function () {
        return new Promise(async (resolve, reject) => {
            try {
                const { streams } = await this.execute({
                    method: 'video.stream.list',
                    params: {
                        room_session_id: this.roomSessionId,
                    },
                });
                const streamInstances = [];
                streams.forEach((stream) => {
                    let streamInstance = this.instanceMap.get(stream.id);
                    if (!streamInstance) {
                        streamInstance = createRoomSessionStreamObject({
                            store: this.store,
                            payload: {
                                room_id: this.roomId,
                                room_session_id: this.roomSessionId,
                                stream,
                            },
                        });
                    }
                    else {
                        streamInstance.setPayload({
                            room_id: this.roomId,
                            room_session_id: this.roomSessionId,
                            stream,
                        });
                    }
                    streamInstances.push(streamInstance);
                    this.instanceMap.set(streamInstance.id, streamInstance);
                });
                resolve({ streams: streamInstances });
            }
            catch (error) {
                reject(error);
            }
        });
    },
};
export const startStream = {
    value: function (params) {
        return new Promise(async (resolve, reject) => {
            try {
                const { stream } = await this.execute({
                    method: 'video.stream.start',
                    params: Object.assign({ room_session_id: this.roomSessionId }, params),
                });
                const streamInstance = createRoomSessionStreamObject({
                    store: this.store,
                    payload: {
                        room_id: this.roomId,
                        room_session_id: this.roomSessionId,
                        stream,
                    },
                });
                this.instanceMap.set(streamInstance.id, streamInstance);
                resolve({ stream: streamInstance });
            }
            catch (error) {
                reject(error);
            }
        });
    },
};
export const setPrioritizeHandraise = {
    value: function (params) {
        return this.execute({
            method: 'video.prioritize_handraise',
            params: {
                room_session_id: this.roomSessionId,
                enable: params,
            },
        });
    },
};
// End Room Methods
/**
 * Room Member Methods
 */
export const audioMuteMember = createRoomMemberMethod('video.member.audio_mute', {
    transformResolve: baseCodeTransform,
});
export const audioUnmuteMember = createRoomMemberMethod('video.member.audio_unmute', {
    transformResolve: baseCodeTransform,
});
export const videoMuteMember = createRoomMemberMethod('video.member.video_mute', {
    transformResolve: baseCodeTransform,
});
export const videoUnmuteMember = createRoomMemberMethod('video.member.video_unmute', {
    transformResolve: baseCodeTransform,
});
export const deafMember = createRoomMemberMethod('video.member.deaf', {
    transformResolve: baseCodeTransform,
});
export const undeafMember = createRoomMemberMethod('video.member.undeaf', {
    transformResolve: baseCodeTransform,
});
// This is used on a RoomSessionMember instance where we have
// `this.roomSessionId` and `this.memberId`
export const setDeaf = {
    value: function (value) {
        return this.execute({
            method: value ? 'video.member.deaf' : 'video.member.undeaf',
            params: {
                room_session_id: this.roomSessionId,
                member_id: this.memberId,
            },
        }, {
            transformResolve: baseCodeTransform,
        });
    },
};
export const setInputVolumeMember = createRoomMemberMethod('video.member.set_input_volume', {
    transformResolve: baseCodeTransform,
});
export const setOutputVolumeMember = createRoomMemberMethod('video.member.set_output_volume', {
    transformResolve: baseCodeTransform,
});
export const setInputSensitivityMember = createRoomMemberMethod('video.member.set_input_sensitivity', {
    transformResolve: baseCodeTransform,
});
export const promote = {
    value: function (_a) {
        var { memberId, mediaAllowed, joinAudioMuted, joinVideoMuted } = _a, rest = __rest(_a, ["memberId", "mediaAllowed", "joinAudioMuted", "joinVideoMuted"]);
        return this.execute({
            method: 'video.member.promote',
            params: Object.assign({ room_session_id: this.roomSessionId, member_id: memberId, media_allowed: mediaAllowed, join_audio_muted: joinAudioMuted, join_video_muted: joinVideoMuted }, rest),
        }, {
            transformResolve: baseCodeTransform,
        });
    },
};
export const demote = {
    value: function ({ memberId, mediaAllowed }) {
        return this.execute({
            method: 'video.member.demote',
            params: {
                room_session_id: this.roomSessionId,
                member_id: memberId,
                media_allowed: mediaAllowed,
            },
        }, {
            transformResolve: baseCodeTransform,
        });
    },
};
export const setMemberPosition = createRoomMemberMethod('video.member.set_position', {
    transformResolve: baseCodeTransform,
});
export const removeMember = {
    value: function (_a) {
        var { memberId } = _a, rest = __rest(_a, ["memberId"]);
        if (!memberId) {
            throw new TypeError('Invalid or missing "memberId" argument');
        }
        return this.execute({
            method: 'video.member.remove',
            params: Object.assign({ room_session_id: this.roomSessionId, member_id: memberId }, rest),
        }, {
            transformResolve: baseCodeTransform,
        });
    },
};
export const removeAllMembers = {
    value: function () {
        return this.execute({
            method: 'video.member.remove',
            params: {
                room_session_id: this.roomSessionId,
                member_id: 'all',
            },
        }, {
            transformResolve: baseCodeTransform,
        });
    },
};
export const getMemberMeta = createRoomMemberMethod('video.member.get_meta', {
    transformResolve: ({ meta }) => ({ meta }),
});
export const setMemberMeta = createRoomMemberMethod('video.member.set_meta', {
    transformResolve: baseCodeTransform,
});
export const updateMemberMeta = createRoomMemberMethod('video.member.update_meta', {
    transformResolve: baseCodeTransform,
});
export const deleteMemberMeta = createRoomMemberMethod('video.member.delete_meta', {
    transformResolve: baseCodeTransform,
});
export const setRaisedHand = {
    value: function (value) {
        const { raised = true, memberId = this.memberId } = value || {};
        if (!memberId) {
            throw new TypeError('Invalid or missing "memberId" argument');
        }
        return this.execute({
            method: raised ? 'video.member.raisehand' : 'video.member.lowerhand',
            params: {
                room_session_id: this.roomSessionId,
                member_id: memberId,
            },
        }, {
            transformResolve: baseCodeTransform,
        });
    },
};
// End Room Member Methods
//# sourceMappingURL=methods.js.map