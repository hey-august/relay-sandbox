import { __rest } from "tslib";
import { uuid, validateEventsToSubscribe, getLogger } from './utils';
import { EventEmitter } from './utils/EventEmitter';
import { makeCustomSagaAction } from './redux/actions';
import { getAuthError, getAuthState, getAuthStatus, } from './redux/features/session/sessionSelectors';
import { AuthError } from './CustomErrors';
import { executeActionWorker } from './workers';
const identity = (payload) => payload;
export const SW_SYMBOL = Symbol('BaseComponent');
export class BaseComponent {
    constructor(options) {
        this.options = options;
        /** @internal */
        this.__sw_symbol = SW_SYMBOL;
        /** @internal */
        this.uuid = uuid();
        this._customSagaTriggers = new Map();
        /**
         * List of running Tasks to be cancelled on `destroy`.
         */
        this._runningWorkers = [];
        /**
         * Map of Sagas that will be attached to the Store to
         * handle events or perform side-effects. This Map will
         * behave as a queue and will be emptied once the workers
         * have been attached. See `this.attachWorkers` for
         * details.
         */
        this._workers = new Map();
        this.eventEmitter = new EventEmitter();
    }
    /** @internal */
    get __uuid() {
        return this.uuid;
    }
    get logger() {
        return getLogger();
    }
    /** @internal */
    set destroyer(d) {
        this._destroyer = d;
    }
    /** @internal */
    get store() {
        return this.options.store;
    }
    /** @internal */
    get instanceMap() {
        return this.options.store.instanceMap;
    }
    /** @internal */
    get emitter() {
        return this.eventEmitter;
    }
    /** @internal */
    get sessionEmitter() {
        return this.options.store.sessionEmitter;
    }
    /** @internal */
    get session() {
        return this.sessionEmitter;
    }
    on(event, fn) {
        return this.emitter.on(event, fn);
    }
    once(event, fn) {
        return this.emitter.once(event, fn);
    }
    off(event, fn) {
        return this.emitter.off(event, fn);
    }
    removeAllListeners(event) {
        if (event) {
            return this.off(event);
        }
        this.eventNames().forEach((eventName) => {
            this.off(eventName);
        });
        this.sessionEventNames().forEach((eventName) => {
            this.sessionEmitter.off(eventName);
        });
        return this.emitter;
    }
    /** @internal */
    eventNames() {
        return this.emitter.eventNames();
    }
    /** @internal */
    sessionEventNames() {
        return this.sessionEmitter.eventNames();
    }
    getSubscriptions() {
        return validateEventsToSubscribe(this.eventNames());
    }
    /** @internal */
    emit(event, ...args) {
        // @ts-ignore
        return this.emitter.emit(event, ...args);
    }
    /** @internal */
    listenerCount(event) {
        return this.emitter.listenerCount(event);
    }
    destroy() {
        var _a;
        (_a = this._destroyer) === null || _a === void 0 ? void 0 : _a.call(this);
        this.removeAllListeners();
        this.detachWorkers();
    }
    /** @internal */
    execute({ method, params }, { transformParams = identity, transformResolve = identity, transformReject = identity, } = {
        transformParams: identity,
        transformResolve: identity,
        transformReject: identity,
    }) {
        return new Promise((resolve, reject) => {
            const requestId = uuid();
            this.runWorker('executeActionWorker', {
                worker: executeActionWorker,
                onDone: (data) => resolve(transformResolve(data)),
                onFail: (error) => reject(transformReject(error)),
                initialState: {
                    requestId,
                    componentId: this.__uuid,
                    method,
                    params: transformParams(params),
                },
            });
        });
    }
    /** @internal */
    triggerCustomSaga(action) {
        return new Promise((resolve, reject) => {
            const dispatchId = uuid();
            this._customSagaTriggers.set(dispatchId, { resolve, reject });
            this.store.dispatch(Object.assign({ dispatchId }, makeCustomSagaAction(this.__uuid, action)));
        });
    }
    /** @internal */
    settleCustomSagaTrigger({ dispatchId, payload, kind, }) {
        const actions = this._customSagaTriggers.get(dispatchId);
        if (actions) {
            actions[kind](payload);
            this._customSagaTriggers.delete(dispatchId);
        }
    }
    /** @internal */
    select(selectorFn) {
        return selectorFn(this.store.getState());
    }
    /** @internal */
    getStateProperty(param) {
        // @ts-expect-error
        return this[param];
    }
    /** @internal */
    get _sessionAuthStatus() {
        return getAuthStatus(this.store.getState());
    }
    /** @internal */
    get _sessionAuthState() {
        return getAuthState(this.store.getState());
    }
    /** @internal */
    _waitUntilSessionAuthorized() {
        const authStatus = getAuthStatus(this.store.getState());
        switch (authStatus) {
            case 'authorized':
                return Promise.resolve(this);
            /**
             * `unknown` is the initial state of the auth reducer
             * so if we've got this far it means it's the first
             * time the user is calling `connect`.
             */
            case 'unknown':
            /**
             * `authorizing` means that the user is calling
             * `connect` again while we're in the process of
             * authorizing the session.
             */
            case 'authorizing':
                return new Promise((resolve, reject) => {
                    const unsubscribe = this.store.subscribe(() => {
                        const authStatus = getAuthStatus(this.store.getState());
                        const authError = getAuthError(this.store.getState());
                        if (authStatus === 'authorized') {
                            resolve(this);
                            unsubscribe();
                        }
                        else if (authStatus === 'unauthorized') {
                            const error = authError
                                ? new AuthError(authError.code, authError.message)
                                : new Error('Unauthorized');
                            reject(error);
                            unsubscribe();
                        }
                    });
                });
            case 'unauthorized':
                return Promise.reject(new Error('Unauthorized'));
        }
    }
    /** @internal */
    runWorker(name, def) {
        if (this._workers.has(name)) {
            getLogger().warn(`[runWorker] Worker with name ${name} has already been registerd.`);
        }
        else {
            this._setWorker(name, def);
        }
        return this._attachWorker(name, def);
    }
    _setWorker(name, def) {
        this._workers.set(name, def);
    }
    _attachWorker(name, _a) {
        var { worker } = _a, params = __rest(_a, ["worker"]);
        const task = this.store.runSaga(worker, Object.assign({ instance: this, runSaga: this.store.runSaga }, params));
        this._runningWorkers.push(task);
        /**
         * Attaching workers is a one-time op for instances so
         * the moment we attach one we'll remove it from the
         * queue.
         */
        this._workers.delete(name);
        return task;
    }
    detachWorkers() {
        this._runningWorkers.forEach((task) => {
            task.cancel();
        });
        this._runningWorkers = [];
    }
}
//# sourceMappingURL=BaseComponent.js.map