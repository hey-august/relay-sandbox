import { connect, actions, validateEventsToSubscribe, BaseConsumer, } from '..';
import { getAuthState } from '../redux/features/session/sessionSelectors';
import { PRODUCT_PREFIX_PUBSUB } from '../utils/constants';
import { pubSubWorker } from './workers/pubSubWorker';
const toInternalPubSubChannels = (channels) => {
    return channels.map((name) => {
        return {
            name,
        };
    });
};
export class BasePubSubConsumer extends BaseConsumer {
    constructor(options) {
        super(options);
        this.subscribeMethod = `${PRODUCT_PREFIX_PUBSUB}.subscribe`;
        // Initialize worker through a function so that it can be override by the BaseChatConsumer
        this.initWorker();
    }
    initWorker() {
        this.runWorker('pubSub', { worker: pubSubWorker });
    }
    _getChannelsParam(channels, method) {
        const _channels = !channels || Array.isArray(channels) ? channels : [channels];
        if (!Array.isArray(_channels) || _channels.length === 0) {
            throw new Error(`Please specify one or more channels when calling .${method}()`);
        }
        return {
            channels: toInternalPubSubChannels(_channels),
        };
    }
    /** @internal */
    _setSubscribeParams(params) {
        this.subscribeParams = Object.assign(Object.assign({}, this.subscribeParams), params);
    }
    /** @internal */
    _getSubscribeParams({ channels }) {
        return Object.assign({}, this._getChannelsParam(channels, 'subscribe'));
    }
    /** @internal */
    _getUnsubscribeParams({ channels }) {
        const channelsParam = this._getChannelsParam(channels, 'unsubscribe');
        return Object.assign({}, channelsParam);
    }
    _checkMissingSubscriptions() {
        const subscriptions = this.getSubscriptions();
        if (subscriptions.length === 0) {
            this.logger.info('Subscribe was called before any listeners were attached. Move `.subscribe()` right after your event listeners to suppress this message.');
            // @ts-ignore
            this.once('message', () => { });
        }
    }
    /** @internal */
    getSubscriptions() {
        const eventNamesWithPrefix = this.eventNames().map((event) => `${PRODUCT_PREFIX_PUBSUB}.${String(event)}`);
        return validateEventsToSubscribe(eventNamesWithPrefix);
    }
    async subscribe(channels) {
        this._checkMissingSubscriptions();
        const params = this._getSubscribeParams({ channels });
        this._setSubscribeParams(params);
        return super.subscribe();
    }
    async unsubscribe(channels) {
        if (this._sessionAuthStatus === 'unknown' ||
            this._sessionAuthStatus === 'unauthorized') {
            throw new Error('You must be authenticated to unsubscribe from a channel');
        }
        const params = this._getUnsubscribeParams({ channels });
        return new Promise(async (resolve, reject) => {
            const subscriptions = this.getSubscriptions();
            if (subscriptions.length > 0) {
                const execParams = {
                    method: `${PRODUCT_PREFIX_PUBSUB}.unsubscribe`,
                    params: Object.assign(Object.assign({}, params), { events: subscriptions }),
                };
                try {
                    await this.execute(execParams);
                }
                catch (error) {
                    return reject(error);
                }
            }
            else {
                this.logger.warn('`unsubscribe()` was called without any listeners attached.');
            }
            return resolve();
        });
    }
    // Currently only `js` supports this features and it's
    // being ignored (filtered at the Proxy level) within
    // `realtime-api`
    updateToken(token) {
        return new Promise((resolve, reject) => {
            this.session.once('session.auth_error', (error) => {
                reject(error);
            });
            this.session.once('session.connected', () => {
                resolve();
            });
            this.store.dispatch(actions.reauthAction({ token }));
        });
    }
    publish(params) {
        return this.execute({
            method: `${PRODUCT_PREFIX_PUBSUB}.publish`,
            params,
        });
    }
    // Currently only `js` supports this features and it's
    // being ignored (filtered at the Proxy level) within
    // `realtime-api`
    async getAllowedChannels() {
        await this._waitUntilSessionAuthorized();
        const authState = this.select(getAuthState);
        if (authState && 'channels' in authState && authState.channels) {
            return authState.channels;
        }
        return {};
    }
}
export const createBasePubSubObject = (params) => {
    const pubSub = connect({
        store: params.store,
        Component: BasePubSubConsumer,
    })(params);
    return pubSub;
};
//# sourceMappingURL=BasePubSub.js.map