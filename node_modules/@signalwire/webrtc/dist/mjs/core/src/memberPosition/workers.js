import { fork } from '@redux-saga/core/effects';
import { sagaEffects, stripNamespacePrefix, } from '..';
/**
 * These workers are shared between the realtime-api and the browser SDK
 * For the realtime-api: we pass the dispatcher function since we emit RoomSessionMember instance
 * For the browser SDK: we use the default dispatcher function since we emit whatever we get from the server
 */
const defaultDispatcher = function* (type, payload, instance) {
    instance.emit(type, payload);
};
function* memberPositionLayoutChangedWorker(options) {
    const { action, memberList, instance, dispatcher = defaultDispatcher, } = options;
    const layers = action.payload.layout.layers;
    const processedMembers = {};
    layers.forEach((layer) => {
        var _a;
        const memberId = layer.member_id;
        if (!memberId) {
            return;
        }
        const memberEventParams = memberList.get(memberId);
        if (memberEventParams &&
            layer.position !== ((_a = memberEventParams.member) === null || _a === void 0 ? void 0 : _a.current_position)) {
            mutateMemberCurrentPosition({
                memberList,
                memberId,
                currentPosition: layer.position,
            });
            processedMembers[memberId] = true;
        }
        else {
            // Values marked as false won't be put to `pubSubChannel`
            processedMembers[memberId] = false;
        }
    });
    for (const [memberId, payload] of memberList) {
        if (processedMembers[memberId]) {
            yield dispatcher === null || dispatcher === void 0 ? void 0 : dispatcher('member.updated', payload, instance);
            /**
             * `undefined` means that we couldn't find the
             * `memberId` inside the `layout.layers` array, which
             * implies that the user should now be off-canvas
             */
        }
        else if (processedMembers[memberId] === undefined) {
            const updatedMemberEventParams = mutateMemberCurrentPosition({
                memberList,
                memberId,
                currentPosition: 'off-canvas',
            });
            if (!updatedMemberEventParams) {
                return;
            }
            yield dispatcher === null || dispatcher === void 0 ? void 0 : dispatcher('member.updated', updatedMemberEventParams, instance);
        }
    }
}
export function* memberUpdatedWorker({ action, memberList, instance, dispatcher = defaultDispatcher, }) {
    var _a, _b;
    const memberId = action.payload.member.id;
    const updatedMemberEventParams = mutateMemberCurrentPosition({
        memberList,
        memberId,
        currentPosition: (_b = (_a = memberList.get(memberId)) === null || _a === void 0 ? void 0 : _a.member) === null || _b === void 0 ? void 0 : _b.current_position,
    });
    if (!updatedMemberEventParams) {
        return;
    }
    const { member: { updated = [] }, } = action.payload;
    const memberUpdatedPayload = Object.assign(Object.assign({}, updatedMemberEventParams), { member: Object.assign(Object.assign({}, updatedMemberEventParams.member), action.payload.member) });
    /** member.updated event is the only one updating the memberList payload */
    memberList.set(memberId, memberUpdatedPayload);
    const event = stripNamespacePrefix(action.type);
    for (const key of updated) {
        const type = `${event}.${key}`;
        yield dispatcher === null || dispatcher === void 0 ? void 0 : dispatcher(type, memberUpdatedPayload, instance);
    }
    yield dispatcher === null || dispatcher === void 0 ? void 0 : dispatcher(event, memberUpdatedPayload, instance);
}
export const MEMBER_POSITION_COMPOUND_EVENTS = new Map([
    [
        'video.member.updated',
        [
            'video.layout.changed',
            // `member.joined` and `member.left` are needed to
            // keep the member list up to date
            'video.member.joined',
            'video.member.left',
        ],
    ],
]);
export const memberPositionWorker = function* memberPositionWorker({ instance, channels, initialState, getSession, instanceMap, dispatcher = defaultDispatcher, }) {
    if (!initialState) {
        return;
    }
    const { swEventChannel } = channels;
    let memberList = initializeMemberList(initialState);
    const addToMemberList = (payload) => {
        /**
         * Add to memberList for both `member.joined` and `member.updated`
         * note: changes made for audience users.
         */
        if (!memberList.has(payload.member.id)) {
            memberList.set(payload.member.id, payload);
        }
    };
    while (true) {
        const action = yield sagaEffects.take(swEventChannel, (action) => {
            const istargetEvent = action.type === 'video.member.updated' ||
                action.type === 'video.layout.changed' ||
                action.type === 'video.member.joined' ||
                action.type === 'video.member.left';
            return istargetEvent;
        });
        switch (action.type) {
            case 'video.member.updated': {
                addToMemberList(action.payload);
                yield fork(memberUpdatedWorker, {
                    action,
                    channels,
                    memberList,
                    instance,
                    getSession,
                    instanceMap,
                    dispatcher,
                });
                break;
            }
            case 'video.member.joined': {
                addToMemberList(action.payload);
                break;
            }
            case 'video.member.left': {
                const member = action.payload.member;
                memberList.delete(member.id);
                break;
            }
            case 'video.layout.changed': {
                yield fork(memberPositionLayoutChangedWorker, {
                    action,
                    channels,
                    memberList,
                    instance,
                    dispatcher,
                });
                break;
            }
        }
    }
};
const mutateMemberCurrentPosition = ({ memberList, memberId, currentPosition, }) => {
    const memberEventParams = memberList.get(memberId);
    if (!memberEventParams) {
        return;
        // This is to avoid setting an undefined property
    }
    else if (!currentPosition) {
        return memberEventParams;
    }
    const updatedMemberEventParams = Object.assign(Object.assign({}, memberEventParams), { member: Object.assign(Object.assign({}, memberEventParams === null || memberEventParams === void 0 ? void 0 : memberEventParams.member), { current_position: currentPosition }) });
    memberList.set(memberId, updatedMemberEventParams);
    return updatedMemberEventParams;
};
const initializeMemberList = (payload) => {
    const members = payload.room_session.members;
    const memberList = new Map();
    members.forEach((member) => {
        memberList.set(member.id, {
            room_id: payload.room_session.room_id,
            room_session_id: payload.room_session.id,
            // At this point we don't have `member.updated`
            // @ts-expect-error
            member,
        });
    });
    return memberList;
};
//# sourceMappingURL=workers.js.map