import { put, take, fork } from '@redux-saga/core/effects';
import { createCatchableSaga } from '../../utils/sagaHelpers';
import { socketMessageAction } from '../../actions';
import { getLogger, isWebrtcEventType, toInternalAction } from '../../../utils';
// TODO: Move TypeGuards to its own module
const isWebrtcEvent = (e) => {
    return isWebrtcEventType(e === null || e === void 0 ? void 0 : e.event_type);
};
const isVideoEvent = (e) => {
    var _a;
    return !!((_a = e === null || e === void 0 ? void 0 : e.event_type) === null || _a === void 0 ? void 0 : _a.startsWith('video.'));
};
const isSwAuthorizationState = (e) => {
    return (e === null || e === void 0 ? void 0 : e.event_type) === 'signalwire.authorization.state';
};
export function* sessionChannelWatcher({ sessionChannel, swEventChannel, session, }) {
    function* swEventWorker(broadcastParams) {
        yield put(swEventChannel, toInternalAction(broadcastParams));
        if (isWebrtcEvent(broadcastParams) || isVideoEvent(broadcastParams)) {
            /**
             * Skip `webrtc.*` & `video.*` events.
             * There are custom workers handling them through `swEventChannel`
             */
            return;
        }
        if (isSwAuthorizationState(broadcastParams)) {
            session.onSwAuthorizationState(broadcastParams.params.authorization_state);
            return;
        }
        /**
         * Put actions with `event_type` to trigger all the children sagas
         * This should replace all the isWebrtcEvent/isVideoEvent guards below
         * since we'll move that logic on a separate package.
         */
        yield put({ type: broadcastParams.event_type, payload: broadcastParams });
    }
    function* sessionChannelWorker(action) {
        if (action.type !== socketMessageAction.type) {
            yield put(action);
            return;
        }
        const { method, params } = action.payload;
        switch (method) {
            case 'signalwire.event':
                yield fork(swEventWorker, params);
                break;
            default:
                return getLogger().debug(`Unknown message: ${method}`, action);
        }
    }
    const sessionChannelWorkerCatchable = createCatchableSaga(sessionChannelWorker, (error) => {
        getLogger().error('Channel Error', error);
    });
    /**
     * Make the watcher restartable
     */
    while (true) {
        try {
            while (true) {
                const action = yield take(sessionChannel);
                yield fork(sessionChannelWorkerCatchable, action);
            }
        }
        catch (error) {
            getLogger().error('sessionChannelWorker error:', error);
        }
        finally {
            getLogger().debug('sessionChannelWorker finally');
        }
    }
}
//# sourceMappingURL=sessionSaga.js.map