import { getSession } from './features/session/sessionSelectors';
export const connect = (options) => {
    const { sessionListeners = {}, store, Component, customSagas = [] } = options;
    const sessionKeys = Object.keys(sessionListeners);
    return (userOptions) => {
        const instance = new Component(Object.assign(Object.assign({}, userOptions), { store }));
        const cacheMap = new Map();
        /**
         * Stop the execution of the redux listeners if `destroyer`
         * below was called in the meantime.
         */
        let run = true;
        const storeUnsubscribe = store.subscribe(() => {
            const state = store.getState();
            const session = getSession(state);
            for (const reduxKey of sessionKeys) {
                if (run === false) {
                    return;
                }
                const cacheKey = `session.${reduxKey}`;
                const current = cacheMap.get(cacheKey);
                const updatedValue = session[reduxKey];
                if (updatedValue !== undefined && current !== updatedValue) {
                    cacheMap.set(cacheKey, updatedValue);
                    const fnName = sessionListeners[reduxKey];
                    if (typeof fnName === 'string') {
                        // FIXME: proper types for fnName
                        // @ts-ignore
                        instance[fnName](session);
                    }
                    else if (typeof fnName === 'function') {
                        fnName(session);
                    }
                }
            }
        });
        // Run all the custom sagas
        const taskList = customSagas === null || customSagas === void 0 ? void 0 : customSagas.map((saga) => {
            return store.runSaga(saga, { instance, runSaga: store.runSaga });
        });
        instance.destroyer = () => {
            run = false;
            storeUnsubscribe();
            cacheMap.clear();
            // Cancel all the custom sagas
            if (taskList === null || taskList === void 0 ? void 0 : taskList.length) {
                taskList.forEach((task) => task.cancel());
            }
        };
        return instance;
    };
};
//# sourceMappingURL=connect.js.map