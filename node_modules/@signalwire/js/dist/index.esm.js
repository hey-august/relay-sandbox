var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/fabric/index.ts
var fabric_exports = {};
__export(fabric_exports, {
  Client: () => Client2,
  SWClient: () => SWClient,
  SignalWire: () => SignalWire,
  WSClient: () => WSClient
});

// src/fabric/createHttpClient.ts
import { AuthError, HttpError } from "@signalwire/core";
async function http(input, init) {
  const response = await fetch(input, init);
  if (!response.ok) {
    if (response.status === 401) {
      throw new AuthError(response.status, "Unauthorized");
    }
    let errorResponse;
    try {
      errorResponse = await response.json();
    } catch (e) {
    }
    const errorMessage = (errorResponse == null ? void 0 : errorResponse.errors) ? JSON.stringify(errorResponse.errors) : "Not Found";
    throw new HttpError(response.status, errorMessage, errorResponse);
  }
  try {
    response.parsedBody = await response.json();
  } catch (e) {
  }
  return response;
}
var createHttpClient = (_a, fetcher = http) => {
  var _b = _a, { baseUrl, timeout = 3e4 } = _b, globalOptions = __objRest(_b, ["baseUrl", "timeout"]);
  const apiClient = async (path, options) => {
    const headers = __spreadValues(__spreadValues(__spreadValues({}, (options == null ? void 0 : options.body) ? { "Content-Type": "application/json" } : {}), globalOptions.headers), options == null ? void 0 : options.headers);
    const reqInit = getRequestInit(__spreadProps(__spreadValues(__spreadValues({}, globalOptions), options), {
      headers
    }));
    let timerId;
    if (timeout) {
      const controller = new AbortController();
      const signal = controller.signal;
      reqInit.signal = signal;
      timerId = setTimeout(() => {
        controller.abort();
      }, timeout);
    }
    try {
      const response = await fetcher(getUrl({
        path,
        baseUrl,
        searchParams: options == null ? void 0 : options.searchParams
      }), reqInit);
      return { body: response.parsedBody };
    } catch (e) {
      throw e;
    } finally {
      timerId && clearTimeout(timerId);
    }
  };
  return apiClient;
};
var getBody = (body) => {
  return typeof body === "string" ? body : JSON.stringify(body);
};
var getRequestInit = (options) => {
  return Object.entries(options).reduce((reducer, [key, value]) => {
    if (key === "body") {
      return __spreadProps(__spreadValues({}, reducer), {
        body: getBody(value)
      });
    } else if (value != void 0) {
      return __spreadProps(__spreadValues({}, reducer), {
        [key]: value
      });
    }
    return reducer;
  }, {});
};
var getUrl = ({
  path,
  baseUrl,
  searchParams
}) => {
  const url = new URL(path, baseUrl);
  if (searchParams) {
    Object.entries(searchParams).forEach(([key, value]) => {
      if (value != void 0) {
        url.searchParams.append(key, value);
      }
    });
  }
  return url.toString();
};

// src/video.ts
var video_exports = {};
__export(video_exports, {
  RoomSession: () => RoomSession,
  createClient: () => createClient,
  createRoomObject: () => createRoomObject,
  joinRoom: () => joinRoom
});

// src/createRoomObject.ts
import { getLogger as getLogger13 } from "@signalwire/core";

// src/createClient.ts
import {
  configureStore,
  connect as connect3,
  getEventEmitter
} from "@signalwire/core";

// src/Client.ts
import {
  BaseClient,
  actions as actions3,
  Chat as ChatNamespace,
  PubSub as PubSubNamespace
} from "@signalwire/core";

// src/features/mediaElements/mediaElementsSagas.ts
import {
  getLogger as getLogger2,
  actions as actions2,
  sagaEffects,
  LOCAL_EVENT_PREFIX
} from "@signalwire/core";
import { setMediaElementSinkId } from "@signalwire/webrtc";

// src/utils/videoElement.ts
import {
  getLogger,
  debounce
} from "@signalwire/core";
var addSDKPrefix = (input) => {
  return `sw-sdk-${input}`;
};
var buildVideo = () => {
  const video = document.createElement("video");
  video.muted = true;
  video.autoplay = true;
  video.playsInline = true;
  video.addEventListener("pause", () => {
    video.play().catch((error) => {
      getLogger().error("Video Element Paused", video, error);
    });
  });
  return video;
};
var waitForVideoReady = ({ element }) => {
  return new Promise((resolve) => {
    element.addEventListener("canplay", function listener() {
      element.removeEventListener("canplay", listener);
      resolve();
    });
    element.addEventListener("resize", function listener() {
      element.removeEventListener("resize", listener);
      resolve();
    });
  });
};
var _getLocationStyles = ({
  x,
  y,
  width,
  height
}) => {
  return {
    top: `${y}%`,
    left: `${x}%`,
    width: `${width}%`,
    height: `${height}%`
  };
};
var _buildLayer = ({ location }) => {
  const { top, left, width, height } = _getLocationStyles(location);
  const layer = document.createElement("div");
  layer.style.position = "absolute";
  layer.style.overflow = "hidden";
  layer.style.top = top;
  layer.style.left = left;
  layer.style.width = width;
  layer.style.height = height;
  return layer;
};
var makeLayoutChangedHandler = ({ localOverlay, rootElement }) => async ({ layout, myMemberId, localStream }) => {
  getLogger().debug("Process layout.changed");
  try {
    const { layers = [] } = layout;
    const location = layers.find(({ member_id }) => member_id === myMemberId);
    let myLayer = localOverlay.domElement;
    localOverlay.status = location ? "visible" : "hidden";
    if (!location) {
      getLogger().debug("Location not found");
      if (myLayer) {
        getLogger().debug("Current layer not visible");
        localOverlay.hide();
      }
      return;
    }
    if (!myLayer) {
      getLogger().debug("Build myLayer");
      myLayer = _buildLayer({ location });
      myLayer.id = localOverlay.id;
      const localVideo = buildVideo();
      localVideo.srcObject = localStream;
      localVideo.disablePictureInPicture = true;
      localVideo.style.width = "100%";
      localVideo.style.height = "100%";
      localVideo.style.pointerEvents = "none";
      localVideo.style.objectFit = "cover";
      myLayer.appendChild(localVideo);
      const mcuLayers = rootElement.querySelector(".mcuLayers");
      const exists = mcuLayers == null ? void 0 : mcuLayers.querySelector(`#${myLayer.id}`);
      if (mcuLayers && !exists) {
        getLogger().debug("Build myLayer append it");
        mcuLayers.appendChild(myLayer);
        localOverlay.domElement = myLayer;
        localOverlay.setLocalOverlayMirror();
        return;
      }
      getLogger().debug("Build myLayer >> wait next");
      return;
    }
    const { top, left, width, height } = _getLocationStyles(location);
    getLogger().debug("Update myLayer:", top, left, width, height);
    const hasVideo = localStream.getVideoTracks().filter((t) => t.enabled && t.readyState === "live").length > 0;
    if (hasVideo) {
      localOverlay.setLocalOverlayMediaStream(localStream);
    }
    myLayer.style.opacity = hasVideo ? "1" : "0";
    myLayer.style.top = top;
    myLayer.style.left = left;
    myLayer.style.width = width;
    myLayer.style.height = height;
  } catch (error) {
    getLogger().error("Layout Changed Error", error);
  }
};
var cleanupElement = (rootElement) => {
  while (rootElement.firstChild) {
    rootElement.removeChild(rootElement.firstChild);
  }
};
var setVideoMediaTrack = ({
  track,
  element
}) => {
  element.srcObject = new MediaStream([track]);
  track.addEventListener("ended", () => {
    element.srcObject = null;
    element.remove();
  });
};
var createRootElementResizeObserver = ({
  video,
  rootElement,
  paddingWrapper
}) => {
  const computePaddingWrapperWidth = (width, height) => {
    const nativeVideoRatio = video.videoWidth / video.videoHeight;
    const rootElementRatio = width / height;
    if (nativeVideoRatio > rootElementRatio) {
      return "100%";
    } else {
      return `${height * nativeVideoRatio}px`;
    }
  };
  const maxPaddingBottom = video.videoHeight / video.videoWidth * 100;
  const update = debounce(({ width, height }) => {
    if (paddingWrapper) {
      const pb = height / width * 100;
      paddingWrapper.style.paddingBottom = `${pb > maxPaddingBottom ? maxPaddingBottom : pb}%`;
      paddingWrapper.style.width = computePaddingWrapperWidth(width, height);
    }
  }, 100);
  const observer = new ResizeObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.contentBoxSize) {
        const { inlineSize, blockSize } = Array.isArray(entry.contentBoxSize) ? entry.contentBoxSize[0] : entry.contentBoxSize;
        update({ width: inlineSize, height: blockSize });
      } else if (entry.contentRect) {
        update({
          width: entry.contentRect.width,
          height: entry.contentRect.height
        });
      }
    });
  });
  return {
    start: () => observer.observe(rootElement),
    stop: () => observer.disconnect()
  };
};

// src/utils/audioElement.ts
var setAudioMediaTrack = ({
  track,
  element
}) => {
  element.autoplay = true;
  element.playsinline = true;
  element.srcObject = new MediaStream([track]);
  track.addEventListener("ended", () => {
    element.srcObject = null;
    element.remove();
  });
  return element;
};

// src/features/actions.ts
import { actions } from "@signalwire/core";
var audioSetSpeakerAction = actions.createAction("swJs/audioSetSpeakerAction");

// src/features/mediaElements/mediaElementsSagas.ts
var makeVideoElementSaga = ({
  rootElement,
  applyLocalVideoOverlay
}) => {
  return function* videoElementSaga({
    instance: room,
    runSaga
  }) {
    try {
      const layerMap = /* @__PURE__ */ new Map();
      const videoEl = buildVideo();
      const localOverlay = {
        status: "hidden",
        get id() {
          return addSDKPrefix(room.id);
        },
        get domElement() {
          return layerMap.get(this.id);
        },
        set domElement(element) {
          if (element) {
            getLogger2().debug("Set localOverlay", element);
            layerMap.set(this.id, element);
          } else {
            getLogger2().debug("Remove localOverlay");
            layerMap.delete(this.id);
          }
        },
        hide() {
          if (!this.domElement) {
            return getLogger2().warn("Missing localOverlay to hide");
          }
          this.domElement.style.opacity = "0";
        },
        show() {
          if (!this.domElement) {
            return getLogger2().warn("Missing localOverlay to show");
          }
          if (this.status === "hidden") {
            return getLogger2().info("localOverlay not visible");
          }
          this.domElement.style.opacity = "1";
        },
        setLocalOverlayMediaStream(stream) {
          if (!this.domElement) {
            return getLogger2().warn("Missing localOverlay to set the local overlay stream");
          }
          const localVideo = this.domElement.querySelector("video");
          if (localVideo) {
            localVideo.srcObject = stream;
          }
        },
        setLocalOverlayMirror(mirror) {
          if (!this.domElement || !this.domElement.firstChild) {
            return getLogger2().warn("Missing localOverlay to set the mirror");
          }
          const videoEl2 = this.domElement.firstChild;
          if (mirror != null ? mirror : room.localOverlay.mirrored) {
            videoEl2.style.transform = "scale(-1, 1)";
            videoEl2.style.webkitTransform = "scale(-1, 1)";
          } else {
            videoEl2.style.transform = "scale(1, 1)";
            videoEl2.style.webkitTransform = "scale(1, 1)";
          }
        }
      };
      const layoutChangedHandler = makeLayoutChangedHandler({
        rootElement,
        localOverlay
      });
      let hasVideoTrack = false;
      let lastLayoutChanged = null;
      const _processLayoutChanged = (params) => {
        var _a;
        if (((_a = room.peer) == null ? void 0 : _a.hasVideoSender) && room.localStream) {
          layoutChangedHandler({
            layout: params.layout,
            localStream: room.localStream,
            myMemberId: room.memberId
          });
        } else {
          localOverlay.hide();
        }
      };
      room.on(`${LOCAL_EVENT_PREFIX}.mirror.video`, (value) => {
        localOverlay.setLocalOverlayMirror(value);
      });
      room.on("layout.changed", (params) => {
        getLogger2().debug("Received layout.changed - videoTrack", hasVideoTrack);
        if (hasVideoTrack) {
          _processLayoutChanged(params);
          return;
        }
        lastLayoutChanged = params;
      });
      room.on("room.subscribed", (params) => {
        var _a;
        const member = (_a = params.room_session.members) == null ? void 0 : _a.find((m) => m.id === room.memberId);
        if (member == null ? void 0 : member.audio_muted) {
          try {
            room.stopOutboundAudio();
          } catch (error) {
            getLogger2().error("Error handling audio_muted", error);
          }
        }
        if (member == null ? void 0 : member.video_muted) {
          try {
            room.stopOutboundVideo();
          } catch (error) {
            getLogger2().error("Error handling video_muted", error);
          }
        }
        if (room.localStream) {
          localOverlay.setLocalOverlayMediaStream(room.localStream);
        }
      });
      room.on("member.updated.video_muted", (params) => {
        try {
          const { member } = params;
          if (member.id === room.memberId && "video_muted" in member) {
            member.video_muted ? localOverlay.hide() : localOverlay.show();
          }
        } catch (error) {
          getLogger2().error("Error handling video_muted", error);
        }
      });
      let videoTask;
      const trackHandler = function(event) {
        switch (event.track.kind) {
          case "video": {
            videoTask = runSaga(videoElementSetupWorker, {
              applyLocalVideoOverlay,
              rootElement,
              track: event.track,
              element: videoEl
            });
            hasVideoTrack = true;
            if (lastLayoutChanged) {
              _processLayoutChanged(lastLayoutChanged);
            }
            break;
          }
        }
      };
      room.on("track", trackHandler);
      room.once("destroy", () => {
        cleanupElement(rootElement);
        layerMap.clear();
        videoTask == null ? void 0 : videoTask.cancel();
      });
    } catch (error) {
      getLogger2().error("videoElementSaga", error);
    }
  };
};
var makeAudioElementSaga = ({ speakerId }) => {
  return function* audioElementSaga({
    instance: room,
    runSaga
  }) {
    if (typeof Audio === "undefined") {
      getLogger2().warn("`Audio` is not supported on this environment.");
      return;
    }
    try {
      const audioEl = room.getAudioEl();
      let audioTask;
      const trackHandler = function(event) {
        switch (event.track.kind) {
          case "audio": {
            audioTask = runSaga(audioElementSetupWorker, {
              track: event.track,
              element: audioEl,
              speakerId,
              room
            });
            break;
          }
        }
      };
      room.on("track", trackHandler);
      room.once("destroy", () => {
        audioTask == null ? void 0 : audioTask.cancel();
      });
    } catch (error) {
      getLogger2().error("audioElementSaga", error);
    }
  };
};
function* audioElementActionsWatcher({
  element,
  room
}) {
  const setSpeakerActionType = actions2.getCustomSagaActionType(room.__uuid, audioSetSpeakerAction);
  while (true) {
    const action = yield sagaEffects.take([setSpeakerActionType]);
    try {
      switch (action.type) {
        case setSpeakerActionType:
          const response = yield sagaEffects.call(setMediaElementSinkId, element, action.payload);
          room.emit(`${LOCAL_EVENT_PREFIX}.speaker.updated`, action.payload);
          room.settleCustomSagaTrigger({
            dispatchId: action.dispatchId,
            payload: response,
            kind: "resolve"
          });
          break;
      }
    } catch (error) {
      room.settleCustomSagaTrigger({
        dispatchId: action.dispatchId,
        payload: error,
        kind: "reject"
      });
      getLogger2().error(error);
    }
  }
}
function* audioElementSetupWorker({
  track,
  element,
  speakerId,
  room
}) {
  setAudioMediaTrack({ track, element });
  if (speakerId) {
    setMediaElementSinkId(element, speakerId).catch(() => {
    });
  }
  yield sagaEffects.fork(audioElementActionsWatcher, {
    element,
    room
  });
}
function* videoElementSetupWorker({
  rootElement,
  applyLocalVideoOverlay = true,
  track,
  element
}) {
  try {
    setVideoMediaTrack({ element, track });
    element.style.width = "100%";
    element.style.maxHeight = "100%";
    if (!applyLocalVideoOverlay) {
      rootElement.appendChild(element);
      return;
    }
    if (rootElement.querySelector(".mcuContent")) {
      getLogger2().debug("MCU Content already there");
      return;
    }
    const mcuWrapper = document.createElement("div");
    mcuWrapper.style.position = "absolute";
    mcuWrapper.style.top = "0";
    mcuWrapper.style.left = "0";
    mcuWrapper.style.right = "0";
    mcuWrapper.style.bottom = "0";
    mcuWrapper.appendChild(element);
    const paddingWrapper = document.createElement("div");
    paddingWrapper.classList.add("paddingWrapper");
    paddingWrapper.style.paddingBottom = "56.25%";
    paddingWrapper.style.position = "relative";
    paddingWrapper.style.width = "100%";
    paddingWrapper.appendChild(mcuWrapper);
    const layersWrapper = document.createElement("div");
    layersWrapper.classList.add("mcuLayers");
    layersWrapper.style.display = "none";
    paddingWrapper.appendChild(layersWrapper);
    const relativeWrapper = document.createElement("div");
    relativeWrapper.classList.add("mcuContent");
    relativeWrapper.style.position = "relative";
    relativeWrapper.style.width = "100%";
    relativeWrapper.style.height = "100%";
    relativeWrapper.style.margin = "0 auto";
    relativeWrapper.style.display = "flex";
    relativeWrapper.style.alignItems = "center";
    relativeWrapper.style.justifyContent = "center";
    relativeWrapper.appendChild(paddingWrapper);
    rootElement.style.width = "100%";
    rootElement.style.height = "100%";
    rootElement.appendChild(relativeWrapper);
    getLogger2().debug("MCU readyState 1 >>", element.readyState);
    if (element.readyState === HTMLMediaElement.HAVE_NOTHING) {
      getLogger2().debug("Wait for the MCU to be ready");
      yield sagaEffects.call(waitForVideoReady, { element });
    }
    getLogger2().debug("MCU is ready..");
    const rootElementResizeObserver = createRootElementResizeObserver({
      rootElement,
      video: element,
      paddingWrapper
    });
    rootElementResizeObserver.start();
    track.addEventListener("ended", () => {
      if (rootElementResizeObserver) {
        rootElementResizeObserver.stop();
      }
    });
    layersWrapper.style.display = "block";
  } catch (error) {
    getLogger2().error("Handle video track error", error);
  }
}

// src/BaseRoomSession.ts
import {
  connect,
  Rooms as Rooms6,
  extendComponent as extendComponent3,
  LOCAL_EVENT_PREFIX as LOCAL_EVENT_PREFIX2,
  validateEventsToSubscribe as validateEventsToSubscribe2
} from "@signalwire/core";
import {
  getDisplayMedia,
  BaseConnection as BaseConnection3,
  supportsMediaOutput,
  createSpeakerDeviceWatcher,
  getSpeakerById
} from "@signalwire/webrtc";

// src/utils/constants.ts
var SCREENSHARE_AUDIO_CONSTRAINTS = {
  echoCancellation: true,
  noiseSuppression: false,
  autoGainControl: false,
  googAutoGainControl: false
};

// src/RoomSessionScreenShare.ts
import {
  Rooms,
  extendComponent
} from "@signalwire/core";
import { BaseConnection } from "@signalwire/webrtc";
var RoomSessionScreenShareConnection = class extends BaseConnection {
  join() {
    return super.invite();
  }
  leave() {
    return super.hangup();
  }
};
var RoomSessionScreenShareAPI = extendComponent(RoomSessionScreenShareConnection, {
  audioMute: Rooms.audioMuteMember,
  audioUnmute: Rooms.audioUnmuteMember,
  videoMute: Rooms.videoMuteMember,
  videoUnmute: Rooms.videoUnmuteMember,
  setMicrophoneVolume: Rooms.setInputVolumeMember,
  setInputVolume: Rooms.setInputVolumeMember,
  setInputSensitivity: Rooms.setInputSensitivityMember
});

// src/RoomSessionDevice.ts
import {
  Rooms as Rooms2,
  extendComponent as extendComponent2
} from "@signalwire/core";
import { BaseConnection as BaseConnection2 } from "@signalwire/webrtc";
var RoomSessionDeviceConnection = class extends BaseConnection2 {
  join() {
    return super.invite();
  }
  leave() {
    return super.hangup();
  }
};
var RoomSessionDeviceAPI = extendComponent2(RoomSessionDeviceConnection, {
  audioMute: Rooms2.audioMuteMember,
  audioUnmute: Rooms2.audioUnmuteMember,
  videoMute: Rooms2.videoMuteMember,
  videoUnmute: Rooms2.videoUnmuteMember,
  setInputVolume: Rooms2.setInputVolumeMember,
  setMicrophoneVolume: Rooms2.setInputVolumeMember,
  setInputSensitivity: Rooms2.setInputSensitivityMember
});

// src/video/memberListUpdatedWorker.ts
import {
  sagaEffects as sagaEffects2,
  toSyntheticEvent,
  validateEventsToSubscribe,
  toInternalEventName
} from "@signalwire/core";
var noop = () => {
};
var EXTERNAL_MEMBER_LIST_UPDATED_EVENT = "memberList.updated";
var INTERNAL_MEMBER_LIST_UPDATED_EVENT = toInternalEventName({
  event: EXTERNAL_MEMBER_LIST_UPDATED_EVENT
});
var SYNTHETIC_MEMBER_LIST_UPDATED_EVENT = toSyntheticEvent(INTERNAL_MEMBER_LIST_UPDATED_EVENT);
var MEMBER_LIST_EVENTS = [
  "video.room.joined",
  "video.member.joined",
  "video.member.left",
  "video.member.updated"
];
var isMemberListEvent = (event) => {
  return MEMBER_LIST_EVENTS.includes(event);
};
var getMemberListEventsToSubscribe = (subscriptions) => {
  return validateEventsToSubscribe(MEMBER_LIST_EVENTS).filter((event) => {
    return !subscriptions.includes(event);
  });
};
var shouldHandleMemberList = (subscriptions) => {
  return subscriptions.some((event) => event.includes(EXTERNAL_MEMBER_LIST_UPDATED_EVENT));
};
var getMembersFromAction = (action) => {
  if (action.type === "video.room.joined") {
    return action.payload.room_session.members;
  }
  return [action.payload.member];
};
var getUpdatedMembers = ({
  action,
  memberList
}) => {
  const actionMembers = getMembersFromAction(action);
  switch (action.type) {
    case "video.member.left":
      actionMembers.forEach((member) => {
        memberList.delete(member.id);
      });
      break;
    default:
      actionMembers.forEach((member) => {
        memberList.set(member.id, member);
      });
  }
  return Array.from(memberList.values());
};
var initMemberListSubscriptions = (room, subscriptions) => {
  const events = getMemberListEventsToSubscribe(subscriptions);
  events.forEach((event) => {
    room.once(event, noop);
  });
  const eventBridgeHandler = ({ members }) => {
    room.emit(EXTERNAL_MEMBER_LIST_UPDATED_EVENT, { members });
  };
  room.on(SYNTHETIC_MEMBER_LIST_UPDATED_EVENT, eventBridgeHandler);
  const cleanup = () => {
    room.off(SYNTHETIC_MEMBER_LIST_UPDATED_EVENT, eventBridgeHandler);
  };
  return {
    cleanup
  };
};
function* membersListUpdatedWatcher({
  swEventChannel,
  instance
}) {
  const memberList = /* @__PURE__ */ new Map();
  function* worker(pubSubAction) {
    const roomSessionId = pubSubAction.type === "video.room.joined" ? pubSubAction.payload.room_session.id : pubSubAction.payload.room_session_id;
    const members = getUpdatedMembers({ action: pubSubAction, memberList });
    const memberListPayload = {
      room_session_id: roomSessionId,
      members
    };
    instance.emit(SYNTHETIC_MEMBER_LIST_UPDATED_EVENT, memberListPayload);
  }
  while (true) {
    const pubSubAction = yield sagaEffects2.take(swEventChannel, ({ type }) => {
      return isMemberListEvent(type);
    });
    yield sagaEffects2.fork(worker, pubSubAction);
  }
}
var memberListUpdatedWorker = function* membersChangedWorker({
  channels: { swEventChannel },
  instance
}) {
  const subscriptions = instance.getSubscriptions();
  if (!shouldHandleMemberList(subscriptions)) {
    return;
  }
  const { cleanup } = initMemberListSubscriptions(instance, subscriptions);
  yield sagaEffects2.fork(membersListUpdatedWatcher, {
    swEventChannel,
    instance
  });
  instance.once("destroy", () => {
    cleanup();
  });
};

// src/video/childMemberJoinedWorker.ts
import {
  getLogger as getLogger3,
  sagaEffects as sagaEffects3,
  componentSelectors,
  componentActions
} from "@signalwire/core";
var childMemberJoinedWorker = function* (options) {
  getLogger3().trace("childMemberJoinedWorker started");
  const { channels, instance, initialState, onDone, onFail } = options;
  const { swEventChannel } = channels;
  const { parentId } = initialState;
  if (!parentId) {
    throw new Error("Missing parentId for childMemberJoinedWorker");
  }
  const action = yield sagaEffects3.take(swEventChannel, (action2) => {
    if (action2.type === "video.member.joined") {
      return action2.payload.member.parent_id === parentId;
    }
    return false;
  });
  const { member } = action.payload;
  if (member == null ? void 0 : member.parent_id) {
    const byId = yield sagaEffects3.select(componentSelectors.getComponentsById);
    const parent = Object.values(byId).find((row) => {
      return "memberId" in row && row.memberId === member.parent_id;
    });
    if (parent) {
      yield sagaEffects3.put(componentActions.upsert({
        id: instance.callId,
        roomId: action.payload.room_id,
        roomSessionId: action.payload.room_session_id,
        memberId: member.id
      }));
      onDone == null ? void 0 : onDone();
    } else {
      onFail == null ? void 0 : onFail({ error: new Error("Unknown parent_id") });
    }
  }
  getLogger3().trace("childMemberJoinedWorker ended");
};

// src/video/videoWorker.ts
import {
  getLogger as getLogger7,
  sagaEffects as sagaEffects4,
  MemberPosition,
  stripNamespacePrefix as stripNamespacePrefix3
} from "@signalwire/core";

// src/video/videoStreamWorker.ts
import {
  getLogger as getLogger4,
  Rooms as Rooms3
} from "@signalwire/core";
var videoStreamWorker = function* (options) {
  getLogger4().trace("videoStreamWorker started");
  const {
    instance: roomSession,
    action: { type, payload },
    instanceMap: { get, set, remove }
  } = options;
  let streamInstance = get(payload.stream.id);
  if (!streamInstance) {
    streamInstance = Rooms3.createRoomSessionStreamObject({
      store: roomSession.store,
      payload
    });
  } else {
    streamInstance.setPayload(payload);
  }
  set(payload.stream.id, streamInstance);
  switch (type) {
    case "video.stream.started":
      roomSession.emit("stream.started", streamInstance);
      break;
    case "video.stream.ended":
      roomSession.emit("stream.ended", streamInstance);
      remove(payload.stream.id);
      break;
    default:
      getLogger4().warn(`Unknown video.stream event: "${type}"`);
      break;
  }
  getLogger4().trace("videoStreamWorker ended");
};

// src/video/videoRecordWorker.ts
import {
  getLogger as getLogger5,
  Rooms as Rooms4,
  stripNamespacePrefix
} from "@signalwire/core";
var videoRecordWorker = function* (options) {
  getLogger5().trace("videoRecordWorker started");
  const {
    instance: roomSession,
    action: { type, payload },
    instanceMap: { get, set, remove }
  } = options;
  let recordingInstance = get(payload.recording.id);
  if (!recordingInstance) {
    recordingInstance = Rooms4.createRoomSessionRecordingObject({
      store: roomSession.store,
      payload
    });
  } else {
    recordingInstance.setPayload(payload);
  }
  set(payload.recording.id, recordingInstance);
  const event = stripNamespacePrefix(type);
  switch (type) {
    case "video.recording.started":
    case "video.recording.updated": {
      roomSession.emit(event, recordingInstance);
      break;
    }
    case "video.recording.ended":
      roomSession.emit(event, recordingInstance);
      remove(payload.recording.id);
      break;
    default:
      getLogger5().warn(`Unknown video.stream event: "${type}"`);
      break;
  }
  getLogger5().trace("videoRecordWorker ended");
};

// src/video/videoPlaybackWorker.ts
import {
  getLogger as getLogger6,
  Rooms as Rooms5,
  stripNamespacePrefix as stripNamespacePrefix2
} from "@signalwire/core";
var videoPlaybackWorker = function* (options) {
  getLogger6().trace("videoPlaybackWorker started");
  const {
    instance: roomSession,
    action: { type, payload },
    instanceMap: { get, set, remove }
  } = options;
  let playbackInstance = get(payload.playback.id);
  if (!playbackInstance) {
    playbackInstance = Rooms5.createRoomSessionPlaybackObject({
      store: roomSession.store,
      payload
    });
  } else {
    playbackInstance.setPayload(payload);
  }
  set(payload.playback.id, playbackInstance);
  const event = stripNamespacePrefix2(type);
  switch (type) {
    case "video.playback.started":
    case "video.playback.updated": {
      roomSession.emit(event, playbackInstance);
      break;
    }
    case "video.playback.ended":
      roomSession.emit(event, playbackInstance);
      remove(payload.playback.id);
      break;
    default:
      getLogger6().warn(`Unknown video.stream event: "${type}"`);
      break;
  }
  getLogger6().trace("videoPlaybackWorker ended");
};

// src/video/videoWorker.ts
var videoWorker = function* (options) {
  const { channels, instance: roomSession } = options;
  const { swEventChannel } = channels;
  function* worker(action) {
    const { type, payload } = action;
    switch (type) {
      case "video.room.subscribed":
        yield sagaEffects4.spawn(MemberPosition.memberPositionWorker, __spreadProps(__spreadValues({}, options), {
          instance: roomSession,
          initialState: payload
        }));
        break;
      case "video.playback.started":
      case "video.playback.updated":
      case "video.playback.ended":
        yield sagaEffects4.fork(videoPlaybackWorker, __spreadValues({
          action
        }, options));
        return;
      case "video.recording.started":
      case "video.recording.updated":
      case "video.recording.ended":
        yield sagaEffects4.fork(videoRecordWorker, __spreadValues({
          action
        }, options));
        return;
      case "video.stream.ended":
      case "video.stream.started":
        yield sagaEffects4.fork(videoStreamWorker, __spreadValues({
          action
        }, options));
        return;
      case "video.room.audience_count": {
        roomSession.emit("room.audienceCount", payload);
        return;
      }
      case "video.member.talking": {
        const { member } = payload;
        if ("talking" in member) {
          const suffix = member.talking ? "started" : "ended";
          roomSession.emit(`member.talking.${suffix}`, payload);
          const deprecatedSuffix = member.talking ? "start" : "stop";
          roomSession.emit(`member.talking.${deprecatedSuffix}`, payload);
        }
        break;
      }
      default:
        break;
    }
    roomSession.emit(stripNamespacePrefix3(type), payload);
  }
  const isVideoEvent = (action) => action.type.startsWith("video.");
  while (true) {
    const action = yield sagaEffects4.take(swEventChannel, isVideoEvent);
    yield sagaEffects4.fork(worker, action);
  }
  getLogger7().trace("videoWorker ended");
};

// src/BaseRoomSession.ts
var RoomSessionConnection = class extends BaseConnection3 {
  constructor(options) {
    super(options);
    __publicField(this, "_screenShareList", /* @__PURE__ */ new Set());
    __publicField(this, "_deviceList", /* @__PURE__ */ new Set());
    __publicField(this, "_mirrored");
    __publicField(this, "_audioEl");
    this._mirrored = options.mirrorLocalVideoOverlay;
    this.runWorker("videoWorker", {
      worker: videoWorker
    });
  }
  get screenShareList() {
    return Array.from(this._screenShareList);
  }
  get deviceList() {
    return Array.from(this._deviceList);
  }
  get interactivityMode() {
    return this.select(({ session }) => {
      var _a;
      const { authState } = session;
      return (_a = authState == null ? void 0 : authState.join_as) != null ? _a : "";
    });
  }
  get permissions() {
    return this.select(({ session }) => {
      var _a, _b;
      const { authState } = session;
      return (_b = (_a = authState == null ? void 0 : authState.room) == null ? void 0 : _a.scopes) != null ? _b : [];
    });
  }
  attachPreConnectWorkers() {
    this.runWorker("memberListUpdated", {
      worker: memberListUpdatedWorker
    });
  }
  async createScreenShareObject(opts = {}) {
    return this.startScreenShare(opts);
  }
  async startScreenShare(opts = {}) {
    return new Promise(async (resolve, reject) => {
      var _a;
      const {
        autoJoin = true,
        audio = false,
        video = true,
        layout,
        positions
      } = opts;
      const displayStream = await getDisplayMedia({
        audio: audio === true ? SCREENSHARE_AUDIO_CONSTRAINTS : audio,
        video
      });
      const options = __spreadProps(__spreadValues({}, this.options), {
        screenShare: true,
        recoverCall: false,
        localStream: displayStream,
        remoteStream: void 0,
        userVariables: __spreadProps(__spreadValues({}, ((_a = this.options) == null ? void 0 : _a.userVariables) || {}), {
          memberCallId: this.callId,
          memberId: this.memberId
        }),
        layout,
        positions
      });
      const screenShare = connect({
        store: this.store,
        Component: RoomSessionScreenShareAPI
      })(options);
      displayStream.getVideoTracks().forEach((t) => {
        t.addEventListener("ended", () => {
          if (screenShare && screenShare.active) {
            screenShare.leave();
          }
        });
      });
      screenShare.once("destroy", () => {
        screenShare.emit("room.left");
        this._screenShareList.delete(screenShare);
      });
      try {
        screenShare.runWorker("childMemberJoinedWorker", {
          worker: childMemberJoinedWorker,
          onDone: () => resolve(screenShare),
          onFail: reject,
          initialState: {
            parentId: this.memberId
          }
        });
        this._screenShareList.add(screenShare);
        if (autoJoin) {
          return await screenShare.join();
        }
        return resolve(screenShare);
      } catch (error) {
        this.logger.error("ScreenShare Error", error);
        reject(error);
      }
    });
  }
  addCamera(opts = {}) {
    const _a = opts, { autoJoin = true } = _a, video = __objRest(_a, ["autoJoin"]);
    return this.addDevice({
      autoJoin,
      video
    });
  }
  addMicrophone(opts = {}) {
    const _a = opts, { autoJoin = true } = _a, audio = __objRest(_a, ["autoJoin"]);
    return this.addDevice({
      autoJoin,
      audio
    });
  }
  async addDevice(opts = {}) {
    return new Promise(async (resolve, reject) => {
      var _a;
      const { autoJoin = true, audio = false, video = false } = opts;
      if (!audio && !video) {
        throw new TypeError("At least one of `audio` or `video` must be requested.");
      }
      const options = __spreadProps(__spreadValues({}, this.options), {
        localStream: void 0,
        remoteStream: void 0,
        audio,
        video,
        additionalDevice: true,
        recoverCall: false,
        userVariables: __spreadProps(__spreadValues({}, ((_a = this.options) == null ? void 0 : _a.userVariables) || {}), {
          memberCallId: this.callId,
          memberId: this.memberId
        })
      });
      const roomDevice = connect({
        store: this.store,
        Component: RoomSessionDeviceAPI
      })(options);
      roomDevice.once("destroy", () => {
        roomDevice.emit("room.left");
        this._deviceList.delete(roomDevice);
      });
      try {
        roomDevice.runWorker("childMemberJoinedWorker", {
          worker: childMemberJoinedWorker,
          onDone: () => resolve(roomDevice),
          onFail: reject,
          initialState: {
            parentId: this.memberId
          }
        });
        this._deviceList.add(roomDevice);
        if (autoJoin) {
          return await roomDevice.join();
        }
        return resolve(roomDevice);
      } catch (error) {
        this.logger.error("RoomDevice Error", error);
        reject(error);
      }
    });
  }
  join() {
    return super.invite();
  }
  leave() {
    return this.hangup();
  }
  updateSpeaker({ deviceId }) {
    const prevId = this._audioEl.sinkId;
    this.once(`${LOCAL_EVENT_PREFIX2}.speaker.updated`, async (newId) => {
      const prevSpeaker = await getSpeakerById(prevId);
      const newSpeaker = await getSpeakerById(newId);
      const isSame = (newSpeaker == null ? void 0 : newSpeaker.deviceId) === (prevSpeaker == null ? void 0 : prevSpeaker.deviceId);
      if (!(newSpeaker == null ? void 0 : newSpeaker.deviceId) || isSame)
        return;
      this.emit("speaker.updated", {
        previous: {
          deviceId: prevSpeaker == null ? void 0 : prevSpeaker.deviceId,
          label: prevSpeaker == null ? void 0 : prevSpeaker.label
        },
        current: {
          deviceId: newSpeaker.deviceId,
          label: newSpeaker.label
        }
      });
    });
    return this.triggerCustomSaga(audioSetSpeakerAction(deviceId));
  }
  _attachSpeakerTrackListener() {
    if (!supportsMediaOutput())
      return;
    createSpeakerDeviceWatcher().then((deviceWatcher) => {
      deviceWatcher.on("removed", async (data) => {
        var _a, _b;
        const sinkId = this._audioEl.sinkId;
        const disconnectedSpeaker = data.changes.find((device) => {
          const payloadDeviceId = device.payload.deviceId;
          return payloadDeviceId === sinkId || payloadDeviceId === "" && sinkId === "default" || payloadDeviceId === "default" && sinkId === "";
        });
        if (disconnectedSpeaker) {
          this.emit("speaker.disconnected", {
            deviceId: disconnectedSpeaker.payload.deviceId,
            label: disconnectedSpeaker.payload.label
          });
          await ((_b = (_a = this._audioEl).setSinkId) == null ? void 0 : _b.call(_a, ""));
          const defaultSpeakers = await getSpeakerById("default");
          if (!(defaultSpeakers == null ? void 0 : defaultSpeakers.deviceId))
            return;
          this.emit("speaker.updated", {
            previous: {
              deviceId: disconnectedSpeaker.payload.deviceId,
              label: disconnectedSpeaker.payload.label
            },
            current: {
              deviceId: defaultSpeakers.deviceId,
              label: defaultSpeakers.label
            }
          });
        }
      });
    });
  }
  getAudioEl() {
    if (this._audioEl)
      return this._audioEl;
    this._audioEl = new Audio();
    this._attachSpeakerTrackListener();
    return this._audioEl;
  }
  async hangup(id) {
    this._screenShareList.forEach((screenShare) => {
      screenShare.leave();
    });
    this._deviceList.forEach((device) => {
      device.leave();
    });
    return super.hangup(id);
  }
  _finalize() {
    this._screenShareList.clear();
    this._deviceList.clear();
    super._finalize();
  }
  getLayoutList() {
    return this.getLayouts();
  }
  getMemberList() {
    return this.getMembers();
  }
  get localOverlay() {
    return {
      mirrored: this._mirrored,
      setMirrored: (value) => {
        this._mirrored = value;
        this.emit(`${LOCAL_EVENT_PREFIX2}.mirror.video`, this._mirrored);
      }
    };
  }
  getSubscriptions() {
    const eventNamesWithPrefix = this.eventNames().map((event) => `video.${event}`);
    return validateEventsToSubscribe2(eventNamesWithPrefix);
  }
};
var RoomSessionAPI = extendComponent3(RoomSessionConnection, {
  audioMute: Rooms6.audioMuteMember,
  audioUnmute: Rooms6.audioUnmuteMember,
  videoMute: Rooms6.videoMuteMember,
  videoUnmute: Rooms6.videoUnmuteMember,
  deaf: Rooms6.deafMember,
  undeaf: Rooms6.undeafMember,
  setInputVolume: Rooms6.setInputVolumeMember,
  setOutputVolume: Rooms6.setOutputVolumeMember,
  setMicrophoneVolume: Rooms6.setInputVolumeMember,
  setSpeakerVolume: Rooms6.setOutputVolumeMember,
  setInputSensitivity: Rooms6.setInputSensitivityMember,
  removeMember: Rooms6.removeMember,
  removeAllMembers: Rooms6.removeAllMembers,
  getMembers: Rooms6.getMembers,
  getLayouts: Rooms6.getLayouts,
  setLayout: Rooms6.setLayout,
  setPositions: Rooms6.setPositions,
  setMemberPosition: Rooms6.setMemberPosition,
  hideVideoMuted: Rooms6.hideVideoMuted,
  showVideoMuted: Rooms6.showVideoMuted,
  getRecordings: Rooms6.getRecordings,
  startRecording: Rooms6.startRecording,
  getPlaybacks: Rooms6.getPlaybacks,
  play: Rooms6.play,
  setHideVideoMuted: Rooms6.setHideVideoMuted,
  getMeta: Rooms6.getMeta,
  setMeta: Rooms6.setMeta,
  updateMeta: Rooms6.updateMeta,
  deleteMeta: Rooms6.deleteMeta,
  getMemberMeta: Rooms6.getMemberMeta,
  setMemberMeta: Rooms6.setMemberMeta,
  updateMemberMeta: Rooms6.updateMemberMeta,
  deleteMemberMeta: Rooms6.deleteMemberMeta,
  promote: Rooms6.promote,
  demote: Rooms6.demote,
  getStreams: Rooms6.getStreams,
  startStream: Rooms6.startStream,
  lock: Rooms6.lock,
  unlock: Rooms6.unlock,
  setRaisedHand: Rooms6.setRaisedHand,
  setPrioritizeHandraise: Rooms6.setPrioritizeHandraise
});
var createBaseRoomSessionObject = (params) => {
  const room = connect({
    store: params.store,
    customSagas: params.customSagas,
    Component: RoomSessionAPI
  })(params);
  return room;
};

// src/cantina/VideoManager.ts
import {
  connect as connect2,
  validateEventsToSubscribe as validateEventsToSubscribe3,
  BaseConsumer
} from "@signalwire/core";

// src/cantina/workers/videoManagerWorker.ts
import { getLogger as getLogger10, sagaEffects as sagaEffects5 } from "@signalwire/core";

// src/cantina/workers/videoManagerRoomsWorker.ts
import {
  getLogger as getLogger8,
  toExternalJSON,
  stripNamespacePrefix as stripNamespacePrefix4
} from "@signalwire/core";
var videoManagerRoomsWorker = function* (options) {
  getLogger8().trace("videoManagerRoomsWorker started");
  const {
    instance: client,
    action: { type, payload }
  } = options;
  const modPayload = {
    rooms: payload.rooms.map((row) => toExternalJSON(row))
  };
  client.emit(stripNamespacePrefix4(type), modPayload);
  getLogger8().trace("videoManagerRoomsWorker ended");
};

// src/cantina/workers/videoManagerRoomWorker.ts
import {
  getLogger as getLogger9,
  toExternalJSON as toExternalJSON2,
  stripNamespacePrefix as stripNamespacePrefix5
} from "@signalwire/core";
var videoManagerRoomWorker = function* (options) {
  getLogger9().trace("videoManagerRoomWorker started");
  const {
    instance: client,
    action: { type, payload }
  } = options;
  client.emit(stripNamespacePrefix5(type), toExternalJSON2(payload));
  getLogger9().trace("videoManagerRoomWorker ended");
};

// src/cantina/workers/videoManagerWorker.ts
var videoManagerWorker = function* (options) {
  getLogger10().trace("videoManagerWorker started");
  const {
    channels: { swEventChannel }
  } = options;
  function* worker(action) {
    const { type } = action;
    switch (type) {
      case "video-manager.rooms.subscribed":
        yield sagaEffects5.fork(videoManagerRoomsWorker, __spreadValues({
          action
        }, options));
        break;
      case "video-manager.room.added":
      case "video-manager.room.deleted":
      case "video-manager.room.ended":
      case "video-manager.room.started":
      case "video-manager.room.updated":
        yield sagaEffects5.fork(videoManagerRoomWorker, __spreadValues({
          action
        }, options));
        break;
      default:
        getLogger10().warn(`Unknown video-manager event: "${type}"`);
        break;
    }
  }
  while (true) {
    const action = yield sagaEffects5.take(swEventChannel, (action2) => {
      return action2.type.startsWith("video-manager.");
    });
    yield sagaEffects5.fork(worker, action);
  }
  getLogger10().trace("videoManagerWorker ended");
};

// src/cantina/VideoManager.ts
var VideoManagerAPI = class extends BaseConsumer {
  constructor(options) {
    super(options);
    this.runWorker("videoManagerWorker", {
      worker: videoManagerWorker
    });
  }
  getSubscriptions() {
    const eventNamesWithPrefix = this.eventNames().map((event) => `video-manager.${event}`);
    return validateEventsToSubscribe3(eventNamesWithPrefix);
  }
};
var createVideoManagerObject = (params) => {
  const manager = connect2({
    store: params.store,
    Component: VideoManagerAPI
  })(params);
  const proxy = new Proxy(manager, {
    get(target, property, receiver) {
      if (property === "_eventsNamespace") {
        return "";
      } else if (property === "eventChannel") {
        return "video-manager.rooms";
      }
      return Reflect.get(target, property, receiver);
    }
  });
  return proxy;
};

// src/Client.ts
var ClientAPI = class extends BaseClient {
  constructor() {
    super(...arguments);
    __publicField(this, "_videoManager");
    __publicField(this, "_chat");
    __publicField(this, "_pubSub");
  }
  get rooms() {
    return {
      makeRoomObject: (makeRoomOptions) => {
        const _a = makeRoomOptions, {
          rootElement,
          applyLocalVideoOverlay = true,
          stopCameraWhileMuted = true,
          stopMicrophoneWhileMuted = true
        } = _a, options = __objRest(_a, [
          "rootElement",
          "applyLocalVideoOverlay",
          "stopCameraWhileMuted",
          "stopMicrophoneWhileMuted"
        ]);
        const customSagas = [];
        customSagas.push(makeAudioElementSaga({
          speakerId: options.speakerId
        }));
        if (rootElement) {
          customSagas.push(makeVideoElementSaga({
            rootElement,
            applyLocalVideoOverlay
          }));
        }
        const room = createBaseRoomSessionObject(__spreadProps(__spreadValues({}, options), {
          store: this.store,
          customSagas
        }));
        if (stopMicrophoneWhileMuted) {
          room.on("member.updated.audio_muted", ({ member }) => {
            try {
              if (member.id === room.memberId && "audio_muted" in member) {
                member.audio_muted ? room.stopOutboundAudio() : room.restoreOutboundAudio();
              }
            } catch (error) {
              this.logger.error("Error handling audio_muted", error);
            }
          });
        }
        if (stopCameraWhileMuted) {
          room.on("member.updated.video_muted", ({ member }) => {
            try {
              if (member.id === room.memberId && "video_muted" in member) {
                member.video_muted ? room.stopOutboundVideo() : room.restoreOutboundVideo();
              }
            } catch (error) {
              this.logger.error("Error handling video_muted", error);
            }
          });
        }
        return room;
      }
    };
  }
  get chat() {
    if (!this._chat) {
      this._chat = ChatNamespace.createBaseChatObject({
        store: this.store
      });
    }
    return this._chat;
  }
  get pubSub() {
    if (!this._pubSub) {
      this._pubSub = PubSubNamespace.createBasePubSubObject({
        store: this.store
      });
    }
    return this._pubSub;
  }
  get videoManager() {
    if (!this._videoManager) {
      this._videoManager = createVideoManagerObject(this.options);
    }
    return this._videoManager;
  }
  reauthenticate(token) {
    this.store.dispatch(actions3.reauthAction({ token }));
  }
};

// src/JWTSession.ts
import jwtDecode2 from "jwt-decode";
import {
  BaseJWTSession,
  getLogger as getLogger12
} from "@signalwire/core";

// src/utils/storage.ts
import jwtDecode from "jwt-decode";
import { getLogger as getLogger11 } from "@signalwire/core";
var getStorage = () => {
  if (window && window.sessionStorage) {
    return window.sessionStorage;
  }
  return void 0;
};
var sessionStorageManager = (token) => {
  var _a;
  let roomName = "";
  try {
    const jwtPayload = jwtDecode(token);
    roomName = (_a = jwtPayload == null ? void 0 : jwtPayload.r) != null ? _a : "";
  } catch (e) {
    if (process.env.NODE_ENV !== "production") {
      getLogger11().error("[sessionStorageManager] error decoding JWT", token);
    }
    roomName = "";
  }
  const valid = Boolean(roomName);
  return {
    authStateKey: valid && `as-${roomName}`,
    protocolKey: valid && `pt-${roomName}`,
    callIdKey: valid && `ci-${roomName}`
  };
};

// src/utils/CloseEvent.ts
import { SWCloseEvent as CoreCloseEvent } from "@signalwire/core";
var SwCloseEvent = typeof CloseEvent === "function" ? CloseEvent : CoreCloseEvent;

// src/JWTSession.ts
var JWTSession = class extends BaseJWTSession {
  constructor(options) {
    var _a;
    let decodedJwt = {};
    try {
      decodedJwt = jwtDecode2(options.token, {
        header: true
      });
    } catch (e) {
      if (process.env.NODE_ENV !== "production") {
        getLogger12().debug("[JWTSession] error decoding the JWT");
      }
    }
    super(__spreadProps(__spreadValues({}, options), {
      host: options.host || (decodedJwt == null ? void 0 : decodedJwt.ch)
    }));
    this.options = options;
    __publicField(this, "WebSocketConstructor", WebSocket);
    __publicField(this, "CloseEventConstructor", SwCloseEvent);
    __publicField(this, "agent", "@signalwire/js/browser/3.25.1");
    __publicField(this, "tokenTyp");
    this.tokenTyp = (_a = decodedJwt.typ) != null ? _a : "VRT";
  }
  get allowReattach() {
    var _a;
    return ((_a = this.options) == null ? void 0 : _a.reattach) !== false && this.isVRT();
  }
  async retrieveRelayProtocol() {
    var _a, _b;
    if (!this.allowReattach) {
      return "";
    }
    const { protocolKey } = sessionStorageManager(this.options.token);
    if (protocolKey) {
      this.logger.trace("Search protocol for", protocolKey);
      return (_b = (_a = getStorage()) == null ? void 0 : _a.getItem(protocolKey)) != null ? _b : "";
    }
    return "";
  }
  async persistRelayProtocol() {
    var _a;
    if (!this.allowReattach) {
      return;
    }
    const { protocolKey } = sessionStorageManager(this.options.token);
    if (protocolKey) {
      this.logger.trace("Persist protocol", protocolKey, this.relayProtocol);
      (_a = getStorage()) == null ? void 0 : _a.setItem(protocolKey, this.relayProtocol);
    }
  }
  async retrieveSwAuthorizationState() {
    var _a, _b;
    const { authStateKey } = sessionStorageManager(this.options.token);
    if (authStateKey) {
      return (_b = (_a = getStorage()) == null ? void 0 : _a.getItem(authStateKey)) != null ? _b : "";
    }
    return "";
  }
  async persistSwAuthorizationState(state) {
    var _a;
    if (!this.allowReattach) {
      return;
    }
    const { authStateKey } = sessionStorageManager(this.options.token);
    if (authStateKey) {
      this.logger.trace("Persist auth state", authStateKey, state);
      (_a = getStorage()) == null ? void 0 : _a.setItem(authStateKey, state);
    }
  }
  _onSocketClose(event) {
    var _a, _b, _c;
    if (this.status === "unknown") {
      const { protocolKey, authStateKey, callIdKey } = sessionStorageManager(this.options.token);
      this.logger.debug("Cleaning up storage");
      if (protocolKey) {
        this.logger.debug("Remove protocolKey", protocolKey);
        (_a = getStorage()) == null ? void 0 : _a.removeItem(protocolKey);
      }
      if (authStateKey) {
        this.logger.debug("Remove authStateKey", authStateKey);
        (_b = getStorage()) == null ? void 0 : _b.removeItem(authStateKey);
      }
      if (callIdKey) {
        this.logger.debug("Remove callIdKey", callIdKey);
        (_c = getStorage()) == null ? void 0 : _c.removeItem(callIdKey);
      }
    }
    super._onSocketClose(event);
  }
  isVRT() {
    return this.tokenTyp === "VRT";
  }
};

// src/createClient.ts
var createClient = (userOptions) => {
  const baseUserOptions = __spreadProps(__spreadValues({}, userOptions), {
    emitter: getEventEmitter()
  });
  const store = configureStore({
    userOptions: baseUserOptions,
    SessionConstructor: JWTSession
  });
  const client = connect3({
    store,
    Component: ClientAPI
  })(baseUserOptions);
  return client;
};

// src/createRoomObject.ts
var VIDEO_CONSTRAINTS = {
  aspectRatio: { ideal: 16 / 9 }
};
var createRoomObject = (roomOptions) => {
  return new Promise(async (resolve, reject) => {
    const _a = roomOptions, {
      audio = true,
      video = true,
      iceServers,
      rootElementId,
      applyLocalVideoOverlay = true,
      autoJoin = false,
      stopCameraWhileMuted = true,
      stopMicrophoneWhileMuted = true,
      speakerId
    } = _a, userOptions = __objRest(_a, [
      "audio",
      "video",
      "iceServers",
      "rootElementId",
      "applyLocalVideoOverlay",
      "autoJoin",
      "stopCameraWhileMuted",
      "stopMicrophoneWhileMuted",
      "speakerId"
    ]);
    const client = createClient(__spreadValues({}, userOptions));
    await client.connect();
    if (!client) {
      return;
    }
    let rootElement;
    if (rootElementId) {
      const el = document.getElementById(rootElementId);
      if (el) {
        rootElement = el;
      } else {
        rootElement = document.body;
        getLogger13().warn(`We couldn't find an element with id: ${rootElementId}: using 'document.body' instead.`);
      }
    }
    const roomObject = client.rooms.makeRoomObject({
      audio,
      video: video === true ? VIDEO_CONSTRAINTS : video,
      negotiateAudio: true,
      negotiateVideo: true,
      iceServers,
      rootElement,
      applyLocalVideoOverlay,
      stopCameraWhileMuted,
      stopMicrophoneWhileMuted,
      speakerId
    });
    roomObject.once("destroy", () => {
      roomObject.emit("room.left");
      client.disconnect();
    });
    const join = () => {
      return new Promise(async (resolve2, reject2) => {
        try {
          roomObject.once("room.subscribed", (_payload) => {
            resolve2(roomObject);
          });
          await roomObject.join();
        } catch (error) {
          getLogger13().error("Join", error);
          client.disconnect();
          reject2(error);
        }
      });
    };
    const room = new Proxy(roomObject, {
      get(target, prop, receiver) {
        if (prop === "join") {
          return join;
        }
        return Reflect.get(target, prop, receiver);
      }
    });
    if (autoJoin) {
      try {
        await room.join();
        resolve(room);
      } catch (error) {
        reject(error);
      }
    } else {
      resolve(room);
    }
  });
};

// src/joinRoom.ts
var joinRoom = (roomOptions) => {
  return createRoomObject(__spreadProps(__spreadValues({}, roomOptions), {
    autoJoin: true
  }));
};

// src/RoomSession.ts
import {
  getLogger as getLogger15
} from "@signalwire/core";

// src/utils/roomSession.ts
import { getLogger as getLogger14 } from "@signalwire/core";
var getJoinMediaParams = (options) => {
  const {
    authState,
    audio = true,
    video = true,
    sendAudio,
    sendVideo,
    receiveAudio,
    receiveVideo
  } = options;
  getLogger14().debug("getJoinMediaParams options", __spreadValues({}, options));
  const { audio_allowed, video_allowed, join_as } = authState;
  const joinAs = join_as != null ? join_as : "member";
  const canSend = joinAs === "member";
  const canSendAudio = canSend && audio_allowed === "both";
  const canSendVideo = canSend && video_allowed === "both";
  const canReceiveAudio = audio_allowed !== "none";
  const canReceiveVideo = video_allowed !== "none";
  const reqToSendAudio = Boolean(sendAudio != null ? sendAudio : audio);
  const reqToSendVideo = Boolean(sendVideo != null ? sendVideo : video);
  const reqToReceiveAudio = Boolean(receiveAudio != null ? receiveAudio : audio);
  const reqToReceiveVideo = Boolean(receiveVideo != null ? receiveVideo : video);
  if (!canSendAudio && reqToSendAudio) {
    getLogger14().info("Not allowed to send audio on this room. Default values will be used.");
  }
  if (!canSendVideo && reqToSendVideo) {
    getLogger14().info("Not allowed to send video on this room. Default values will be used.");
  }
  if (!canReceiveAudio && reqToReceiveAudio) {
    getLogger14().info("Not allowed to receive video from the room. Default values will be used.");
  }
  if (!canReceiveVideo && reqToReceiveVideo) {
    getLogger14().info("Not allowed to receive video from the room. Default values will be used.");
  }
  return {
    mustSendAudio: canSendAudio && reqToSendAudio,
    mustSendVideo: canSendVideo && reqToSendVideo,
    mustRecvAudio: canReceiveAudio && reqToReceiveAudio,
    mustRecvVideo: canReceiveVideo && reqToReceiveVideo
  };
};
var checkMediaParams = (options) => {
  return Object.values(options).some(Boolean);
};

// src/RoomSession.ts
var UNSAFE_PROP_ACCESS = [
  "audioMute",
  "audioUnmute",
  "deaf",
  "getLayouts",
  "getMembers",
  "getRecordings",
  "hideVideoMuted",
  "leave",
  "removerMember",
  "restoreOutboundAudio",
  "restoreOutboundVideo",
  "setInputSensitivity",
  "setInputVolume",
  "setLayout",
  "setPositions",
  "setMemberPosition",
  "setOutputVolume",
  "showVideoMuted",
  "startRecording",
  "stopOutboundAudio",
  "stopOutboundVideo",
  "undeaf",
  "videoMute",
  "videoUnmute",
  "setMicrophoneVolume",
  "setSpeakerVolume",
  "getMeta",
  "setMeta",
  "updateMeta",
  "deleteMeta",
  "getMemberMeta",
  "setMemberMeta",
  "updateMemberMeta",
  "deleteMemberMeta",
  "promote",
  "demote",
  "lock",
  "unlock"
];
var REQUIRED_EVENTS = [
  "member.joined",
  "layout.changed"
];
var noop2 = () => {
};
var RoomSession = function(roomOptions) {
  const _a = roomOptions, {
    audio: audioFromConstructor = true,
    video: videoFromConstructor = true,
    iceServers,
    rootElement,
    applyLocalVideoOverlay = true,
    mirrorLocalVideoOverlay = false,
    stopCameraWhileMuted = true,
    stopMicrophoneWhileMuted = true,
    speakerId,
    destinationNumber,
    localStream,
    watchMediaPackets,
    watchMediaPacketsTimeout
  } = _a, userOptions = __objRest(_a, [
    "audio",
    "video",
    "iceServers",
    "rootElement",
    "applyLocalVideoOverlay",
    "mirrorLocalVideoOverlay",
    "stopCameraWhileMuted",
    "stopMicrophoneWhileMuted",
    "speakerId",
    "destinationNumber",
    "localStream",
    "watchMediaPackets",
    "watchMediaPacketsTimeout"
  ]);
  const deprecatedParams = ["audio", "video"];
  deprecatedParams.forEach((param) => {
    if (param in roomOptions) {
      getLogger15().warn(`The '${param}' parameter on the RoomSession constructor is deprecated. Set it on the '.join()' function instead.`);
    }
  });
  const allowReattach = (roomOptions == null ? void 0 : roomOptions.reattach) !== false;
  const { callIdKey } = sessionStorageManager(userOptions.token);
  const reattachManager = {
    joined: ({ call_id }) => {
      var _a2;
      if (allowReattach && callIdKey) {
        (_a2 = getStorage()) == null ? void 0 : _a2.setItem(callIdKey, call_id);
      }
    },
    init: () => {
      if (allowReattach) {
        room.on("room.subscribed", reattachManager.joined);
      }
      room.options.prevCallId = reattachManager.getPrevCallId();
    },
    destroy: () => {
      var _a2;
      if (!allowReattach) {
        return;
      }
      room.off("room.subscribed", reattachManager.joined);
      if (callIdKey) {
        (_a2 = getStorage()) == null ? void 0 : _a2.removeItem(callIdKey);
      }
    },
    getPrevCallId: () => {
      var _a2, _b;
      if (!allowReattach || !callIdKey) {
        return;
      }
      return (_b = (_a2 = getStorage()) == null ? void 0 : _a2.getItem(callIdKey)) != null ? _b : void 0;
    }
  };
  const client = createClient(userOptions);
  const room = client.rooms.makeRoomObject({
    negotiateAudio: true,
    negotiateVideo: true,
    iceServers,
    rootElement,
    applyLocalVideoOverlay,
    mirrorLocalVideoOverlay,
    stopCameraWhileMuted,
    stopMicrophoneWhileMuted,
    speakerId,
    destinationNumber,
    localStream,
    watchMediaPackets,
    watchMediaPacketsTimeout,
    prevCallId: reattachManager.getPrevCallId()
  });
  room.once("destroy", () => {
    room.emit("room.left", { reason: room.leaveReason });
    reattachManager.destroy();
    client.disconnect();
  });
  client.session.once("session.disconnected", () => {
    room.destroy();
  });
  const join = (params) => {
    return new Promise(async (resolve, reject) => {
      var _a2, _b;
      try {
        room.attachPreConnectWorkers();
        await client.connect();
        const audio = (_a2 = params == null ? void 0 : params.audio) != null ? _a2 : audioFromConstructor;
        const video = (_b = params == null ? void 0 : params.video) != null ? _b : videoFromConstructor;
        const authState = client._sessionAuthState;
        getLogger15().debug("getJoinMediaParams authState?", authState);
        if (authState && authState.type === "video") {
          const mediaOptions = getJoinMediaParams(__spreadValues({
            authState,
            sendAudio: Boolean(audio),
            sendVideo: Boolean(video)
          }, params));
          if (!checkMediaParams(mediaOptions)) {
            client.disconnect();
            return reject(new Error(`Invalid arguments to join the room. The token used has join_as: '${authState.join_as}'. 
${JSON.stringify(params, null, 2)}
`));
          }
          getLogger15().debug("Set mediaOptions", mediaOptions);
          room.updateMediaOptions({
            audio: mediaOptions.mustSendAudio ? audio || true : false,
            video: mediaOptions.mustSendVideo ? video || true : false,
            negotiateAudio: mediaOptions.mustRecvAudio,
            negotiateVideo: mediaOptions.mustRecvVideo
          });
        }
        room.once("room.subscribed", () => {
          resolve(room);
        });
        reattachManager.init();
        REQUIRED_EVENTS.forEach((event) => room.once(event, noop2));
        await room.join();
      } catch (error) {
        getLogger15().error("RoomSession Join", error);
        client.disconnect();
        reject(error);
      }
    });
  };
  const interceptors = {
    join
  };
  return new Proxy(room, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (!target.active && UNSAFE_PROP_ACCESS.includes(prop)) {
        throw new Error(`Tried to access the property/method "${prop}" before the room was connected. Please call roomSession.join() first.`);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/fabric/buildCall.ts
var buildCall = ({
  strategy,
  params,
  userParams
}) => {
  let obj;
  let start;
  switch (strategy) {
    case "room":
      obj = new RoomSession(__spreadValues({
        token: params.token,
        debug: {
          logWsTraffic: true
        },
        logLevel: "debug",
        watchMediaPackets: false
      }, userParams));
      start = (joinParams) => {
        return new Promise((resolve, reject) => {
          obj.once("room.joined", (params2) => resolve(params2));
          obj.emitter.once("verto.display", (params2) => resolve(params2));
          return obj.join(joinParams).catch((error) => reject(error));
        });
      };
      break;
    default:
      throw new Error(`Unknown strategy: '${strategy}'`);
  }
  const interceptors = {
    start
  };
  return new Proxy(obj, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/fabric/Client.ts
var Client2 = class {
  constructor(options) {
    this.options = options;
    __publicField(this, "httpClient");
    this.httpClient = createHttpClient({
      baseUrl: `https://${this.host}`,
      headers: {
        Authorization: `Bearer ${this.options.accessToken}`
      }
    });
  }
  get host() {
    var _a;
    return (_a = this.options.host) != null ? _a : "fabric.signalwire.com";
  }
  async getAddresses() {
    const path = "/addresses";
    const { body } = await this.httpClient(path);
    const anotherPage = async (url) => {
      const { search } = new URL(url);
      const { body: body2 } = await this.httpClient(`${path}${search}`);
      return buildResult(body2);
    };
    const buildResult = (body2) => {
      return {
        addresses: body2.data,
        nextPage: async () => {
          const { next } = body2.links;
          return next ? anotherPage(next) : void 0;
        },
        prevPage: async () => {
          const { prev } = body2.links;
          return prev ? anotherPage(prev) : void 0;
        }
      };
    };
    return buildResult(body);
  }
  async createCall(_a) {
    var _b = _a, {
      uri
    } = _b, userParams = __objRest(_b, [
      "uri"
    ]);
    const path = "/call";
    const { body } = await this.httpClient(path, {
      method: "POST",
      body: { uri }
    });
    console.log("Dial Response", body);
    return buildCall(__spreadProps(__spreadValues({}, body), {
      userParams: __spreadValues({
        host: this.host.includes("swire") ? "relay.swire.io" : void 0
      }, userParams)
    }));
  }
};

// src/fabric/SWClient.ts
var SWClient = class {
  constructor(options) {
    this.options = options;
    __publicField(this, "httpClient");
    this.httpClient = createHttpClient({
      baseUrl: `https://${this.httpHost}`,
      headers: {
        Authorization: `Bearer ${this.options.accessToken}`
      }
    });
  }
  get httpHost() {
    var _a;
    return (_a = this.options.httpHost) != null ? _a : "fabric.signalwire.com";
  }
  async getAddresses() {
    const path = "/addresses";
    const { body } = await this.httpClient(path);
    const anotherPage = async (url) => {
      const { search } = new URL(url);
      const { body: body2 } = await this.httpClient(`${path}${search}`);
      return buildResult(body2);
    };
    const buildResult = (body2) => {
      return {
        addresses: body2.data,
        nextPage: async () => {
          const { next } = body2.links;
          return next ? anotherPage(next) : void 0;
        },
        prevPage: async () => {
          const { prev } = body2.links;
          return prev ? anotherPage(prev) : void 0;
        }
      };
    };
    return buildResult(body);
  }
  async registerDevice({ deviceType, deviceToken }) {
    const path = "/subscriber/devices";
    const { body } = await this.httpClient(path, {
      method: "POST",
      body: {
        device_type: deviceType,
        device_token: deviceToken
      }
    });
    return body;
  }
  async unregisterDevice({ id }) {
    const path = `/subscriber/devices/${id}`;
    return await this.httpClient(path, {
      method: "DELETE"
    });
  }
};

// src/fabric/WSClient.ts
import { getLogger as getLogger17, VertoSubscribe } from "@signalwire/core";

// src/fabric/WSClientWorker.ts
import {
  getLogger as getLogger16,
  sagaEffects as sagaEffects6
} from "@signalwire/core";
var WSClientWorker = function* (options) {
  getLogger16().debug("WSClientWorker started");
  const { channels, instance } = options;
  const { swEventChannel } = channels;
  getLogger16().debug("WSClientWorker instance", instance);
  while (true) {
    const action = yield sagaEffects6.take(swEventChannel, (action2) => {
      getLogger16().debug("WSClientWorker action", action2);
      if (action2.type === "webrtc.message") {
        return action2.payload.method === "verto.invite";
      }
      return false;
    });
    getLogger16().debug("Build new call to answer", action);
  }
  getLogger16().trace("WSClientWorker ended");
};

// src/fabric/WSClient.ts
var WSClient = class {
  constructor(options) {
    this.options = options;
    __publicField(this, "wsClient");
    __publicField(this, "logger", getLogger17());
    this.wsClient = createClient({
      host: this.options.host,
      token: this.options.token,
      debug: {
        logWsTraffic: true
      },
      logLevel: "debug"
    });
  }
  connect() {
    this.wsClient.runWorker("WSClientWorker", {
      worker: WSClientWorker
    });
    return this.wsClient.connect();
  }
  disconnect() {
    return this.wsClient.disconnect();
  }
  async dial(params) {
    return new Promise(async (resolve, reject) => {
      try {
        console.log("WSClient dial with:", params);
        await this.connect();
        const call = this.wsClient.rooms.makeRoomObject({
          negotiateAudio: true,
          negotiateVideo: true,
          rootElement: this.options.rootElement,
          applyLocalVideoOverlay: true,
          stopCameraWhileMuted: true,
          stopMicrophoneWhileMuted: true,
          destinationNumber: params.to,
          watchMediaPackets: false,
          nodeId: params.nodeId
        });
        call.once("destroy", () => {
          this.logger.debug("RTC Connection Destroyed");
        });
        this.wsClient.once("session.disconnected", () => {
          this.logger.debug("Session Disconnected");
        });
        call.attachPreConnectWorkers();
        call.start = () => {
          return new Promise(async (resolve2, reject2) => {
            try {
              call.once("verto.display", () => resolve2(call));
              call.once("room.subscribed", () => resolve2(call));
              await call.join();
            } catch (error) {
              getLogger17().error("WSClient call start", error);
              reject2(error);
            }
          });
        };
        resolve(call);
      } catch (error) {
        getLogger17().error("WSClient dial", error);
        reject(error);
      }
    });
  }
  handlePushNotification(payload) {
    return new Promise(async (resolve, reject) => {
      const { decrypted, type } = payload;
      if (type !== "call_invite") {
        this.logger.warn("Unknown notification type", payload);
        return;
      }
      this.logger.debug("handlePushNotification", payload);
      const { params: jsonrpc, node_id: nodeId } = decrypted;
      const {
        params: {
          callID,
          sdp,
          caller_id_name,
          caller_id_number,
          callee_id_name,
          callee_id_number,
          display_direction
        }
      } = jsonrpc;
      this.logger.debug("handlePushNotification data", {
        callID,
        sdp,
        caller_id_name,
        caller_id_number,
        callee_id_name,
        callee_id_number,
        display_direction
      });
      try {
        await this.connect();
        try {
          await this.executeVertoSubscribe(callID, nodeId);
        } catch (error) {
          this.logger.warn("Verto Subscribe", error);
        }
        const call = this.wsClient.rooms.makeRoomObject({
          negotiateAudio: true,
          negotiateVideo: true,
          rootElement: this.options.rootElement,
          applyLocalVideoOverlay: true,
          stopCameraWhileMuted: true,
          stopMicrophoneWhileMuted: true,
          watchMediaPackets: false,
          remoteSdp: sdp,
          prevCallId: callID,
          nodeId
        });
        call.once("destroy", () => {
          getLogger17().debug("RTC Connection Destroyed");
        });
        call.attachPreConnectWorkers();
        getLogger17().debug("Resolving Call", call);
        resolve({ resultType: "inboundCall", resultObject: call });
      } catch (error) {
        reject(error);
      }
    });
  }
  async executeVertoSubscribe(callId, nodeId) {
    try {
      return await this.wsClient.execute({
        method: "webrtc.verto",
        params: {
          callID: callId,
          node_id: nodeId,
          subscribe: [],
          message: VertoSubscribe({
            sessid: callId,
            eventChannel: []
          })
        }
      });
    } catch (error) {
      this.logger.warn("The call is not available anymore", callId);
      throw error;
    }
  }
  updateToken(token) {
    return new Promise((resolve, reject) => {
      this.wsClient.once("session.auth_error", (error) => {
        reject(error);
      });
      this.wsClient.once("session.connected", () => {
        resolve();
      });
      this.wsClient.reauthenticate(token);
    });
  }
};

// src/fabric/HTTPClient.ts
var HTTPClient = class {
  constructor(options) {
    this.options = options;
    __publicField(this, "httpClient");
    this.httpClient = createHttpClient({
      baseUrl: `https://${this.httpHost}`,
      headers: {
        Authorization: `Bearer ${this.options.token}`
      }
    });
  }
  get httpHost() {
    const { host } = this.options;
    if (!host) {
      return "fabric.signalwire.com";
    }
    return `fabric.${host.split(".").splice(1).join(".")}`;
  }
  async getAddresses() {
    const path = "/addresses";
    const { body } = await this.httpClient(path);
    const anotherPage = async (url) => {
      const { search } = new URL(url);
      const { body: body2 } = await this.httpClient(`${path}${search}`);
      return buildResult(body2);
    };
    const buildResult = (body2) => {
      return {
        addresses: body2.data,
        nextPage: async () => {
          const { next } = body2.links;
          return next ? anotherPage(next) : void 0;
        },
        prevPage: async () => {
          const { prev } = body2.links;
          return prev ? anotherPage(prev) : void 0;
        }
      };
    };
    return buildResult(body);
  }
  async registerDevice({
    deviceType,
    deviceToken
  }) {
    const path = "/subscriber/devices";
    const { body } = await this.httpClient(path, {
      method: "POST",
      body: {
        device_type: deviceType,
        device_token: deviceToken
      }
    });
    return body;
  }
  async unregisterDevice({ id }) {
    const path = `/subscriber/devices/${id}`;
    return await this.httpClient(path, {
      method: "DELETE"
    });
  }
};

// src/fabric/SignalWire.ts
var SignalWire = (options) => {
  return new Promise(async (resolve, reject) => {
    try {
      const httpClient = new HTTPClient(options);
      const wsClient = new WSClient(options);
      resolve({
        httpHost: httpClient.httpHost,
        getAddresses: httpClient.getAddresses.bind(httpClient),
        registerDevice: httpClient.registerDevice.bind(httpClient),
        unregisterDevice: httpClient.unregisterDevice.bind(httpClient),
        connect: wsClient.connect.bind(wsClient),
        disconnect: wsClient.disconnect.bind(wsClient),
        dial: wsClient.dial.bind(wsClient),
        handlePushNotification: wsClient.handlePushNotification.bind(wsClient),
        updateToken: wsClient.updateToken.bind(wsClient),
        __httpClient: httpClient,
        __wsClient: wsClient
      });
    } catch (error) {
      reject(error);
    }
  });
};

// src/chat/index.ts
var chat_exports = {};
__export(chat_exports, {
  ChatMember: () => ChatMember,
  ChatMessage: () => ChatMessage,
  Client: () => Client3
});

// src/chat/Client.ts
var INTERCEPTED_METHODS = [
  "subscribe",
  "publish",
  "getMessages",
  "getMembers",
  "getMemberState",
  "getAllowedChannels",
  "setMemberState"
];
var Client3 = function(chatOptions) {
  const client = createClient(chatOptions);
  const createInterceptor = (prop) => {
    return async (...params) => {
      await client.connect();
      return client.chat[prop](...params);
    };
  };
  const interceptors = {
    _session: client,
    disconnect: () => client.disconnect()
  };
  return new Proxy(client.chat, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (INTERCEPTED_METHODS.includes(prop)) {
        return createInterceptor(prop);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/chat/index.ts
import { ChatMember, ChatMessage } from "@signalwire/core";

// src/pubSub/index.ts
var pubSub_exports = {};
__export(pubSub_exports, {
  Client: () => Client4,
  PubSubMessage: () => PubSubMessage
});
import { PubSub } from "@signalwire/core";

// src/utils/interfaces.ts
import { INTERNAL_MEMBER_UPDATABLE_PROPS } from "@signalwire/core";
var INTERNAL_MEMBER_UPDATED_EVENTS = Object.keys(INTERNAL_MEMBER_UPDATABLE_PROPS).map((key) => {
  return `member.updated.${key}`;
});

// src/pubSub/Client.ts
var INTERCEPTED_METHODS2 = [
  "getAllowedChannels",
  "subscribe",
  "publish"
];
var Client4 = function(pubSubOptions) {
  const client = createClient(pubSubOptions);
  const createInterceptor = (prop) => {
    return async (...params) => {
      await client.connect();
      return client.pubSub[prop](...params);
    };
  };
  const interceptors = {
    _session: client,
    disconnect: () => client.disconnect()
  };
  return new Proxy(client.pubSub, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (INTERCEPTED_METHODS2.includes(prop)) {
        return createInterceptor(prop);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/pubSub/index.ts
var PubSubMessage = PubSub.PubSubMessage;

// src/webrtc.ts
var webrtc_exports = {};
__export(webrtc_exports, {
  checkCameraPermissions: () => checkCameraPermissions,
  checkMicrophonePermissions: () => checkMicrophonePermissions,
  checkPermissions: () => checkPermissions,
  checkSpeakerPermissions: () => checkSpeakerPermissions,
  createCameraDeviceWatcher: () => createCameraDeviceWatcher,
  createDeviceWatcher: () => createDeviceWatcher,
  createMicrophoneAnalyzer: () => createMicrophoneAnalyzer,
  createMicrophoneDeviceWatcher: () => createMicrophoneDeviceWatcher,
  createSpeakerDeviceWatcher: () => createSpeakerDeviceWatcher2,
  enumerateDevices: () => enumerateDevices,
  getCameraDevices: () => getCameraDevices,
  getCameraDevicesWithPermissions: () => getCameraDevicesWithPermissions,
  getDevices: () => getDevices,
  getDevicesWithPermissions: () => getDevicesWithPermissions,
  getDisplayMedia: () => getDisplayMedia2,
  getMicrophoneDevices: () => getMicrophoneDevices,
  getMicrophoneDevicesWithPermissions: () => getMicrophoneDevicesWithPermissions,
  getSpeakerDevices: () => getSpeakerDevices,
  getSpeakerDevicesWithPermissions: () => getSpeakerDevicesWithPermissions,
  getSupportedConstraints: () => getSupportedConstraints,
  getUserMedia: () => getUserMedia,
  requestPermissions: () => requestPermissions,
  setMediaElementSinkId: () => setMediaElementSinkId2,
  stopStream: () => stopStream,
  stopTrack: () => stopTrack,
  supportsGetDisplayMedia: () => supportsGetDisplayMedia,
  supportsGetUserMedia: () => supportsGetUserMedia,
  supportsMediaDevices: () => supportsMediaDevices,
  supportsMediaOutput: () => supportsMediaOutput2
});
import {
  getDevices,
  getCameraDevices,
  getMicrophoneDevices,
  getSpeakerDevices,
  getDevicesWithPermissions,
  getCameraDevicesWithPermissions,
  getMicrophoneDevicesWithPermissions,
  getSpeakerDevicesWithPermissions,
  checkPermissions,
  checkCameraPermissions,
  checkMicrophonePermissions,
  checkSpeakerPermissions,
  requestPermissions,
  createDeviceWatcher,
  createCameraDeviceWatcher,
  createMicrophoneDeviceWatcher,
  createSpeakerDeviceWatcher as createSpeakerDeviceWatcher2,
  supportsMediaDevices,
  supportsGetUserMedia,
  supportsGetDisplayMedia,
  getUserMedia,
  getDisplayMedia as getDisplayMedia2,
  enumerateDevices,
  getSupportedConstraints,
  supportsMediaOutput as supportsMediaOutput2,
  setMediaElementSinkId as setMediaElementSinkId2,
  stopStream,
  stopTrack,
  createMicrophoneAnalyzer
} from "@signalwire/webrtc";
export {
  chat_exports as Chat,
  fabric_exports as Fabric,
  pubSub_exports as PubSub,
  SWClient,
  SignalWire,
  video_exports as Video,
  webrtc_exports as WebRTC
};
//# sourceMappingURL=index.esm.js.map
