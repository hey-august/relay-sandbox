var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Chat: () => chat_exports,
  Fabric: () => fabric_exports,
  PubSub: () => pubSub_exports,
  SWClient: () => SWClient,
  SignalWire: () => SignalWire,
  Video: () => video_exports,
  WebRTC: () => webrtc_exports
});
module.exports = __toCommonJS(src_exports);

// src/fabric/index.ts
var fabric_exports = {};
__export(fabric_exports, {
  Client: () => Client2,
  SWClient: () => SWClient,
  SignalWire: () => SignalWire,
  WSClient: () => WSClient
});

// src/fabric/createHttpClient.ts
var import_core = require("@signalwire/core");
function http(input, init) {
  return __async(this, null, function* () {
    const response = yield fetch(input, init);
    if (!response.ok) {
      if (response.status === 401) {
        throw new import_core.AuthError(response.status, "Unauthorized");
      }
      let errorResponse;
      try {
        errorResponse = yield response.json();
      } catch (e) {
      }
      const errorMessage = (errorResponse == null ? void 0 : errorResponse.errors) ? JSON.stringify(errorResponse.errors) : "Not Found";
      throw new import_core.HttpError(response.status, errorMessage, errorResponse);
    }
    try {
      response.parsedBody = yield response.json();
    } catch (e) {
    }
    return response;
  });
}
var createHttpClient = (_a, fetcher = http) => {
  var _b = _a, { baseUrl, timeout = 3e4 } = _b, globalOptions = __objRest(_b, ["baseUrl", "timeout"]);
  const apiClient = (path, options) => __async(void 0, null, function* () {
    const headers = __spreadValues(__spreadValues(__spreadValues({}, (options == null ? void 0 : options.body) ? { "Content-Type": "application/json" } : {}), globalOptions.headers), options == null ? void 0 : options.headers);
    const reqInit = getRequestInit(__spreadProps(__spreadValues(__spreadValues({}, globalOptions), options), {
      headers
    }));
    let timerId;
    if (timeout) {
      const controller = new AbortController();
      const signal = controller.signal;
      reqInit.signal = signal;
      timerId = setTimeout(() => {
        controller.abort();
      }, timeout);
    }
    try {
      const response = yield fetcher(getUrl({
        path,
        baseUrl,
        searchParams: options == null ? void 0 : options.searchParams
      }), reqInit);
      return { body: response.parsedBody };
    } catch (e) {
      throw e;
    } finally {
      timerId && clearTimeout(timerId);
    }
  });
  return apiClient;
};
var getBody = (body) => {
  return typeof body === "string" ? body : JSON.stringify(body);
};
var getRequestInit = (options) => {
  return Object.entries(options).reduce((reducer, [key, value]) => {
    if (key === "body") {
      return __spreadProps(__spreadValues({}, reducer), {
        body: getBody(value)
      });
    } else if (value != void 0) {
      return __spreadProps(__spreadValues({}, reducer), {
        [key]: value
      });
    }
    return reducer;
  }, {});
};
var getUrl = ({
  path,
  baseUrl,
  searchParams
}) => {
  const url = new URL(path, baseUrl);
  if (searchParams) {
    Object.entries(searchParams).forEach(([key, value]) => {
      if (value != void 0) {
        url.searchParams.append(key, value);
      }
    });
  }
  return url.toString();
};

// src/video.ts
var video_exports = {};
__export(video_exports, {
  RoomSession: () => RoomSession,
  createClient: () => createClient,
  createRoomObject: () => createRoomObject,
  joinRoom: () => joinRoom
});

// src/createRoomObject.ts
var import_core23 = require("@signalwire/core");

// src/createClient.ts
var import_core22 = require("@signalwire/core");

// src/Client.ts
var import_core18 = require("@signalwire/core");

// src/features/mediaElements/mediaElementsSagas.ts
var import_core4 = require("@signalwire/core");
var import_webrtc = require("@signalwire/webrtc");

// src/utils/videoElement.ts
var import_core2 = require("@signalwire/core");
var addSDKPrefix = (input) => {
  return `sw-sdk-${input}`;
};
var buildVideo = () => {
  const video = document.createElement("video");
  video.muted = true;
  video.autoplay = true;
  video.playsInline = true;
  video.addEventListener("pause", () => {
    video.play().catch((error) => {
      (0, import_core2.getLogger)().error("Video Element Paused", video, error);
    });
  });
  return video;
};
var waitForVideoReady = ({ element }) => {
  return new Promise((resolve) => {
    element.addEventListener("canplay", function listener() {
      element.removeEventListener("canplay", listener);
      resolve();
    });
    element.addEventListener("resize", function listener() {
      element.removeEventListener("resize", listener);
      resolve();
    });
  });
};
var _getLocationStyles = ({
  x,
  y,
  width,
  height
}) => {
  return {
    top: `${y}%`,
    left: `${x}%`,
    width: `${width}%`,
    height: `${height}%`
  };
};
var _buildLayer = ({ location }) => {
  const { top, left, width, height } = _getLocationStyles(location);
  const layer = document.createElement("div");
  layer.style.position = "absolute";
  layer.style.overflow = "hidden";
  layer.style.top = top;
  layer.style.left = left;
  layer.style.width = width;
  layer.style.height = height;
  return layer;
};
var makeLayoutChangedHandler = ({ localOverlay, rootElement }) => (_0) => __async(void 0, [_0], function* ({ layout, myMemberId, localStream }) {
  (0, import_core2.getLogger)().debug("Process layout.changed");
  try {
    const { layers = [] } = layout;
    const location = layers.find(({ member_id }) => member_id === myMemberId);
    let myLayer = localOverlay.domElement;
    localOverlay.status = location ? "visible" : "hidden";
    if (!location) {
      (0, import_core2.getLogger)().debug("Location not found");
      if (myLayer) {
        (0, import_core2.getLogger)().debug("Current layer not visible");
        localOverlay.hide();
      }
      return;
    }
    if (!myLayer) {
      (0, import_core2.getLogger)().debug("Build myLayer");
      myLayer = _buildLayer({ location });
      myLayer.id = localOverlay.id;
      const localVideo = buildVideo();
      localVideo.srcObject = localStream;
      localVideo.disablePictureInPicture = true;
      localVideo.style.width = "100%";
      localVideo.style.height = "100%";
      localVideo.style.pointerEvents = "none";
      localVideo.style.objectFit = "cover";
      myLayer.appendChild(localVideo);
      const mcuLayers = rootElement.querySelector(".mcuLayers");
      const exists = mcuLayers == null ? void 0 : mcuLayers.querySelector(`#${myLayer.id}`);
      if (mcuLayers && !exists) {
        (0, import_core2.getLogger)().debug("Build myLayer append it");
        mcuLayers.appendChild(myLayer);
        localOverlay.domElement = myLayer;
        localOverlay.setLocalOverlayMirror();
        return;
      }
      (0, import_core2.getLogger)().debug("Build myLayer >> wait next");
      return;
    }
    const { top, left, width, height } = _getLocationStyles(location);
    (0, import_core2.getLogger)().debug("Update myLayer:", top, left, width, height);
    const hasVideo = localStream.getVideoTracks().filter((t) => t.enabled && t.readyState === "live").length > 0;
    if (hasVideo) {
      localOverlay.setLocalOverlayMediaStream(localStream);
    }
    myLayer.style.opacity = hasVideo ? "1" : "0";
    myLayer.style.top = top;
    myLayer.style.left = left;
    myLayer.style.width = width;
    myLayer.style.height = height;
  } catch (error) {
    (0, import_core2.getLogger)().error("Layout Changed Error", error);
  }
});
var cleanupElement = (rootElement) => {
  while (rootElement.firstChild) {
    rootElement.removeChild(rootElement.firstChild);
  }
};
var setVideoMediaTrack = ({
  track,
  element
}) => {
  element.srcObject = new MediaStream([track]);
  track.addEventListener("ended", () => {
    element.srcObject = null;
    element.remove();
  });
};
var createRootElementResizeObserver = ({
  video,
  rootElement,
  paddingWrapper
}) => {
  const computePaddingWrapperWidth = (width, height) => {
    const nativeVideoRatio = video.videoWidth / video.videoHeight;
    const rootElementRatio = width / height;
    if (nativeVideoRatio > rootElementRatio) {
      return "100%";
    } else {
      return `${height * nativeVideoRatio}px`;
    }
  };
  const maxPaddingBottom = video.videoHeight / video.videoWidth * 100;
  const update = (0, import_core2.debounce)(({ width, height }) => {
    if (paddingWrapper) {
      const pb = height / width * 100;
      paddingWrapper.style.paddingBottom = `${pb > maxPaddingBottom ? maxPaddingBottom : pb}%`;
      paddingWrapper.style.width = computePaddingWrapperWidth(width, height);
    }
  }, 100);
  const observer = new ResizeObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.contentBoxSize) {
        const { inlineSize, blockSize } = Array.isArray(entry.contentBoxSize) ? entry.contentBoxSize[0] : entry.contentBoxSize;
        update({ width: inlineSize, height: blockSize });
      } else if (entry.contentRect) {
        update({
          width: entry.contentRect.width,
          height: entry.contentRect.height
        });
      }
    });
  });
  return {
    start: () => observer.observe(rootElement),
    stop: () => observer.disconnect()
  };
};

// src/utils/audioElement.ts
var setAudioMediaTrack = ({
  track,
  element
}) => {
  element.autoplay = true;
  element.playsinline = true;
  element.srcObject = new MediaStream([track]);
  track.addEventListener("ended", () => {
    element.srcObject = null;
    element.remove();
  });
  return element;
};

// src/features/actions.ts
var import_core3 = require("@signalwire/core");
var audioSetSpeakerAction = import_core3.actions.createAction("swJs/audioSetSpeakerAction");

// src/features/mediaElements/mediaElementsSagas.ts
var makeVideoElementSaga = ({
  rootElement,
  applyLocalVideoOverlay
}) => {
  return function* videoElementSaga({
    instance: room,
    runSaga
  }) {
    try {
      const layerMap = /* @__PURE__ */ new Map();
      const videoEl = buildVideo();
      const localOverlay = {
        status: "hidden",
        get id() {
          return addSDKPrefix(room.id);
        },
        get domElement() {
          return layerMap.get(this.id);
        },
        set domElement(element) {
          if (element) {
            (0, import_core4.getLogger)().debug("Set localOverlay", element);
            layerMap.set(this.id, element);
          } else {
            (0, import_core4.getLogger)().debug("Remove localOverlay");
            layerMap.delete(this.id);
          }
        },
        hide() {
          if (!this.domElement) {
            return (0, import_core4.getLogger)().warn("Missing localOverlay to hide");
          }
          this.domElement.style.opacity = "0";
        },
        show() {
          if (!this.domElement) {
            return (0, import_core4.getLogger)().warn("Missing localOverlay to show");
          }
          if (this.status === "hidden") {
            return (0, import_core4.getLogger)().info("localOverlay not visible");
          }
          this.domElement.style.opacity = "1";
        },
        setLocalOverlayMediaStream(stream) {
          if (!this.domElement) {
            return (0, import_core4.getLogger)().warn("Missing localOverlay to set the local overlay stream");
          }
          const localVideo = this.domElement.querySelector("video");
          if (localVideo) {
            localVideo.srcObject = stream;
          }
        },
        setLocalOverlayMirror(mirror) {
          if (!this.domElement || !this.domElement.firstChild) {
            return (0, import_core4.getLogger)().warn("Missing localOverlay to set the mirror");
          }
          const videoEl2 = this.domElement.firstChild;
          if (mirror != null ? mirror : room.localOverlay.mirrored) {
            videoEl2.style.transform = "scale(-1, 1)";
            videoEl2.style.webkitTransform = "scale(-1, 1)";
          } else {
            videoEl2.style.transform = "scale(1, 1)";
            videoEl2.style.webkitTransform = "scale(1, 1)";
          }
        }
      };
      const layoutChangedHandler = makeLayoutChangedHandler({
        rootElement,
        localOverlay
      });
      let hasVideoTrack = false;
      let lastLayoutChanged = null;
      const _processLayoutChanged = (params) => {
        var _a;
        if (((_a = room.peer) == null ? void 0 : _a.hasVideoSender) && room.localStream) {
          layoutChangedHandler({
            layout: params.layout,
            localStream: room.localStream,
            myMemberId: room.memberId
          });
        } else {
          localOverlay.hide();
        }
      };
      room.on(`${import_core4.LOCAL_EVENT_PREFIX}.mirror.video`, (value) => {
        localOverlay.setLocalOverlayMirror(value);
      });
      room.on("layout.changed", (params) => {
        (0, import_core4.getLogger)().debug("Received layout.changed - videoTrack", hasVideoTrack);
        if (hasVideoTrack) {
          _processLayoutChanged(params);
          return;
        }
        lastLayoutChanged = params;
      });
      room.on("room.subscribed", (params) => {
        var _a;
        const member = (_a = params.room_session.members) == null ? void 0 : _a.find((m) => m.id === room.memberId);
        if (member == null ? void 0 : member.audio_muted) {
          try {
            room.stopOutboundAudio();
          } catch (error) {
            (0, import_core4.getLogger)().error("Error handling audio_muted", error);
          }
        }
        if (member == null ? void 0 : member.video_muted) {
          try {
            room.stopOutboundVideo();
          } catch (error) {
            (0, import_core4.getLogger)().error("Error handling video_muted", error);
          }
        }
        if (room.localStream) {
          localOverlay.setLocalOverlayMediaStream(room.localStream);
        }
      });
      room.on("member.updated.video_muted", (params) => {
        try {
          const { member } = params;
          if (member.id === room.memberId && "video_muted" in member) {
            member.video_muted ? localOverlay.hide() : localOverlay.show();
          }
        } catch (error) {
          (0, import_core4.getLogger)().error("Error handling video_muted", error);
        }
      });
      let videoTask;
      const trackHandler = function(event) {
        switch (event.track.kind) {
          case "video": {
            videoTask = runSaga(videoElementSetupWorker, {
              applyLocalVideoOverlay,
              rootElement,
              track: event.track,
              element: videoEl
            });
            hasVideoTrack = true;
            if (lastLayoutChanged) {
              _processLayoutChanged(lastLayoutChanged);
            }
            break;
          }
        }
      };
      room.on("track", trackHandler);
      room.once("destroy", () => {
        cleanupElement(rootElement);
        layerMap.clear();
        videoTask == null ? void 0 : videoTask.cancel();
      });
    } catch (error) {
      (0, import_core4.getLogger)().error("videoElementSaga", error);
    }
  };
};
var makeAudioElementSaga = ({ speakerId }) => {
  return function* audioElementSaga({
    instance: room,
    runSaga
  }) {
    if (typeof Audio === "undefined") {
      (0, import_core4.getLogger)().warn("`Audio` is not supported on this environment.");
      return;
    }
    try {
      const audioEl = room.getAudioEl();
      let audioTask;
      const trackHandler = function(event) {
        switch (event.track.kind) {
          case "audio": {
            audioTask = runSaga(audioElementSetupWorker, {
              track: event.track,
              element: audioEl,
              speakerId,
              room
            });
            break;
          }
        }
      };
      room.on("track", trackHandler);
      room.once("destroy", () => {
        audioTask == null ? void 0 : audioTask.cancel();
      });
    } catch (error) {
      (0, import_core4.getLogger)().error("audioElementSaga", error);
    }
  };
};
function* audioElementActionsWatcher({
  element,
  room
}) {
  const setSpeakerActionType = import_core4.actions.getCustomSagaActionType(room.__uuid, audioSetSpeakerAction);
  while (true) {
    const action = yield import_core4.sagaEffects.take([setSpeakerActionType]);
    try {
      switch (action.type) {
        case setSpeakerActionType:
          const response = yield import_core4.sagaEffects.call(import_webrtc.setMediaElementSinkId, element, action.payload);
          room.emit(`${import_core4.LOCAL_EVENT_PREFIX}.speaker.updated`, action.payload);
          room.settleCustomSagaTrigger({
            dispatchId: action.dispatchId,
            payload: response,
            kind: "resolve"
          });
          break;
      }
    } catch (error) {
      room.settleCustomSagaTrigger({
        dispatchId: action.dispatchId,
        payload: error,
        kind: "reject"
      });
      (0, import_core4.getLogger)().error(error);
    }
  }
}
function* audioElementSetupWorker({
  track,
  element,
  speakerId,
  room
}) {
  setAudioMediaTrack({ track, element });
  if (speakerId) {
    (0, import_webrtc.setMediaElementSinkId)(element, speakerId).catch(() => {
    });
  }
  yield import_core4.sagaEffects.fork(audioElementActionsWatcher, {
    element,
    room
  });
}
function* videoElementSetupWorker({
  rootElement,
  applyLocalVideoOverlay = true,
  track,
  element
}) {
  try {
    setVideoMediaTrack({ element, track });
    element.style.width = "100%";
    element.style.maxHeight = "100%";
    if (!applyLocalVideoOverlay) {
      rootElement.appendChild(element);
      return;
    }
    if (rootElement.querySelector(".mcuContent")) {
      (0, import_core4.getLogger)().debug("MCU Content already there");
      return;
    }
    const mcuWrapper = document.createElement("div");
    mcuWrapper.style.position = "absolute";
    mcuWrapper.style.top = "0";
    mcuWrapper.style.left = "0";
    mcuWrapper.style.right = "0";
    mcuWrapper.style.bottom = "0";
    mcuWrapper.appendChild(element);
    const paddingWrapper = document.createElement("div");
    paddingWrapper.classList.add("paddingWrapper");
    paddingWrapper.style.paddingBottom = "56.25%";
    paddingWrapper.style.position = "relative";
    paddingWrapper.style.width = "100%";
    paddingWrapper.appendChild(mcuWrapper);
    const layersWrapper = document.createElement("div");
    layersWrapper.classList.add("mcuLayers");
    layersWrapper.style.display = "none";
    paddingWrapper.appendChild(layersWrapper);
    const relativeWrapper = document.createElement("div");
    relativeWrapper.classList.add("mcuContent");
    relativeWrapper.style.position = "relative";
    relativeWrapper.style.width = "100%";
    relativeWrapper.style.height = "100%";
    relativeWrapper.style.margin = "0 auto";
    relativeWrapper.style.display = "flex";
    relativeWrapper.style.alignItems = "center";
    relativeWrapper.style.justifyContent = "center";
    relativeWrapper.appendChild(paddingWrapper);
    rootElement.style.width = "100%";
    rootElement.style.height = "100%";
    rootElement.appendChild(relativeWrapper);
    (0, import_core4.getLogger)().debug("MCU readyState 1 >>", element.readyState);
    if (element.readyState === HTMLMediaElement.HAVE_NOTHING) {
      (0, import_core4.getLogger)().debug("Wait for the MCU to be ready");
      yield import_core4.sagaEffects.call(waitForVideoReady, { element });
    }
    (0, import_core4.getLogger)().debug("MCU is ready..");
    const rootElementResizeObserver = createRootElementResizeObserver({
      rootElement,
      video: element,
      paddingWrapper
    });
    rootElementResizeObserver.start();
    track.addEventListener("ended", () => {
      if (rootElementResizeObserver) {
        rootElementResizeObserver.stop();
      }
    });
    layersWrapper.style.display = "block";
  } catch (error) {
    (0, import_core4.getLogger)().error("Handle video track error", error);
  }
}

// src/BaseRoomSession.ts
var import_core13 = require("@signalwire/core");
var import_webrtc4 = require("@signalwire/webrtc");

// src/utils/constants.ts
var SCREENSHARE_AUDIO_CONSTRAINTS = {
  echoCancellation: true,
  noiseSuppression: false,
  autoGainControl: false,
  googAutoGainControl: false
};

// src/RoomSessionScreenShare.ts
var import_core5 = require("@signalwire/core");
var import_webrtc2 = require("@signalwire/webrtc");
var RoomSessionScreenShareConnection = class extends import_webrtc2.BaseConnection {
  join() {
    return super.invite();
  }
  leave() {
    return super.hangup();
  }
};
var RoomSessionScreenShareAPI = (0, import_core5.extendComponent)(RoomSessionScreenShareConnection, {
  audioMute: import_core5.Rooms.audioMuteMember,
  audioUnmute: import_core5.Rooms.audioUnmuteMember,
  videoMute: import_core5.Rooms.videoMuteMember,
  videoUnmute: import_core5.Rooms.videoUnmuteMember,
  setMicrophoneVolume: import_core5.Rooms.setInputVolumeMember,
  setInputVolume: import_core5.Rooms.setInputVolumeMember,
  setInputSensitivity: import_core5.Rooms.setInputSensitivityMember
});

// src/RoomSessionDevice.ts
var import_core6 = require("@signalwire/core");
var import_webrtc3 = require("@signalwire/webrtc");
var RoomSessionDeviceConnection = class extends import_webrtc3.BaseConnection {
  join() {
    return super.invite();
  }
  leave() {
    return super.hangup();
  }
};
var RoomSessionDeviceAPI = (0, import_core6.extendComponent)(RoomSessionDeviceConnection, {
  audioMute: import_core6.Rooms.audioMuteMember,
  audioUnmute: import_core6.Rooms.audioUnmuteMember,
  videoMute: import_core6.Rooms.videoMuteMember,
  videoUnmute: import_core6.Rooms.videoUnmuteMember,
  setInputVolume: import_core6.Rooms.setInputVolumeMember,
  setMicrophoneVolume: import_core6.Rooms.setInputVolumeMember,
  setInputSensitivity: import_core6.Rooms.setInputSensitivityMember
});

// src/video/memberListUpdatedWorker.ts
var import_core7 = require("@signalwire/core");
var noop = () => {
};
var EXTERNAL_MEMBER_LIST_UPDATED_EVENT = "memberList.updated";
var INTERNAL_MEMBER_LIST_UPDATED_EVENT = (0, import_core7.toInternalEventName)({
  event: EXTERNAL_MEMBER_LIST_UPDATED_EVENT
});
var SYNTHETIC_MEMBER_LIST_UPDATED_EVENT = (0, import_core7.toSyntheticEvent)(INTERNAL_MEMBER_LIST_UPDATED_EVENT);
var MEMBER_LIST_EVENTS = [
  "video.room.joined",
  "video.member.joined",
  "video.member.left",
  "video.member.updated"
];
var isMemberListEvent = (event) => {
  return MEMBER_LIST_EVENTS.includes(event);
};
var getMemberListEventsToSubscribe = (subscriptions) => {
  return (0, import_core7.validateEventsToSubscribe)(MEMBER_LIST_EVENTS).filter((event) => {
    return !subscriptions.includes(event);
  });
};
var shouldHandleMemberList = (subscriptions) => {
  return subscriptions.some((event) => event.includes(EXTERNAL_MEMBER_LIST_UPDATED_EVENT));
};
var getMembersFromAction = (action) => {
  if (action.type === "video.room.joined") {
    return action.payload.room_session.members;
  }
  return [action.payload.member];
};
var getUpdatedMembers = ({
  action,
  memberList
}) => {
  const actionMembers = getMembersFromAction(action);
  switch (action.type) {
    case "video.member.left":
      actionMembers.forEach((member) => {
        memberList.delete(member.id);
      });
      break;
    default:
      actionMembers.forEach((member) => {
        memberList.set(member.id, member);
      });
  }
  return Array.from(memberList.values());
};
var initMemberListSubscriptions = (room, subscriptions) => {
  const events = getMemberListEventsToSubscribe(subscriptions);
  events.forEach((event) => {
    room.once(event, noop);
  });
  const eventBridgeHandler = ({ members }) => {
    room.emit(EXTERNAL_MEMBER_LIST_UPDATED_EVENT, { members });
  };
  room.on(SYNTHETIC_MEMBER_LIST_UPDATED_EVENT, eventBridgeHandler);
  const cleanup = () => {
    room.off(SYNTHETIC_MEMBER_LIST_UPDATED_EVENT, eventBridgeHandler);
  };
  return {
    cleanup
  };
};
function* membersListUpdatedWatcher({
  swEventChannel,
  instance
}) {
  const memberList = /* @__PURE__ */ new Map();
  function* worker(pubSubAction) {
    const roomSessionId = pubSubAction.type === "video.room.joined" ? pubSubAction.payload.room_session.id : pubSubAction.payload.room_session_id;
    const members = getUpdatedMembers({ action: pubSubAction, memberList });
    const memberListPayload = {
      room_session_id: roomSessionId,
      members
    };
    instance.emit(SYNTHETIC_MEMBER_LIST_UPDATED_EVENT, memberListPayload);
  }
  while (true) {
    const pubSubAction = yield import_core7.sagaEffects.take(swEventChannel, ({ type }) => {
      return isMemberListEvent(type);
    });
    yield import_core7.sagaEffects.fork(worker, pubSubAction);
  }
}
var memberListUpdatedWorker = function* membersChangedWorker({
  channels: { swEventChannel },
  instance
}) {
  const subscriptions = instance.getSubscriptions();
  if (!shouldHandleMemberList(subscriptions)) {
    return;
  }
  const { cleanup } = initMemberListSubscriptions(instance, subscriptions);
  yield import_core7.sagaEffects.fork(membersListUpdatedWatcher, {
    swEventChannel,
    instance
  });
  instance.once("destroy", () => {
    cleanup();
  });
};

// src/video/childMemberJoinedWorker.ts
var import_core8 = require("@signalwire/core");
var childMemberJoinedWorker = function* (options) {
  (0, import_core8.getLogger)().trace("childMemberJoinedWorker started");
  const { channels, instance, initialState, onDone, onFail } = options;
  const { swEventChannel } = channels;
  const { parentId } = initialState;
  if (!parentId) {
    throw new Error("Missing parentId for childMemberJoinedWorker");
  }
  const action = yield import_core8.sagaEffects.take(swEventChannel, (action2) => {
    if (action2.type === "video.member.joined") {
      return action2.payload.member.parent_id === parentId;
    }
    return false;
  });
  const { member } = action.payload;
  if (member == null ? void 0 : member.parent_id) {
    const byId = yield import_core8.sagaEffects.select(import_core8.componentSelectors.getComponentsById);
    const parent = Object.values(byId).find((row) => {
      return "memberId" in row && row.memberId === member.parent_id;
    });
    if (parent) {
      yield import_core8.sagaEffects.put(import_core8.componentActions.upsert({
        id: instance.callId,
        roomId: action.payload.room_id,
        roomSessionId: action.payload.room_session_id,
        memberId: member.id
      }));
      onDone == null ? void 0 : onDone();
    } else {
      onFail == null ? void 0 : onFail({ error: new Error("Unknown parent_id") });
    }
  }
  (0, import_core8.getLogger)().trace("childMemberJoinedWorker ended");
};

// src/video/videoWorker.ts
var import_core12 = require("@signalwire/core");

// src/video/videoStreamWorker.ts
var import_core9 = require("@signalwire/core");
var videoStreamWorker = function* (options) {
  (0, import_core9.getLogger)().trace("videoStreamWorker started");
  const {
    instance: roomSession,
    action: { type, payload },
    instanceMap: { get, set, remove }
  } = options;
  let streamInstance = get(payload.stream.id);
  if (!streamInstance) {
    streamInstance = import_core9.Rooms.createRoomSessionStreamObject({
      store: roomSession.store,
      payload
    });
  } else {
    streamInstance.setPayload(payload);
  }
  set(payload.stream.id, streamInstance);
  switch (type) {
    case "video.stream.started":
      roomSession.emit("stream.started", streamInstance);
      break;
    case "video.stream.ended":
      roomSession.emit("stream.ended", streamInstance);
      remove(payload.stream.id);
      break;
    default:
      (0, import_core9.getLogger)().warn(`Unknown video.stream event: "${type}"`);
      break;
  }
  (0, import_core9.getLogger)().trace("videoStreamWorker ended");
};

// src/video/videoRecordWorker.ts
var import_core10 = require("@signalwire/core");
var videoRecordWorker = function* (options) {
  (0, import_core10.getLogger)().trace("videoRecordWorker started");
  const {
    instance: roomSession,
    action: { type, payload },
    instanceMap: { get, set, remove }
  } = options;
  let recordingInstance = get(payload.recording.id);
  if (!recordingInstance) {
    recordingInstance = import_core10.Rooms.createRoomSessionRecordingObject({
      store: roomSession.store,
      payload
    });
  } else {
    recordingInstance.setPayload(payload);
  }
  set(payload.recording.id, recordingInstance);
  const event = (0, import_core10.stripNamespacePrefix)(type);
  switch (type) {
    case "video.recording.started":
    case "video.recording.updated": {
      roomSession.emit(event, recordingInstance);
      break;
    }
    case "video.recording.ended":
      roomSession.emit(event, recordingInstance);
      remove(payload.recording.id);
      break;
    default:
      (0, import_core10.getLogger)().warn(`Unknown video.stream event: "${type}"`);
      break;
  }
  (0, import_core10.getLogger)().trace("videoRecordWorker ended");
};

// src/video/videoPlaybackWorker.ts
var import_core11 = require("@signalwire/core");
var videoPlaybackWorker = function* (options) {
  (0, import_core11.getLogger)().trace("videoPlaybackWorker started");
  const {
    instance: roomSession,
    action: { type, payload },
    instanceMap: { get, set, remove }
  } = options;
  let playbackInstance = get(payload.playback.id);
  if (!playbackInstance) {
    playbackInstance = import_core11.Rooms.createRoomSessionPlaybackObject({
      store: roomSession.store,
      payload
    });
  } else {
    playbackInstance.setPayload(payload);
  }
  set(payload.playback.id, playbackInstance);
  const event = (0, import_core11.stripNamespacePrefix)(type);
  switch (type) {
    case "video.playback.started":
    case "video.playback.updated": {
      roomSession.emit(event, playbackInstance);
      break;
    }
    case "video.playback.ended":
      roomSession.emit(event, playbackInstance);
      remove(payload.playback.id);
      break;
    default:
      (0, import_core11.getLogger)().warn(`Unknown video.stream event: "${type}"`);
      break;
  }
  (0, import_core11.getLogger)().trace("videoPlaybackWorker ended");
};

// src/video/videoWorker.ts
var videoWorker = function* (options) {
  const { channels, instance: roomSession } = options;
  const { swEventChannel } = channels;
  function* worker(action) {
    const { type, payload } = action;
    switch (type) {
      case "video.room.subscribed":
        yield import_core12.sagaEffects.spawn(import_core12.MemberPosition.memberPositionWorker, __spreadProps(__spreadValues({}, options), {
          instance: roomSession,
          initialState: payload
        }));
        break;
      case "video.playback.started":
      case "video.playback.updated":
      case "video.playback.ended":
        yield import_core12.sagaEffects.fork(videoPlaybackWorker, __spreadValues({
          action
        }, options));
        return;
      case "video.recording.started":
      case "video.recording.updated":
      case "video.recording.ended":
        yield import_core12.sagaEffects.fork(videoRecordWorker, __spreadValues({
          action
        }, options));
        return;
      case "video.stream.ended":
      case "video.stream.started":
        yield import_core12.sagaEffects.fork(videoStreamWorker, __spreadValues({
          action
        }, options));
        return;
      case "video.room.audience_count": {
        roomSession.emit("room.audienceCount", payload);
        return;
      }
      case "video.member.talking": {
        const { member } = payload;
        if ("talking" in member) {
          const suffix = member.talking ? "started" : "ended";
          roomSession.emit(`member.talking.${suffix}`, payload);
          const deprecatedSuffix = member.talking ? "start" : "stop";
          roomSession.emit(`member.talking.${deprecatedSuffix}`, payload);
        }
        break;
      }
      default:
        break;
    }
    roomSession.emit((0, import_core12.stripNamespacePrefix)(type), payload);
  }
  const isVideoEvent = (action) => action.type.startsWith("video.");
  while (true) {
    const action = yield import_core12.sagaEffects.take(swEventChannel, isVideoEvent);
    yield import_core12.sagaEffects.fork(worker, action);
  }
  (0, import_core12.getLogger)().trace("videoWorker ended");
};

// src/BaseRoomSession.ts
var RoomSessionConnection = class extends import_webrtc4.BaseConnection {
  constructor(options) {
    super(options);
    __publicField(this, "_screenShareList", /* @__PURE__ */ new Set());
    __publicField(this, "_deviceList", /* @__PURE__ */ new Set());
    __publicField(this, "_mirrored");
    __publicField(this, "_audioEl");
    this._mirrored = options.mirrorLocalVideoOverlay;
    this.runWorker("videoWorker", {
      worker: videoWorker
    });
  }
  get screenShareList() {
    return Array.from(this._screenShareList);
  }
  get deviceList() {
    return Array.from(this._deviceList);
  }
  get interactivityMode() {
    return this.select(({ session }) => {
      var _a;
      const { authState } = session;
      return (_a = authState == null ? void 0 : authState.join_as) != null ? _a : "";
    });
  }
  get permissions() {
    return this.select(({ session }) => {
      var _a, _b;
      const { authState } = session;
      return (_b = (_a = authState == null ? void 0 : authState.room) == null ? void 0 : _a.scopes) != null ? _b : [];
    });
  }
  attachPreConnectWorkers() {
    this.runWorker("memberListUpdated", {
      worker: memberListUpdatedWorker
    });
  }
  createScreenShareObject() {
    return __async(this, arguments, function* (opts = {}) {
      return this.startScreenShare(opts);
    });
  }
  startScreenShare() {
    return __async(this, arguments, function* (opts = {}) {
      return new Promise((resolve, reject) => __async(this, null, function* () {
        var _a;
        const {
          autoJoin = true,
          audio = false,
          video = true,
          layout,
          positions
        } = opts;
        const displayStream = yield (0, import_webrtc4.getDisplayMedia)({
          audio: audio === true ? SCREENSHARE_AUDIO_CONSTRAINTS : audio,
          video
        });
        const options = __spreadProps(__spreadValues({}, this.options), {
          screenShare: true,
          recoverCall: false,
          localStream: displayStream,
          remoteStream: void 0,
          userVariables: __spreadProps(__spreadValues({}, ((_a = this.options) == null ? void 0 : _a.userVariables) || {}), {
            memberCallId: this.callId,
            memberId: this.memberId
          }),
          layout,
          positions
        });
        const screenShare = (0, import_core13.connect)({
          store: this.store,
          Component: RoomSessionScreenShareAPI
        })(options);
        displayStream.getVideoTracks().forEach((t) => {
          t.addEventListener("ended", () => {
            if (screenShare && screenShare.active) {
              screenShare.leave();
            }
          });
        });
        screenShare.once("destroy", () => {
          screenShare.emit("room.left");
          this._screenShareList.delete(screenShare);
        });
        try {
          screenShare.runWorker("childMemberJoinedWorker", {
            worker: childMemberJoinedWorker,
            onDone: () => resolve(screenShare),
            onFail: reject,
            initialState: {
              parentId: this.memberId
            }
          });
          this._screenShareList.add(screenShare);
          if (autoJoin) {
            return yield screenShare.join();
          }
          return resolve(screenShare);
        } catch (error) {
          this.logger.error("ScreenShare Error", error);
          reject(error);
        }
      }));
    });
  }
  addCamera(opts = {}) {
    const _a = opts, { autoJoin = true } = _a, video = __objRest(_a, ["autoJoin"]);
    return this.addDevice({
      autoJoin,
      video
    });
  }
  addMicrophone(opts = {}) {
    const _a = opts, { autoJoin = true } = _a, audio = __objRest(_a, ["autoJoin"]);
    return this.addDevice({
      autoJoin,
      audio
    });
  }
  addDevice() {
    return __async(this, arguments, function* (opts = {}) {
      return new Promise((resolve, reject) => __async(this, null, function* () {
        var _a;
        const { autoJoin = true, audio = false, video = false } = opts;
        if (!audio && !video) {
          throw new TypeError("At least one of `audio` or `video` must be requested.");
        }
        const options = __spreadProps(__spreadValues({}, this.options), {
          localStream: void 0,
          remoteStream: void 0,
          audio,
          video,
          additionalDevice: true,
          recoverCall: false,
          userVariables: __spreadProps(__spreadValues({}, ((_a = this.options) == null ? void 0 : _a.userVariables) || {}), {
            memberCallId: this.callId,
            memberId: this.memberId
          })
        });
        const roomDevice = (0, import_core13.connect)({
          store: this.store,
          Component: RoomSessionDeviceAPI
        })(options);
        roomDevice.once("destroy", () => {
          roomDevice.emit("room.left");
          this._deviceList.delete(roomDevice);
        });
        try {
          roomDevice.runWorker("childMemberJoinedWorker", {
            worker: childMemberJoinedWorker,
            onDone: () => resolve(roomDevice),
            onFail: reject,
            initialState: {
              parentId: this.memberId
            }
          });
          this._deviceList.add(roomDevice);
          if (autoJoin) {
            return yield roomDevice.join();
          }
          return resolve(roomDevice);
        } catch (error) {
          this.logger.error("RoomDevice Error", error);
          reject(error);
        }
      }));
    });
  }
  join() {
    return super.invite();
  }
  leave() {
    return this.hangup();
  }
  updateSpeaker({ deviceId }) {
    const prevId = this._audioEl.sinkId;
    this.once(`${import_core13.LOCAL_EVENT_PREFIX}.speaker.updated`, (newId) => __async(this, null, function* () {
      const prevSpeaker = yield (0, import_webrtc4.getSpeakerById)(prevId);
      const newSpeaker = yield (0, import_webrtc4.getSpeakerById)(newId);
      const isSame = (newSpeaker == null ? void 0 : newSpeaker.deviceId) === (prevSpeaker == null ? void 0 : prevSpeaker.deviceId);
      if (!(newSpeaker == null ? void 0 : newSpeaker.deviceId) || isSame)
        return;
      this.emit("speaker.updated", {
        previous: {
          deviceId: prevSpeaker == null ? void 0 : prevSpeaker.deviceId,
          label: prevSpeaker == null ? void 0 : prevSpeaker.label
        },
        current: {
          deviceId: newSpeaker.deviceId,
          label: newSpeaker.label
        }
      });
    }));
    return this.triggerCustomSaga(audioSetSpeakerAction(deviceId));
  }
  _attachSpeakerTrackListener() {
    if (!(0, import_webrtc4.supportsMediaOutput)())
      return;
    (0, import_webrtc4.createSpeakerDeviceWatcher)().then((deviceWatcher) => {
      deviceWatcher.on("removed", (data) => __async(this, null, function* () {
        var _a, _b;
        const sinkId = this._audioEl.sinkId;
        const disconnectedSpeaker = data.changes.find((device) => {
          const payloadDeviceId = device.payload.deviceId;
          return payloadDeviceId === sinkId || payloadDeviceId === "" && sinkId === "default" || payloadDeviceId === "default" && sinkId === "";
        });
        if (disconnectedSpeaker) {
          this.emit("speaker.disconnected", {
            deviceId: disconnectedSpeaker.payload.deviceId,
            label: disconnectedSpeaker.payload.label
          });
          yield (_b = (_a = this._audioEl).setSinkId) == null ? void 0 : _b.call(_a, "");
          const defaultSpeakers = yield (0, import_webrtc4.getSpeakerById)("default");
          if (!(defaultSpeakers == null ? void 0 : defaultSpeakers.deviceId))
            return;
          this.emit("speaker.updated", {
            previous: {
              deviceId: disconnectedSpeaker.payload.deviceId,
              label: disconnectedSpeaker.payload.label
            },
            current: {
              deviceId: defaultSpeakers.deviceId,
              label: defaultSpeakers.label
            }
          });
        }
      }));
    });
  }
  getAudioEl() {
    if (this._audioEl)
      return this._audioEl;
    this._audioEl = new Audio();
    this._attachSpeakerTrackListener();
    return this._audioEl;
  }
  hangup(id) {
    return __async(this, null, function* () {
      this._screenShareList.forEach((screenShare) => {
        screenShare.leave();
      });
      this._deviceList.forEach((device) => {
        device.leave();
      });
      return __superGet(RoomSessionConnection.prototype, this, "hangup").call(this, id);
    });
  }
  _finalize() {
    this._screenShareList.clear();
    this._deviceList.clear();
    super._finalize();
  }
  getLayoutList() {
    return this.getLayouts();
  }
  getMemberList() {
    return this.getMembers();
  }
  get localOverlay() {
    return {
      mirrored: this._mirrored,
      setMirrored: (value) => {
        this._mirrored = value;
        this.emit(`${import_core13.LOCAL_EVENT_PREFIX}.mirror.video`, this._mirrored);
      }
    };
  }
  getSubscriptions() {
    const eventNamesWithPrefix = this.eventNames().map((event) => `video.${event}`);
    return (0, import_core13.validateEventsToSubscribe)(eventNamesWithPrefix);
  }
};
var RoomSessionAPI = (0, import_core13.extendComponent)(RoomSessionConnection, {
  audioMute: import_core13.Rooms.audioMuteMember,
  audioUnmute: import_core13.Rooms.audioUnmuteMember,
  videoMute: import_core13.Rooms.videoMuteMember,
  videoUnmute: import_core13.Rooms.videoUnmuteMember,
  deaf: import_core13.Rooms.deafMember,
  undeaf: import_core13.Rooms.undeafMember,
  setInputVolume: import_core13.Rooms.setInputVolumeMember,
  setOutputVolume: import_core13.Rooms.setOutputVolumeMember,
  setMicrophoneVolume: import_core13.Rooms.setInputVolumeMember,
  setSpeakerVolume: import_core13.Rooms.setOutputVolumeMember,
  setInputSensitivity: import_core13.Rooms.setInputSensitivityMember,
  removeMember: import_core13.Rooms.removeMember,
  removeAllMembers: import_core13.Rooms.removeAllMembers,
  getMembers: import_core13.Rooms.getMembers,
  getLayouts: import_core13.Rooms.getLayouts,
  setLayout: import_core13.Rooms.setLayout,
  setPositions: import_core13.Rooms.setPositions,
  setMemberPosition: import_core13.Rooms.setMemberPosition,
  hideVideoMuted: import_core13.Rooms.hideVideoMuted,
  showVideoMuted: import_core13.Rooms.showVideoMuted,
  getRecordings: import_core13.Rooms.getRecordings,
  startRecording: import_core13.Rooms.startRecording,
  getPlaybacks: import_core13.Rooms.getPlaybacks,
  play: import_core13.Rooms.play,
  setHideVideoMuted: import_core13.Rooms.setHideVideoMuted,
  getMeta: import_core13.Rooms.getMeta,
  setMeta: import_core13.Rooms.setMeta,
  updateMeta: import_core13.Rooms.updateMeta,
  deleteMeta: import_core13.Rooms.deleteMeta,
  getMemberMeta: import_core13.Rooms.getMemberMeta,
  setMemberMeta: import_core13.Rooms.setMemberMeta,
  updateMemberMeta: import_core13.Rooms.updateMemberMeta,
  deleteMemberMeta: import_core13.Rooms.deleteMemberMeta,
  promote: import_core13.Rooms.promote,
  demote: import_core13.Rooms.demote,
  getStreams: import_core13.Rooms.getStreams,
  startStream: import_core13.Rooms.startStream,
  lock: import_core13.Rooms.lock,
  unlock: import_core13.Rooms.unlock,
  setRaisedHand: import_core13.Rooms.setRaisedHand,
  setPrioritizeHandraise: import_core13.Rooms.setPrioritizeHandraise
});
var createBaseRoomSessionObject = (params) => {
  const room = (0, import_core13.connect)({
    store: params.store,
    customSagas: params.customSagas,
    Component: RoomSessionAPI
  })(params);
  return room;
};

// src/cantina/VideoManager.ts
var import_core17 = require("@signalwire/core");

// src/cantina/workers/videoManagerWorker.ts
var import_core16 = require("@signalwire/core");

// src/cantina/workers/videoManagerRoomsWorker.ts
var import_core14 = require("@signalwire/core");
var videoManagerRoomsWorker = function* (options) {
  (0, import_core14.getLogger)().trace("videoManagerRoomsWorker started");
  const {
    instance: client,
    action: { type, payload }
  } = options;
  const modPayload = {
    rooms: payload.rooms.map((row) => (0, import_core14.toExternalJSON)(row))
  };
  client.emit((0, import_core14.stripNamespacePrefix)(type), modPayload);
  (0, import_core14.getLogger)().trace("videoManagerRoomsWorker ended");
};

// src/cantina/workers/videoManagerRoomWorker.ts
var import_core15 = require("@signalwire/core");
var videoManagerRoomWorker = function* (options) {
  (0, import_core15.getLogger)().trace("videoManagerRoomWorker started");
  const {
    instance: client,
    action: { type, payload }
  } = options;
  client.emit((0, import_core15.stripNamespacePrefix)(type), (0, import_core15.toExternalJSON)(payload));
  (0, import_core15.getLogger)().trace("videoManagerRoomWorker ended");
};

// src/cantina/workers/videoManagerWorker.ts
var videoManagerWorker = function* (options) {
  (0, import_core16.getLogger)().trace("videoManagerWorker started");
  const {
    channels: { swEventChannel }
  } = options;
  function* worker(action) {
    const { type } = action;
    switch (type) {
      case "video-manager.rooms.subscribed":
        yield import_core16.sagaEffects.fork(videoManagerRoomsWorker, __spreadValues({
          action
        }, options));
        break;
      case "video-manager.room.added":
      case "video-manager.room.deleted":
      case "video-manager.room.ended":
      case "video-manager.room.started":
      case "video-manager.room.updated":
        yield import_core16.sagaEffects.fork(videoManagerRoomWorker, __spreadValues({
          action
        }, options));
        break;
      default:
        (0, import_core16.getLogger)().warn(`Unknown video-manager event: "${type}"`);
        break;
    }
  }
  while (true) {
    const action = yield import_core16.sagaEffects.take(swEventChannel, (action2) => {
      return action2.type.startsWith("video-manager.");
    });
    yield import_core16.sagaEffects.fork(worker, action);
  }
  (0, import_core16.getLogger)().trace("videoManagerWorker ended");
};

// src/cantina/VideoManager.ts
var VideoManagerAPI = class extends import_core17.BaseConsumer {
  constructor(options) {
    super(options);
    this.runWorker("videoManagerWorker", {
      worker: videoManagerWorker
    });
  }
  getSubscriptions() {
    const eventNamesWithPrefix = this.eventNames().map((event) => `video-manager.${event}`);
    return (0, import_core17.validateEventsToSubscribe)(eventNamesWithPrefix);
  }
};
var createVideoManagerObject = (params) => {
  const manager = (0, import_core17.connect)({
    store: params.store,
    Component: VideoManagerAPI
  })(params);
  const proxy = new Proxy(manager, {
    get(target, property, receiver) {
      if (property === "_eventsNamespace") {
        return "";
      } else if (property === "eventChannel") {
        return "video-manager.rooms";
      }
      return Reflect.get(target, property, receiver);
    }
  });
  return proxy;
};

// src/Client.ts
var ClientAPI = class extends import_core18.BaseClient {
  constructor() {
    super(...arguments);
    __publicField(this, "_videoManager");
    __publicField(this, "_chat");
    __publicField(this, "_pubSub");
  }
  get rooms() {
    return {
      makeRoomObject: (makeRoomOptions) => {
        const _a = makeRoomOptions, {
          rootElement,
          applyLocalVideoOverlay = true,
          stopCameraWhileMuted = true,
          stopMicrophoneWhileMuted = true
        } = _a, options = __objRest(_a, [
          "rootElement",
          "applyLocalVideoOverlay",
          "stopCameraWhileMuted",
          "stopMicrophoneWhileMuted"
        ]);
        const customSagas = [];
        customSagas.push(makeAudioElementSaga({
          speakerId: options.speakerId
        }));
        if (rootElement) {
          customSagas.push(makeVideoElementSaga({
            rootElement,
            applyLocalVideoOverlay
          }));
        }
        const room = createBaseRoomSessionObject(__spreadProps(__spreadValues({}, options), {
          store: this.store,
          customSagas
        }));
        if (stopMicrophoneWhileMuted) {
          room.on("member.updated.audio_muted", ({ member }) => {
            try {
              if (member.id === room.memberId && "audio_muted" in member) {
                member.audio_muted ? room.stopOutboundAudio() : room.restoreOutboundAudio();
              }
            } catch (error) {
              this.logger.error("Error handling audio_muted", error);
            }
          });
        }
        if (stopCameraWhileMuted) {
          room.on("member.updated.video_muted", ({ member }) => {
            try {
              if (member.id === room.memberId && "video_muted" in member) {
                member.video_muted ? room.stopOutboundVideo() : room.restoreOutboundVideo();
              }
            } catch (error) {
              this.logger.error("Error handling video_muted", error);
            }
          });
        }
        return room;
      }
    };
  }
  get chat() {
    if (!this._chat) {
      this._chat = import_core18.Chat.createBaseChatObject({
        store: this.store
      });
    }
    return this._chat;
  }
  get pubSub() {
    if (!this._pubSub) {
      this._pubSub = import_core18.PubSub.createBasePubSubObject({
        store: this.store
      });
    }
    return this._pubSub;
  }
  get videoManager() {
    if (!this._videoManager) {
      this._videoManager = createVideoManagerObject(this.options);
    }
    return this._videoManager;
  }
  reauthenticate(token) {
    this.store.dispatch(import_core18.actions.reauthAction({ token }));
  }
};

// src/JWTSession.ts
var import_jwt_decode2 = __toESM(require("jwt-decode"));
var import_core21 = require("@signalwire/core");

// src/utils/storage.ts
var import_jwt_decode = __toESM(require("jwt-decode"));
var import_core19 = require("@signalwire/core");
var getStorage = () => {
  if (window && window.sessionStorage) {
    return window.sessionStorage;
  }
  return void 0;
};
var sessionStorageManager = (token) => {
  var _a;
  let roomName = "";
  try {
    const jwtPayload = (0, import_jwt_decode.default)(token);
    roomName = (_a = jwtPayload == null ? void 0 : jwtPayload.r) != null ? _a : "";
  } catch (e) {
    if (process.env.NODE_ENV !== "production") {
      (0, import_core19.getLogger)().error("[sessionStorageManager] error decoding JWT", token);
    }
    roomName = "";
  }
  const valid = Boolean(roomName);
  return {
    authStateKey: valid && `as-${roomName}`,
    protocolKey: valid && `pt-${roomName}`,
    callIdKey: valid && `ci-${roomName}`
  };
};

// src/utils/CloseEvent.ts
var import_core20 = require("@signalwire/core");
var SwCloseEvent = typeof CloseEvent === "function" ? CloseEvent : import_core20.SWCloseEvent;

// src/JWTSession.ts
var JWTSession = class extends import_core21.BaseJWTSession {
  constructor(options) {
    var _a;
    let decodedJwt = {};
    try {
      decodedJwt = (0, import_jwt_decode2.default)(options.token, {
        header: true
      });
    } catch (e) {
      if (process.env.NODE_ENV !== "production") {
        (0, import_core21.getLogger)().debug("[JWTSession] error decoding the JWT");
      }
    }
    super(__spreadProps(__spreadValues({}, options), {
      host: options.host || (decodedJwt == null ? void 0 : decodedJwt.ch)
    }));
    this.options = options;
    __publicField(this, "WebSocketConstructor", WebSocket);
    __publicField(this, "CloseEventConstructor", SwCloseEvent);
    __publicField(this, "agent", "@signalwire/js/browser/3.25.1");
    __publicField(this, "tokenTyp");
    this.tokenTyp = (_a = decodedJwt.typ) != null ? _a : "VRT";
  }
  get allowReattach() {
    var _a;
    return ((_a = this.options) == null ? void 0 : _a.reattach) !== false && this.isVRT();
  }
  retrieveRelayProtocol() {
    return __async(this, null, function* () {
      var _a, _b;
      if (!this.allowReattach) {
        return "";
      }
      const { protocolKey } = sessionStorageManager(this.options.token);
      if (protocolKey) {
        this.logger.trace("Search protocol for", protocolKey);
        return (_b = (_a = getStorage()) == null ? void 0 : _a.getItem(protocolKey)) != null ? _b : "";
      }
      return "";
    });
  }
  persistRelayProtocol() {
    return __async(this, null, function* () {
      var _a;
      if (!this.allowReattach) {
        return;
      }
      const { protocolKey } = sessionStorageManager(this.options.token);
      if (protocolKey) {
        this.logger.trace("Persist protocol", protocolKey, this.relayProtocol);
        (_a = getStorage()) == null ? void 0 : _a.setItem(protocolKey, this.relayProtocol);
      }
    });
  }
  retrieveSwAuthorizationState() {
    return __async(this, null, function* () {
      var _a, _b;
      const { authStateKey } = sessionStorageManager(this.options.token);
      if (authStateKey) {
        return (_b = (_a = getStorage()) == null ? void 0 : _a.getItem(authStateKey)) != null ? _b : "";
      }
      return "";
    });
  }
  persistSwAuthorizationState(state) {
    return __async(this, null, function* () {
      var _a;
      if (!this.allowReattach) {
        return;
      }
      const { authStateKey } = sessionStorageManager(this.options.token);
      if (authStateKey) {
        this.logger.trace("Persist auth state", authStateKey, state);
        (_a = getStorage()) == null ? void 0 : _a.setItem(authStateKey, state);
      }
    });
  }
  _onSocketClose(event) {
    var _a, _b, _c;
    if (this.status === "unknown") {
      const { protocolKey, authStateKey, callIdKey } = sessionStorageManager(this.options.token);
      this.logger.debug("Cleaning up storage");
      if (protocolKey) {
        this.logger.debug("Remove protocolKey", protocolKey);
        (_a = getStorage()) == null ? void 0 : _a.removeItem(protocolKey);
      }
      if (authStateKey) {
        this.logger.debug("Remove authStateKey", authStateKey);
        (_b = getStorage()) == null ? void 0 : _b.removeItem(authStateKey);
      }
      if (callIdKey) {
        this.logger.debug("Remove callIdKey", callIdKey);
        (_c = getStorage()) == null ? void 0 : _c.removeItem(callIdKey);
      }
    }
    super._onSocketClose(event);
  }
  isVRT() {
    return this.tokenTyp === "VRT";
  }
};

// src/createClient.ts
var createClient = (userOptions) => {
  const baseUserOptions = __spreadProps(__spreadValues({}, userOptions), {
    emitter: (0, import_core22.getEventEmitter)()
  });
  const store = (0, import_core22.configureStore)({
    userOptions: baseUserOptions,
    SessionConstructor: JWTSession
  });
  const client = (0, import_core22.connect)({
    store,
    Component: ClientAPI
  })(baseUserOptions);
  return client;
};

// src/createRoomObject.ts
var VIDEO_CONSTRAINTS = {
  aspectRatio: { ideal: 16 / 9 }
};
var createRoomObject = (roomOptions) => {
  return new Promise((resolve, reject) => __async(void 0, null, function* () {
    const _a = roomOptions, {
      audio = true,
      video = true,
      iceServers,
      rootElementId,
      applyLocalVideoOverlay = true,
      autoJoin = false,
      stopCameraWhileMuted = true,
      stopMicrophoneWhileMuted = true,
      speakerId
    } = _a, userOptions = __objRest(_a, [
      "audio",
      "video",
      "iceServers",
      "rootElementId",
      "applyLocalVideoOverlay",
      "autoJoin",
      "stopCameraWhileMuted",
      "stopMicrophoneWhileMuted",
      "speakerId"
    ]);
    const client = createClient(__spreadValues({}, userOptions));
    yield client.connect();
    if (!client) {
      return;
    }
    let rootElement;
    if (rootElementId) {
      const el = document.getElementById(rootElementId);
      if (el) {
        rootElement = el;
      } else {
        rootElement = document.body;
        (0, import_core23.getLogger)().warn(`We couldn't find an element with id: ${rootElementId}: using 'document.body' instead.`);
      }
    }
    const roomObject = client.rooms.makeRoomObject({
      audio,
      video: video === true ? VIDEO_CONSTRAINTS : video,
      negotiateAudio: true,
      negotiateVideo: true,
      iceServers,
      rootElement,
      applyLocalVideoOverlay,
      stopCameraWhileMuted,
      stopMicrophoneWhileMuted,
      speakerId
    });
    roomObject.once("destroy", () => {
      roomObject.emit("room.left");
      client.disconnect();
    });
    const join = () => {
      return new Promise((resolve2, reject2) => __async(void 0, null, function* () {
        try {
          roomObject.once("room.subscribed", (_payload) => {
            resolve2(roomObject);
          });
          yield roomObject.join();
        } catch (error) {
          (0, import_core23.getLogger)().error("Join", error);
          client.disconnect();
          reject2(error);
        }
      }));
    };
    const room = new Proxy(roomObject, {
      get(target, prop, receiver) {
        if (prop === "join") {
          return join;
        }
        return Reflect.get(target, prop, receiver);
      }
    });
    if (autoJoin) {
      try {
        yield room.join();
        resolve(room);
      } catch (error) {
        reject(error);
      }
    } else {
      resolve(room);
    }
  }));
};

// src/joinRoom.ts
var joinRoom = (roomOptions) => {
  return createRoomObject(__spreadProps(__spreadValues({}, roomOptions), {
    autoJoin: true
  }));
};

// src/RoomSession.ts
var import_core25 = require("@signalwire/core");

// src/utils/roomSession.ts
var import_core24 = require("@signalwire/core");
var getJoinMediaParams = (options) => {
  const {
    authState,
    audio = true,
    video = true,
    sendAudio,
    sendVideo,
    receiveAudio,
    receiveVideo
  } = options;
  (0, import_core24.getLogger)().debug("getJoinMediaParams options", __spreadValues({}, options));
  const { audio_allowed, video_allowed, join_as } = authState;
  const joinAs = join_as != null ? join_as : "member";
  const canSend = joinAs === "member";
  const canSendAudio = canSend && audio_allowed === "both";
  const canSendVideo = canSend && video_allowed === "both";
  const canReceiveAudio = audio_allowed !== "none";
  const canReceiveVideo = video_allowed !== "none";
  const reqToSendAudio = Boolean(sendAudio != null ? sendAudio : audio);
  const reqToSendVideo = Boolean(sendVideo != null ? sendVideo : video);
  const reqToReceiveAudio = Boolean(receiveAudio != null ? receiveAudio : audio);
  const reqToReceiveVideo = Boolean(receiveVideo != null ? receiveVideo : video);
  if (!canSendAudio && reqToSendAudio) {
    (0, import_core24.getLogger)().info("Not allowed to send audio on this room. Default values will be used.");
  }
  if (!canSendVideo && reqToSendVideo) {
    (0, import_core24.getLogger)().info("Not allowed to send video on this room. Default values will be used.");
  }
  if (!canReceiveAudio && reqToReceiveAudio) {
    (0, import_core24.getLogger)().info("Not allowed to receive video from the room. Default values will be used.");
  }
  if (!canReceiveVideo && reqToReceiveVideo) {
    (0, import_core24.getLogger)().info("Not allowed to receive video from the room. Default values will be used.");
  }
  return {
    mustSendAudio: canSendAudio && reqToSendAudio,
    mustSendVideo: canSendVideo && reqToSendVideo,
    mustRecvAudio: canReceiveAudio && reqToReceiveAudio,
    mustRecvVideo: canReceiveVideo && reqToReceiveVideo
  };
};
var checkMediaParams = (options) => {
  return Object.values(options).some(Boolean);
};

// src/RoomSession.ts
var UNSAFE_PROP_ACCESS = [
  "audioMute",
  "audioUnmute",
  "deaf",
  "getLayouts",
  "getMembers",
  "getRecordings",
  "hideVideoMuted",
  "leave",
  "removerMember",
  "restoreOutboundAudio",
  "restoreOutboundVideo",
  "setInputSensitivity",
  "setInputVolume",
  "setLayout",
  "setPositions",
  "setMemberPosition",
  "setOutputVolume",
  "showVideoMuted",
  "startRecording",
  "stopOutboundAudio",
  "stopOutboundVideo",
  "undeaf",
  "videoMute",
  "videoUnmute",
  "setMicrophoneVolume",
  "setSpeakerVolume",
  "getMeta",
  "setMeta",
  "updateMeta",
  "deleteMeta",
  "getMemberMeta",
  "setMemberMeta",
  "updateMemberMeta",
  "deleteMemberMeta",
  "promote",
  "demote",
  "lock",
  "unlock"
];
var REQUIRED_EVENTS = [
  "member.joined",
  "layout.changed"
];
var noop2 = () => {
};
var RoomSession = function(roomOptions) {
  const _a = roomOptions, {
    audio: audioFromConstructor = true,
    video: videoFromConstructor = true,
    iceServers,
    rootElement,
    applyLocalVideoOverlay = true,
    mirrorLocalVideoOverlay = false,
    stopCameraWhileMuted = true,
    stopMicrophoneWhileMuted = true,
    speakerId,
    destinationNumber,
    localStream,
    watchMediaPackets,
    watchMediaPacketsTimeout
  } = _a, userOptions = __objRest(_a, [
    "audio",
    "video",
    "iceServers",
    "rootElement",
    "applyLocalVideoOverlay",
    "mirrorLocalVideoOverlay",
    "stopCameraWhileMuted",
    "stopMicrophoneWhileMuted",
    "speakerId",
    "destinationNumber",
    "localStream",
    "watchMediaPackets",
    "watchMediaPacketsTimeout"
  ]);
  const deprecatedParams = ["audio", "video"];
  deprecatedParams.forEach((param) => {
    if (param in roomOptions) {
      (0, import_core25.getLogger)().warn(`The '${param}' parameter on the RoomSession constructor is deprecated. Set it on the '.join()' function instead.`);
    }
  });
  const allowReattach = (roomOptions == null ? void 0 : roomOptions.reattach) !== false;
  const { callIdKey } = sessionStorageManager(userOptions.token);
  const reattachManager = {
    joined: ({ call_id }) => {
      var _a2;
      if (allowReattach && callIdKey) {
        (_a2 = getStorage()) == null ? void 0 : _a2.setItem(callIdKey, call_id);
      }
    },
    init: () => {
      if (allowReattach) {
        room.on("room.subscribed", reattachManager.joined);
      }
      room.options.prevCallId = reattachManager.getPrevCallId();
    },
    destroy: () => {
      var _a2;
      if (!allowReattach) {
        return;
      }
      room.off("room.subscribed", reattachManager.joined);
      if (callIdKey) {
        (_a2 = getStorage()) == null ? void 0 : _a2.removeItem(callIdKey);
      }
    },
    getPrevCallId: () => {
      var _a2, _b;
      if (!allowReattach || !callIdKey) {
        return;
      }
      return (_b = (_a2 = getStorage()) == null ? void 0 : _a2.getItem(callIdKey)) != null ? _b : void 0;
    }
  };
  const client = createClient(userOptions);
  const room = client.rooms.makeRoomObject({
    negotiateAudio: true,
    negotiateVideo: true,
    iceServers,
    rootElement,
    applyLocalVideoOverlay,
    mirrorLocalVideoOverlay,
    stopCameraWhileMuted,
    stopMicrophoneWhileMuted,
    speakerId,
    destinationNumber,
    localStream,
    watchMediaPackets,
    watchMediaPacketsTimeout,
    prevCallId: reattachManager.getPrevCallId()
  });
  room.once("destroy", () => {
    room.emit("room.left", { reason: room.leaveReason });
    reattachManager.destroy();
    client.disconnect();
  });
  client.session.once("session.disconnected", () => {
    room.destroy();
  });
  const join = (params) => {
    return new Promise((resolve, reject) => __async(this, null, function* () {
      var _a2, _b;
      try {
        room.attachPreConnectWorkers();
        yield client.connect();
        const audio = (_a2 = params == null ? void 0 : params.audio) != null ? _a2 : audioFromConstructor;
        const video = (_b = params == null ? void 0 : params.video) != null ? _b : videoFromConstructor;
        const authState = client._sessionAuthState;
        (0, import_core25.getLogger)().debug("getJoinMediaParams authState?", authState);
        if (authState && authState.type === "video") {
          const mediaOptions = getJoinMediaParams(__spreadValues({
            authState,
            sendAudio: Boolean(audio),
            sendVideo: Boolean(video)
          }, params));
          if (!checkMediaParams(mediaOptions)) {
            client.disconnect();
            return reject(new Error(`Invalid arguments to join the room. The token used has join_as: '${authState.join_as}'. 
${JSON.stringify(params, null, 2)}
`));
          }
          (0, import_core25.getLogger)().debug("Set mediaOptions", mediaOptions);
          room.updateMediaOptions({
            audio: mediaOptions.mustSendAudio ? audio || true : false,
            video: mediaOptions.mustSendVideo ? video || true : false,
            negotiateAudio: mediaOptions.mustRecvAudio,
            negotiateVideo: mediaOptions.mustRecvVideo
          });
        }
        room.once("room.subscribed", () => {
          resolve(room);
        });
        reattachManager.init();
        REQUIRED_EVENTS.forEach((event) => room.once(event, noop2));
        yield room.join();
      } catch (error) {
        (0, import_core25.getLogger)().error("RoomSession Join", error);
        client.disconnect();
        reject(error);
      }
    }));
  };
  const interceptors = {
    join
  };
  return new Proxy(room, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (!target.active && UNSAFE_PROP_ACCESS.includes(prop)) {
        throw new Error(`Tried to access the property/method "${prop}" before the room was connected. Please call roomSession.join() first.`);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/fabric/buildCall.ts
var buildCall = ({
  strategy,
  params,
  userParams
}) => {
  let obj;
  let start;
  switch (strategy) {
    case "room":
      obj = new RoomSession(__spreadValues({
        token: params.token,
        debug: {
          logWsTraffic: true
        },
        logLevel: "debug",
        watchMediaPackets: false
      }, userParams));
      start = (joinParams) => {
        return new Promise((resolve, reject) => {
          obj.once("room.joined", (params2) => resolve(params2));
          obj.emitter.once("verto.display", (params2) => resolve(params2));
          return obj.join(joinParams).catch((error) => reject(error));
        });
      };
      break;
    default:
      throw new Error(`Unknown strategy: '${strategy}'`);
  }
  const interceptors = {
    start
  };
  return new Proxy(obj, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/fabric/Client.ts
var Client2 = class {
  constructor(options) {
    this.options = options;
    __publicField(this, "httpClient");
    this.httpClient = createHttpClient({
      baseUrl: `https://${this.host}`,
      headers: {
        Authorization: `Bearer ${this.options.accessToken}`
      }
    });
  }
  get host() {
    var _a;
    return (_a = this.options.host) != null ? _a : "fabric.signalwire.com";
  }
  getAddresses() {
    return __async(this, null, function* () {
      const path = "/addresses";
      const { body } = yield this.httpClient(path);
      const anotherPage = (url) => __async(this, null, function* () {
        const { search } = new URL(url);
        const { body: body2 } = yield this.httpClient(`${path}${search}`);
        return buildResult(body2);
      });
      const buildResult = (body2) => {
        return {
          addresses: body2.data,
          nextPage: () => __async(this, null, function* () {
            const { next } = body2.links;
            return next ? anotherPage(next) : void 0;
          }),
          prevPage: () => __async(this, null, function* () {
            const { prev } = body2.links;
            return prev ? anotherPage(prev) : void 0;
          })
        };
      };
      return buildResult(body);
    });
  }
  createCall(_a) {
    return __async(this, null, function* () {
      var _b = _a, {
        uri
      } = _b, userParams = __objRest(_b, [
        "uri"
      ]);
      const path = "/call";
      const { body } = yield this.httpClient(path, {
        method: "POST",
        body: { uri }
      });
      console.log("Dial Response", body);
      return buildCall(__spreadProps(__spreadValues({}, body), {
        userParams: __spreadValues({
          host: this.host.includes("swire") ? "relay.swire.io" : void 0
        }, userParams)
      }));
    });
  }
};

// src/fabric/SWClient.ts
var SWClient = class {
  constructor(options) {
    this.options = options;
    __publicField(this, "httpClient");
    this.httpClient = createHttpClient({
      baseUrl: `https://${this.httpHost}`,
      headers: {
        Authorization: `Bearer ${this.options.accessToken}`
      }
    });
  }
  get httpHost() {
    var _a;
    return (_a = this.options.httpHost) != null ? _a : "fabric.signalwire.com";
  }
  getAddresses() {
    return __async(this, null, function* () {
      const path = "/addresses";
      const { body } = yield this.httpClient(path);
      const anotherPage = (url) => __async(this, null, function* () {
        const { search } = new URL(url);
        const { body: body2 } = yield this.httpClient(`${path}${search}`);
        return buildResult(body2);
      });
      const buildResult = (body2) => {
        return {
          addresses: body2.data,
          nextPage: () => __async(this, null, function* () {
            const { next } = body2.links;
            return next ? anotherPage(next) : void 0;
          }),
          prevPage: () => __async(this, null, function* () {
            const { prev } = body2.links;
            return prev ? anotherPage(prev) : void 0;
          })
        };
      };
      return buildResult(body);
    });
  }
  registerDevice(_0) {
    return __async(this, arguments, function* ({ deviceType, deviceToken }) {
      const path = "/subscriber/devices";
      const { body } = yield this.httpClient(path, {
        method: "POST",
        body: {
          device_type: deviceType,
          device_token: deviceToken
        }
      });
      return body;
    });
  }
  unregisterDevice(_0) {
    return __async(this, arguments, function* ({ id }) {
      const path = `/subscriber/devices/${id}`;
      return yield this.httpClient(path, {
        method: "DELETE"
      });
    });
  }
};

// src/fabric/WSClient.ts
var import_core27 = require("@signalwire/core");

// src/fabric/WSClientWorker.ts
var import_core26 = require("@signalwire/core");
var WSClientWorker = function* (options) {
  (0, import_core26.getLogger)().debug("WSClientWorker started");
  const { channels, instance } = options;
  const { swEventChannel } = channels;
  (0, import_core26.getLogger)().debug("WSClientWorker instance", instance);
  while (true) {
    const action = yield import_core26.sagaEffects.take(swEventChannel, (action2) => {
      (0, import_core26.getLogger)().debug("WSClientWorker action", action2);
      if (action2.type === "webrtc.message") {
        return action2.payload.method === "verto.invite";
      }
      return false;
    });
    (0, import_core26.getLogger)().debug("Build new call to answer", action);
  }
  (0, import_core26.getLogger)().trace("WSClientWorker ended");
};

// src/fabric/WSClient.ts
var WSClient = class {
  constructor(options) {
    this.options = options;
    __publicField(this, "wsClient");
    __publicField(this, "logger", (0, import_core27.getLogger)());
    this.wsClient = createClient({
      host: this.options.host,
      token: this.options.token,
      debug: {
        logWsTraffic: true
      },
      logLevel: "debug"
    });
  }
  connect() {
    this.wsClient.runWorker("WSClientWorker", {
      worker: WSClientWorker
    });
    return this.wsClient.connect();
  }
  disconnect() {
    return this.wsClient.disconnect();
  }
  dial(params) {
    return __async(this, null, function* () {
      return new Promise((resolve, reject) => __async(this, null, function* () {
        try {
          console.log("WSClient dial with:", params);
          yield this.connect();
          const call = this.wsClient.rooms.makeRoomObject({
            negotiateAudio: true,
            negotiateVideo: true,
            rootElement: this.options.rootElement,
            applyLocalVideoOverlay: true,
            stopCameraWhileMuted: true,
            stopMicrophoneWhileMuted: true,
            destinationNumber: params.to,
            watchMediaPackets: false,
            nodeId: params.nodeId
          });
          call.once("destroy", () => {
            this.logger.debug("RTC Connection Destroyed");
          });
          this.wsClient.once("session.disconnected", () => {
            this.logger.debug("Session Disconnected");
          });
          call.attachPreConnectWorkers();
          call.start = () => {
            return new Promise((resolve2, reject2) => __async(this, null, function* () {
              try {
                call.once("verto.display", () => resolve2(call));
                call.once("room.subscribed", () => resolve2(call));
                yield call.join();
              } catch (error) {
                (0, import_core27.getLogger)().error("WSClient call start", error);
                reject2(error);
              }
            }));
          };
          resolve(call);
        } catch (error) {
          (0, import_core27.getLogger)().error("WSClient dial", error);
          reject(error);
        }
      }));
    });
  }
  handlePushNotification(payload) {
    return new Promise((resolve, reject) => __async(this, null, function* () {
      const { decrypted, type } = payload;
      if (type !== "call_invite") {
        this.logger.warn("Unknown notification type", payload);
        return;
      }
      this.logger.debug("handlePushNotification", payload);
      const { params: jsonrpc, node_id: nodeId } = decrypted;
      const {
        params: {
          callID,
          sdp,
          caller_id_name,
          caller_id_number,
          callee_id_name,
          callee_id_number,
          display_direction
        }
      } = jsonrpc;
      this.logger.debug("handlePushNotification data", {
        callID,
        sdp,
        caller_id_name,
        caller_id_number,
        callee_id_name,
        callee_id_number,
        display_direction
      });
      try {
        yield this.connect();
        try {
          yield this.executeVertoSubscribe(callID, nodeId);
        } catch (error) {
          this.logger.warn("Verto Subscribe", error);
        }
        const call = this.wsClient.rooms.makeRoomObject({
          negotiateAudio: true,
          negotiateVideo: true,
          rootElement: this.options.rootElement,
          applyLocalVideoOverlay: true,
          stopCameraWhileMuted: true,
          stopMicrophoneWhileMuted: true,
          watchMediaPackets: false,
          remoteSdp: sdp,
          prevCallId: callID,
          nodeId
        });
        call.once("destroy", () => {
          (0, import_core27.getLogger)().debug("RTC Connection Destroyed");
        });
        call.attachPreConnectWorkers();
        (0, import_core27.getLogger)().debug("Resolving Call", call);
        resolve({ resultType: "inboundCall", resultObject: call });
      } catch (error) {
        reject(error);
      }
    }));
  }
  executeVertoSubscribe(callId, nodeId) {
    return __async(this, null, function* () {
      try {
        return yield this.wsClient.execute({
          method: "webrtc.verto",
          params: {
            callID: callId,
            node_id: nodeId,
            subscribe: [],
            message: (0, import_core27.VertoSubscribe)({
              sessid: callId,
              eventChannel: []
            })
          }
        });
      } catch (error) {
        this.logger.warn("The call is not available anymore", callId);
        throw error;
      }
    });
  }
  updateToken(token) {
    return new Promise((resolve, reject) => {
      this.wsClient.once("session.auth_error", (error) => {
        reject(error);
      });
      this.wsClient.once("session.connected", () => {
        resolve();
      });
      this.wsClient.reauthenticate(token);
    });
  }
};

// src/fabric/HTTPClient.ts
var HTTPClient = class {
  constructor(options) {
    this.options = options;
    __publicField(this, "httpClient");
    this.httpClient = createHttpClient({
      baseUrl: `https://${this.httpHost}`,
      headers: {
        Authorization: `Bearer ${this.options.token}`
      }
    });
  }
  get httpHost() {
    const { host } = this.options;
    if (!host) {
      return "fabric.signalwire.com";
    }
    return `fabric.${host.split(".").splice(1).join(".")}`;
  }
  getAddresses() {
    return __async(this, null, function* () {
      const path = "/addresses";
      const { body } = yield this.httpClient(path);
      const anotherPage = (url) => __async(this, null, function* () {
        const { search } = new URL(url);
        const { body: body2 } = yield this.httpClient(`${path}${search}`);
        return buildResult(body2);
      });
      const buildResult = (body2) => {
        return {
          addresses: body2.data,
          nextPage: () => __async(this, null, function* () {
            const { next } = body2.links;
            return next ? anotherPage(next) : void 0;
          }),
          prevPage: () => __async(this, null, function* () {
            const { prev } = body2.links;
            return prev ? anotherPage(prev) : void 0;
          })
        };
      };
      return buildResult(body);
    });
  }
  registerDevice(_0) {
    return __async(this, arguments, function* ({
      deviceType,
      deviceToken
    }) {
      const path = "/subscriber/devices";
      const { body } = yield this.httpClient(path, {
        method: "POST",
        body: {
          device_type: deviceType,
          device_token: deviceToken
        }
      });
      return body;
    });
  }
  unregisterDevice(_0) {
    return __async(this, arguments, function* ({ id }) {
      const path = `/subscriber/devices/${id}`;
      return yield this.httpClient(path, {
        method: "DELETE"
      });
    });
  }
};

// src/fabric/SignalWire.ts
var SignalWire = (options) => {
  return new Promise((resolve, reject) => __async(void 0, null, function* () {
    try {
      const httpClient = new HTTPClient(options);
      const wsClient = new WSClient(options);
      resolve({
        httpHost: httpClient.httpHost,
        getAddresses: httpClient.getAddresses.bind(httpClient),
        registerDevice: httpClient.registerDevice.bind(httpClient),
        unregisterDevice: httpClient.unregisterDevice.bind(httpClient),
        connect: wsClient.connect.bind(wsClient),
        disconnect: wsClient.disconnect.bind(wsClient),
        dial: wsClient.dial.bind(wsClient),
        handlePushNotification: wsClient.handlePushNotification.bind(wsClient),
        updateToken: wsClient.updateToken.bind(wsClient),
        __httpClient: httpClient,
        __wsClient: wsClient
      });
    } catch (error) {
      reject(error);
    }
  }));
};

// src/chat/index.ts
var chat_exports = {};
__export(chat_exports, {
  ChatMember: () => import_core28.ChatMember,
  ChatMessage: () => import_core28.ChatMessage,
  Client: () => Client3
});

// src/chat/Client.ts
var INTERCEPTED_METHODS = [
  "subscribe",
  "publish",
  "getMessages",
  "getMembers",
  "getMemberState",
  "getAllowedChannels",
  "setMemberState"
];
var Client3 = function(chatOptions) {
  const client = createClient(chatOptions);
  const createInterceptor = (prop) => {
    return (...params) => __async(this, null, function* () {
      yield client.connect();
      return client.chat[prop](...params);
    });
  };
  const interceptors = {
    _session: client,
    disconnect: () => client.disconnect()
  };
  return new Proxy(client.chat, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (INTERCEPTED_METHODS.includes(prop)) {
        return createInterceptor(prop);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/chat/index.ts
var import_core28 = require("@signalwire/core");

// src/pubSub/index.ts
var pubSub_exports = {};
__export(pubSub_exports, {
  Client: () => Client4,
  PubSubMessage: () => PubSubMessage
});
var import_core30 = require("@signalwire/core");

// src/utils/interfaces.ts
var import_core29 = require("@signalwire/core");
var INTERNAL_MEMBER_UPDATED_EVENTS = Object.keys(import_core29.INTERNAL_MEMBER_UPDATABLE_PROPS).map((key) => {
  return `member.updated.${key}`;
});

// src/pubSub/Client.ts
var INTERCEPTED_METHODS2 = [
  "getAllowedChannels",
  "subscribe",
  "publish"
];
var Client4 = function(pubSubOptions) {
  const client = createClient(pubSubOptions);
  const createInterceptor = (prop) => {
    return (...params) => __async(this, null, function* () {
      yield client.connect();
      return client.pubSub[prop](...params);
    });
  };
  const interceptors = {
    _session: client,
    disconnect: () => client.disconnect()
  };
  return new Proxy(client.pubSub, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (INTERCEPTED_METHODS2.includes(prop)) {
        return createInterceptor(prop);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/pubSub/index.ts
var PubSubMessage = import_core30.PubSub.PubSubMessage;

// src/webrtc.ts
var webrtc_exports = {};
__export(webrtc_exports, {
  checkCameraPermissions: () => import_webrtc5.checkCameraPermissions,
  checkMicrophonePermissions: () => import_webrtc5.checkMicrophonePermissions,
  checkPermissions: () => import_webrtc5.checkPermissions,
  checkSpeakerPermissions: () => import_webrtc5.checkSpeakerPermissions,
  createCameraDeviceWatcher: () => import_webrtc5.createCameraDeviceWatcher,
  createDeviceWatcher: () => import_webrtc5.createDeviceWatcher,
  createMicrophoneAnalyzer: () => import_webrtc5.createMicrophoneAnalyzer,
  createMicrophoneDeviceWatcher: () => import_webrtc5.createMicrophoneDeviceWatcher,
  createSpeakerDeviceWatcher: () => import_webrtc5.createSpeakerDeviceWatcher,
  enumerateDevices: () => import_webrtc5.enumerateDevices,
  getCameraDevices: () => import_webrtc5.getCameraDevices,
  getCameraDevicesWithPermissions: () => import_webrtc5.getCameraDevicesWithPermissions,
  getDevices: () => import_webrtc5.getDevices,
  getDevicesWithPermissions: () => import_webrtc5.getDevicesWithPermissions,
  getDisplayMedia: () => import_webrtc5.getDisplayMedia,
  getMicrophoneDevices: () => import_webrtc5.getMicrophoneDevices,
  getMicrophoneDevicesWithPermissions: () => import_webrtc5.getMicrophoneDevicesWithPermissions,
  getSpeakerDevices: () => import_webrtc5.getSpeakerDevices,
  getSpeakerDevicesWithPermissions: () => import_webrtc5.getSpeakerDevicesWithPermissions,
  getSupportedConstraints: () => import_webrtc5.getSupportedConstraints,
  getUserMedia: () => import_webrtc5.getUserMedia,
  requestPermissions: () => import_webrtc5.requestPermissions,
  setMediaElementSinkId: () => import_webrtc5.setMediaElementSinkId,
  stopStream: () => import_webrtc5.stopStream,
  stopTrack: () => import_webrtc5.stopTrack,
  supportsGetDisplayMedia: () => import_webrtc5.supportsGetDisplayMedia,
  supportsGetUserMedia: () => import_webrtc5.supportsGetUserMedia,
  supportsMediaDevices: () => import_webrtc5.supportsMediaDevices,
  supportsMediaOutput: () => import_webrtc5.supportsMediaOutput
});
var import_webrtc5 = require("@signalwire/webrtc");
//# sourceMappingURL=index.js.map
