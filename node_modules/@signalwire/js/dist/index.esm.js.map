{
  "version": 3,
  "sources": ["../src/fabric/index.ts", "../src/fabric/createHttpClient.ts", "../src/video.ts", "../src/createRoomObject.ts", "../src/createClient.ts", "../src/Client.ts", "../src/features/mediaElements/mediaElementsSagas.ts", "../src/utils/videoElement.ts", "../src/utils/audioElement.ts", "../src/features/actions.ts", "../src/BaseRoomSession.ts", "../src/utils/constants.ts", "../src/RoomSessionScreenShare.ts", "../src/RoomSessionDevice.ts", "../src/video/memberListUpdatedWorker.ts", "../src/video/childMemberJoinedWorker.ts", "../src/video/videoWorker.ts", "../src/video/videoStreamWorker.ts", "../src/video/videoRecordWorker.ts", "../src/video/videoPlaybackWorker.ts", "../src/cantina/VideoManager.ts", "../src/cantina/workers/videoManagerWorker.ts", "../src/cantina/workers/videoManagerRoomsWorker.ts", "../src/cantina/workers/videoManagerRoomWorker.ts", "../src/JWTSession.ts", "../src/utils/storage.ts", "../src/utils/CloseEvent.ts", "../src/joinRoom.ts", "../src/RoomSession.ts", "../src/utils/roomSession.ts", "../src/fabric/buildCall.ts", "../src/fabric/Client.ts", "../src/fabric/SWClient.ts", "../src/fabric/WSClient.ts", "../src/fabric/WSClientWorker.ts", "../src/fabric/HTTPClient.ts", "../src/fabric/SignalWire.ts", "../src/chat/index.ts", "../src/chat/Client.ts", "../src/pubSub/index.ts", "../src/utils/interfaces.ts", "../src/pubSub/Client.ts", "../src/webrtc.ts"],
  "sourcesContent": ["export * from './Client'\nexport * from './SWClient'\nexport * from './WSClient'\nexport * from './SignalWire'\n", "import { AuthError, HttpError } from '@signalwire/core'\n\ninterface InternalHttpResponse<T> extends Response {\n  parsedBody?: T\n}\n\nasync function http<T>(\n  input: string,\n  init: RequestInit | undefined\n): Promise<InternalHttpResponse<T>> {\n  const response: InternalHttpResponse<T> = await fetch(input, init)\n\n  if (!response.ok) {\n    if (response.status === 401) {\n      throw new AuthError(response.status, 'Unauthorized')\n    }\n\n    let errorResponse\n    try {\n      errorResponse = await response.json()\n    } catch (e) {}\n\n    const errorMessage = errorResponse?.errors\n      ? JSON.stringify(errorResponse.errors)\n      : 'Not Found'\n\n    throw new HttpError(response.status, errorMessage, errorResponse)\n  }\n\n  try {\n    // might throw if body is empty\n    response.parsedBody = await response.json()\n  } catch (e) {}\n\n  return response\n}\n\ninterface CreateHttpClientOptions extends RequestInit {\n  baseUrl: string\n  /**\n   * Timeout in milliseconds\n   */\n  timeout?: number\n}\n\ninterface HttpClientRequestInit extends Omit<RequestInit, 'body'> {\n  body?: Record<string, unknown>\n  searchParams?: Record<string, any>\n}\n\nexport const createHttpClient = (\n  { baseUrl, timeout = 30000, ...globalOptions }: CreateHttpClientOptions,\n  fetcher = http\n) => {\n  const apiClient = async <T>(\n    path: string,\n    options?: HttpClientRequestInit\n  ): Promise<{ body: T }> => {\n    const headers = {\n      ...(options?.body ? { 'Content-Type': 'application/json' } : {}),\n      ...globalOptions.headers,\n      ...options?.headers,\n    }\n\n    const reqInit = getRequestInit({\n      ...globalOptions,\n      ...options,\n      headers,\n    })\n    // reqInit.mode = 'no-cors'\n    // reqInit.credentials = 'include'\n\n    let timerId\n    if (timeout) {\n      const controller = new AbortController()\n      const signal = controller.signal\n\n      reqInit.signal = signal\n\n      timerId = setTimeout(() => {\n        controller.abort()\n      }, timeout)\n    }\n\n    try {\n      const response = await fetcher<T>(\n        getUrl({\n          path,\n          baseUrl,\n          searchParams: options?.searchParams,\n        }),\n        reqInit\n      )\n\n      return { body: response.parsedBody as T }\n    } catch (e) {\n      throw e\n    } finally {\n      timerId && clearTimeout(timerId)\n    }\n  }\n\n  return apiClient\n}\n\nconst getBody = (body: unknown) => {\n  return typeof body === 'string' ? body : JSON.stringify(body)\n}\n\nconst getRequestInit = (options: any): RequestInit => {\n  return Object.entries(options).reduce((reducer, [key, value]) => {\n    if (key === 'body') {\n      return {\n        ...reducer,\n        body: getBody(value),\n      }\n    } else if (value != undefined) {\n      return {\n        ...reducer,\n        [key]: value,\n      }\n    }\n\n    return reducer\n  }, {} as RequestInit)\n}\n\nconst getUrl = ({\n  path,\n  baseUrl,\n  searchParams,\n}: {\n  baseUrl: string\n  path: string\n  searchParams?: Record<string, any>\n}) => {\n  const url = new URL(path, baseUrl)\n\n  if (searchParams) {\n    Object.entries(searchParams).forEach(([key, value]) => {\n      if (value != undefined) {\n        url.searchParams.append(key, value)\n      }\n    })\n  }\n  return url.toString()\n}\n", "import { createRoomObject, Room } from './createRoomObject'\nimport { createClient } from './createClient'\nimport { joinRoom } from './joinRoom'\nimport { MakeRoomOptions } from './Client'\nimport { RoomSession, RoomSessionOptions } from './RoomSession'\nimport { RoomSessionDevice, RoomDevice } from './RoomSessionDevice'\nimport {\n  RoomSessionScreenShare,\n  RoomScreenShare,\n} from './RoomSessionScreenShare'\n\nexport {\n  RoomSession,\n  RoomSessionDevice,\n  RoomSessionScreenShare,\n  // Just to keep backwards compatibility.\n  createRoomObject,\n  joinRoom,\n  Room,\n  RoomDevice,\n  RoomScreenShare,\n  createClient,\n}\n\n/** @ignore */\nexport type { MakeRoomOptions, RoomSessionOptions }\n\n/** @ignore */\nexport type {\n  MemberCommandParams,\n  MemberCommandWithVolumeParams,\n  MemberCommandWithValueParams,\n  DeprecatedMemberUpdatableProps,\n  DeprecatedVideoMemberHandlerParams,\n  VideoMemberHandlerParams,\n  VideoMemberListUpdatedParams,\n} from './utils/interfaces'\n\nexport type { CreateRoomObjectOptions } from './createRoomObject'\n\nexport type {\n  RoomSessionRecording,\n  RoomSessionPlayback,\n} from '@signalwire/core'\n\n", "import { UserOptions, getLogger } from '@signalwire/core'\nimport { createClient } from './createClient'\nimport { MakeRoomOptions } from './Client'\nimport { BaseRoomSession } from './BaseRoomSession'\n\n/**\n * @internal\n * @deprecated Use {@link RoomSession} instead.\n **/\nexport interface Room extends BaseRoomSession<Room> {}\n\nexport interface CreateRoomObjectOptions\n  extends UserOptions,\n    Omit<MakeRoomOptions, 'rootElement'> {\n  /** Id of the HTML element in which to display the video stream */\n  rootElementId?: string\n  /** Whether to automatically join the room session. */\n  autoJoin?: boolean\n}\n\nconst VIDEO_CONSTRAINTS: MediaTrackConstraints = {\n  aspectRatio: { ideal: 16 / 9 },\n}\n\n/**\n * Using Video.createRoomObject() you can create a `RoomObject` to join a room.\n *\n * @example\n * With an HTMLDivElement with id=\"root\" in the DOM.\n * ```js\n * // <div id=\"root\"></div>\n *\n * try {\n *   const roomObj = await Video.createRoomObject({\n *     token: '<YourJWT>',\n *     rootElementId: 'root',\n *   })\n *\n *   roomObj.join()\n * } catch (error) {\n *   console.error('Error', error)\n * }\n * ```\n * @deprecated Use {@link RoomSession} instead.\n */\nexport const createRoomObject = (\n  roomOptions: CreateRoomObjectOptions\n): Promise<Room> => {\n  return new Promise(async (resolve, reject) => {\n    const {\n      audio = true,\n      video = true,\n      iceServers,\n      rootElementId,\n      applyLocalVideoOverlay = true,\n      autoJoin = false,\n      stopCameraWhileMuted = true,\n      stopMicrophoneWhileMuted = true,\n      speakerId,\n      ...userOptions\n    } = roomOptions\n\n    const client = createClient<Room>({\n      ...userOptions,\n    })\n    await client.connect()\n\n    if (!client) {\n      return\n    }\n\n    /**\n     * Since `makeRoomObject` now only accepts a\n     * `rootElement` the following is to preserve backwards\n     * compatibility with the previous syntax\n     */\n    let rootElement: HTMLElement | undefined\n    if (rootElementId) {\n      const el = document.getElementById(rootElementId)\n\n      if (el) {\n        rootElement = el\n      } else {\n        rootElement = document.body\n\n        getLogger().warn(\n          `We couldn't find an element with id: ${rootElementId}: using 'document.body' instead.`\n        )\n      }\n    }\n\n    const roomObject = client.rooms.makeRoomObject({\n      audio,\n      video: video === true ? VIDEO_CONSTRAINTS : video,\n      negotiateAudio: true,\n      negotiateVideo: true,\n      iceServers,\n      rootElement,\n      applyLocalVideoOverlay,\n      stopCameraWhileMuted,\n      stopMicrophoneWhileMuted,\n      speakerId,\n    })\n\n    // WebRTC connection left the room.\n    roomObject.once('destroy', () => {\n      roomObject.emit('room.left')\n      client.disconnect()\n    })\n\n    const join = () => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          roomObject.once('room.subscribed', (_payload) => {\n            resolve(roomObject)\n          })\n\n          await roomObject.join()\n        } catch (error) {\n          getLogger().error('Join', error)\n          // Disconnect the underlay client in case of media/signaling errors\n          client.disconnect()\n\n          reject(error)\n        }\n      })\n    }\n\n    const room = new Proxy(roomObject, {\n      get(target: any, prop: any, receiver: any) {\n        if (prop === 'join') {\n          return join\n        }\n        return Reflect.get(target, prop, receiver)\n      },\n    })\n\n    if (autoJoin) {\n      try {\n        await room.join()\n        resolve(room)\n      } catch (error) {\n        reject(error)\n      }\n    } else {\n      resolve(room)\n    }\n  })\n}\n", "import {\n  ClientEvents,\n  configureStore,\n  connect,\n  getEventEmitter,\n  UserOptions,\n} from '@signalwire/core'\nimport { ClientAPI, Client } from './Client'\nimport { JWTSession } from './JWTSession'\n\n/**\n * With Video.createClient() you can establish a WebSocket connection\n * with SignalWire and interact with the client.\n *\n * ## Examples\n * Create a client\n *\n * @example\n * ```js\n * try {\n *   const client = Video.createClient({\n *     token: '<YourJWT>',\n *   })\n *\n *   await client.connect()\n *   // Your client is ready now..\n * } catch (error) {\n *   console.error('Error', error)\n * }\n * ```\n * @internal\n */\nexport const createClient = <RoomSessionType>(userOptions: UserOptions) => {\n  const baseUserOptions = {\n    ...userOptions,\n    emitter: getEventEmitter<ClientEvents>(),\n  }\n  const store = configureStore({\n    userOptions: baseUserOptions,\n    SessionConstructor: JWTSession,\n  })\n  const client = connect<\n    ClientEvents,\n    ClientAPI<RoomSessionType>,\n    Client<RoomSessionType>\n  >({\n    store,\n    Component: ClientAPI,\n  })(baseUserOptions)\n\n  return client\n}\n", "import {\n  BaseClient,\n  ClientEvents,\n  ClientContract,\n  actions,\n  Chat as ChatNamespace,\n  PubSub as PubSubNamespace,\n} from '@signalwire/core'\nimport type { CustomSaga } from '@signalwire/core'\nimport { ConnectionOptions } from '@signalwire/webrtc'\nimport {\n  makeVideoElementSaga,\n  makeAudioElementSaga,\n} from './features/mediaElements/mediaElementsSagas'\nimport {\n  createBaseRoomSessionObject,\n  RoomSessionConnection,\n} from './BaseRoomSession'\nimport { VideoManager, createVideoManagerObject } from './cantina'\nimport type { Client as ChatClient } from './chat/Client'\nimport type { Client as PubSubClient } from './pubSub/Client'\nimport type { RoomSession } from './RoomSession'\n\nexport interface Client<RoomSessionType = RoomSession>\n  extends ClientContract<Client<RoomSessionType>, ClientEvents> {\n  rooms: ClientAPI<RoomSessionType>['rooms']\n  chat: ClientAPI<RoomSessionType>['chat']\n  pubSub: ClientAPI<RoomSessionType>['pubSub']\n}\n\nexport interface MakeRoomOptions extends ConnectionOptions {\n  /** HTML element in which to display the video stream */\n  rootElement?: HTMLElement\n  /** Whether to apply the local-overlay on top of your video. Default: `true`. */\n  applyLocalVideoOverlay?: boolean\n  /** Whether to mirror the local video overlay. Default: `false`. */\n  mirrorLocalVideoOverlay?: boolean\n  /** Whether to stop the camera when the member is muted. Default: `true`. */\n  stopCameraWhileMuted?: boolean\n  /** Whether to stop the microphone when the member is muted. Default: `true`. */\n  stopMicrophoneWhileMuted?: boolean\n  /** Local media stream to override the local video and audio stream tracks */\n  localStream?: MediaStream\n}\n\nexport class ClientAPI<\n  RoomSessionType = RoomSession\n> extends BaseClient<ClientEvents> {\n  private _videoManager: VideoManager\n  private _chat: ChatClient\n  private _pubSub: PubSubClient\n\n  get rooms() {\n    return {\n      makeRoomObject: (makeRoomOptions: MakeRoomOptions) => {\n        const {\n          rootElement,\n          applyLocalVideoOverlay = true,\n          stopCameraWhileMuted = true,\n          stopMicrophoneWhileMuted = true,\n          ...options\n        } = makeRoomOptions\n\n        // TODO: This might not be needed here. We can initiate these sagas in the BaseRoomSession constructor.\n        const customSagas: Array<CustomSaga<RoomSessionConnection>> = []\n\n        /**\n         * By default the SDK will attach the audio to\n         * an Audio element (regardless of \"rootElement\")\n         */\n        customSagas.push(\n          makeAudioElementSaga({\n            speakerId: options.speakerId,\n          })\n        )\n\n        /**\n         * If the user provides a `roomElement` we'll\n         * automatically handle the Video element for them\n         */\n        if (rootElement) {\n          customSagas.push(\n            makeVideoElementSaga({\n              rootElement,\n              applyLocalVideoOverlay,\n            })\n          )\n        }\n\n        const room = createBaseRoomSessionObject<RoomSessionType>({\n          ...options,\n          store: this.store,\n          customSagas,\n        })\n\n        /**\n         * Stop and Restore outbound audio on audio_muted event\n         */\n        if (stopMicrophoneWhileMuted) {\n          room.on('member.updated.audio_muted', ({ member }) => {\n            try {\n              if (member.id === room.memberId && 'audio_muted' in member) {\n                member.audio_muted\n                  ? room.stopOutboundAudio()\n                  : room.restoreOutboundAudio()\n              }\n            } catch (error) {\n              this.logger.error('Error handling audio_muted', error)\n            }\n          })\n        }\n\n        /**\n         * Stop and Restore outbound video on video_muted event\n         */\n        if (stopCameraWhileMuted) {\n          room.on('member.updated.video_muted', ({ member }) => {\n            try {\n              if (member.id === room.memberId && 'video_muted' in member) {\n                member.video_muted\n                  ? room.stopOutboundVideo()\n                  : room.restoreOutboundVideo()\n              }\n            } catch (error) {\n              this.logger.error('Error handling video_muted', error)\n            }\n          })\n        }\n\n        return room\n      },\n    }\n  }\n\n  get chat() {\n    if (!this._chat) {\n      this._chat = ChatNamespace.createBaseChatObject<ChatClient>({\n        store: this.store,\n      })\n    }\n    return this._chat\n  }\n\n  get pubSub() {\n    if (!this._pubSub) {\n      this._pubSub = PubSubNamespace.createBasePubSubObject<PubSubClient>({\n        store: this.store,\n      })\n    }\n    return this._pubSub\n  }\n\n  /** @internal */\n  get videoManager() {\n    if (!this._videoManager) {\n      this._videoManager = createVideoManagerObject(this.options)\n    }\n    return this._videoManager\n  }\n\n  /**\n   * Reauthenticate with the SignalWire network using a new token\n   * For now it returns void since with an invalid token the server\n   * will close the connection right away so we can hook on the session\n   * events in case. Need to improve it.\n   *\n   * @internal\n   */\n  reauthenticate(token: string) {\n    this.store.dispatch(actions.reauthAction({ token }))\n  }\n}\n", "import {\n  getLogger,\n  CustomSagaParams,\n  actions,\n  sagaEffects,\n  LOCAL_EVENT_PREFIX,\n} from '@signalwire/core'\nimport type { SagaIterator, Task } from '@signalwire/core'\nimport { setMediaElementSinkId } from '@signalwire/webrtc'\nimport {\n  buildVideo,\n  cleanupElement,\n  makeLayoutChangedHandler,\n  setVideoMediaTrack,\n  waitForVideoReady,\n  LocalOverlay,\n  addSDKPrefix,\n  createRootElementResizeObserver,\n} from '../../utils/videoElement'\nimport { setAudioMediaTrack } from '../../utils/audioElement'\nimport { audioSetSpeakerAction } from '../actions'\nimport type { RoomSessionConnection } from '../../BaseRoomSession'\n\nexport const makeVideoElementSaga = ({\n  rootElement,\n  applyLocalVideoOverlay,\n}: {\n  rootElement: HTMLElement\n  applyLocalVideoOverlay?: boolean\n}) => {\n  return function* videoElementSaga({\n    instance: room,\n    runSaga,\n  }: CustomSagaParams<RoomSessionConnection>): SagaIterator {\n    try {\n      const layerMap = new Map<string, HTMLDivElement>()\n      const videoEl = buildVideo()\n\n      /**\n       * We used this `LocalOverlay` interface to interact with the localVideo\n       * overlay DOM element in here and in the `layoutChangedHandler`.\n       * The idea is to avoid APIs like `document.getElementById` because it\n       * won't work if the SDK is used within a Shadow DOM tree.\n       * Instead of querying the `document`, let's use our `layerMap`.\n       */\n      const localOverlay: LocalOverlay = {\n        // Each `layout.changed` event will update `status`\n        status: 'hidden',\n        get id() {\n          // FIXME: Use `id` until the `memberId` is stable between promote/demote\n          return addSDKPrefix(room.id)\n        },\n        get domElement() {\n          return layerMap.get(this.id)\n        },\n        set domElement(element: HTMLDivElement | undefined) {\n          if (element) {\n            getLogger().debug('Set localOverlay', element)\n            layerMap.set(this.id, element)\n          } else {\n            getLogger().debug('Remove localOverlay')\n            layerMap.delete(this.id)\n          }\n        },\n        hide() {\n          if (!this.domElement) {\n            return getLogger().warn('Missing localOverlay to hide')\n          }\n          this.domElement.style.opacity = '0'\n        },\n        show() {\n          if (!this.domElement) {\n            return getLogger().warn('Missing localOverlay to show')\n          }\n          if (this.status === 'hidden') {\n            return getLogger().info('localOverlay not visible')\n          }\n          this.domElement.style.opacity = '1'\n        },\n        setLocalOverlayMediaStream(stream: MediaStream) {\n          if (!this.domElement) {\n            return getLogger().warn(\n              'Missing localOverlay to set the local overlay stream'\n            )\n          }\n          const localVideo = this.domElement.querySelector('video')\n          if (localVideo) {\n            localVideo.srcObject = stream\n          }\n        },\n        setLocalOverlayMirror(mirror: boolean) {\n          if (!this.domElement || !this.domElement.firstChild) {\n            return getLogger().warn('Missing localOverlay to set the mirror')\n          }\n          const videoEl = this.domElement.firstChild as HTMLVideoElement\n          if (mirror ?? room.localOverlay.mirrored) {\n            videoEl.style.transform = 'scale(-1, 1)'\n            videoEl.style.webkitTransform = 'scale(-1, 1)'\n          } else {\n            videoEl.style.transform = 'scale(1, 1)'\n            videoEl.style.webkitTransform = 'scale(1, 1)'\n          }\n        },\n      }\n\n      const layoutChangedHandler = makeLayoutChangedHandler({\n        rootElement,\n        localOverlay,\n      })\n\n      let hasVideoTrack = false\n      let lastLayoutChanged: any = null\n\n      const _processLayoutChanged = (params: any) => {\n        // FIXME: expose a method on BaseConnection\n        if (room.peer?.hasVideoSender && room.localStream) {\n          layoutChangedHandler({\n            layout: params.layout,\n            localStream: room.localStream,\n            myMemberId: room.memberId,\n          })\n        } else {\n          localOverlay.hide()\n        }\n      }\n\n      // @ts-expect-error\n      room.on(`${LOCAL_EVENT_PREFIX}.mirror.video`, (value: boolean) => {\n        localOverlay.setLocalOverlayMirror(value)\n      })\n\n      room.on('layout.changed', (params) => {\n        getLogger().debug('Received layout.changed - videoTrack', hasVideoTrack)\n        if (hasVideoTrack) {\n          _processLayoutChanged(params)\n          return\n        }\n\n        lastLayoutChanged = params\n      })\n\n      /**\n       * If the user joins with `join_video_muted: true` or\n       * `join_audio_muted: true` we'll stop the streams\n       * right away.\n       */\n      room.on('room.subscribed', (params) => {\n        const member = params.room_session.members?.find(\n          (m) => m.id === room.memberId\n        )\n\n        if (member?.audio_muted) {\n          try {\n            room.stopOutboundAudio()\n          } catch (error) {\n            getLogger().error('Error handling audio_muted', error)\n          }\n        }\n\n        if (member?.video_muted) {\n          try {\n            room.stopOutboundVideo()\n          } catch (error) {\n            getLogger().error('Error handling video_muted', error)\n          }\n        }\n\n        if (room.localStream) {\n          localOverlay.setLocalOverlayMediaStream(room.localStream)\n        }\n      })\n\n      room.on('member.updated.video_muted', (params) => {\n        try {\n          const { member } = params\n          if (member.id === room.memberId && 'video_muted' in member) {\n            member.video_muted ? localOverlay.hide() : localOverlay.show()\n          }\n        } catch (error) {\n          getLogger().error('Error handling video_muted', error)\n        }\n      })\n\n      let videoTask: Task | undefined\n\n      const trackHandler = function (event: RTCTrackEvent) {\n        switch (event.track.kind) {\n          case 'video': {\n            videoTask = runSaga(videoElementSetupWorker, {\n              applyLocalVideoOverlay,\n              rootElement,\n              track: event.track,\n              element: videoEl,\n            })\n\n            hasVideoTrack = true\n            if (lastLayoutChanged) {\n              _processLayoutChanged(lastLayoutChanged)\n            }\n            break\n          }\n        }\n      }\n      /**\n       * Using `on` instead of `once` (or `off` within trackHandler) because\n       * there are cases (promote/demote) where we need to handle multiple `track`\n       * events and update the videoEl with the new track.\n       */\n      room.on('track', trackHandler)\n\n      room.once('destroy', () => {\n        cleanupElement(rootElement)\n        layerMap.clear()\n        videoTask?.cancel()\n      })\n    } catch (error) {\n      getLogger().error('videoElementSaga', error)\n    }\n  }\n}\n\nexport const makeAudioElementSaga = ({ speakerId }: { speakerId?: string }) => {\n  return function* audioElementSaga({\n    instance: room,\n    runSaga,\n  }: CustomSagaParams<RoomSessionConnection>): SagaIterator {\n    if (typeof Audio === 'undefined') {\n      getLogger().warn('`Audio` is not supported on this environment.')\n      return\n    }\n\n    try {\n      const audioEl = room.getAudioEl()\n      let audioTask: Task | undefined\n\n      const trackHandler = function (event: RTCTrackEvent) {\n        switch (event.track.kind) {\n          case 'audio': {\n            audioTask = runSaga(audioElementSetupWorker, {\n              track: event.track,\n              element: audioEl,\n              speakerId,\n              room,\n            })\n            break\n          }\n        }\n      }\n      /**\n       * Using `on` instead of `once` (or `off` within trackHandler) because\n       * there are cases (promote/demote) where we need to handle multiple `track`\n       * events and update the audioEl with the new track.\n       */\n      room.on('track', trackHandler)\n\n      room.once('destroy', () => {\n        audioTask?.cancel()\n      })\n    } catch (error) {\n      getLogger().error('audioElementSaga', error)\n    }\n  }\n}\n\nfunction* audioElementActionsWatcher({\n  element,\n  room,\n}: {\n  element: HTMLAudioElement\n  room: RoomSessionConnection\n}): SagaIterator {\n  // TODO: For now we're handling individual actions but in the future\n  // we might want to have a single action per custom saga and use it\n  // in a similar fashion to `executeAction`\n  const setSpeakerActionType = actions.getCustomSagaActionType(\n    room.__uuid,\n    audioSetSpeakerAction\n  )\n\n  while (true) {\n    const action = yield sagaEffects.take([setSpeakerActionType])\n\n    try {\n      switch (action.type) {\n        case setSpeakerActionType:\n          const response = yield sagaEffects.call(\n            setMediaElementSinkId,\n            element,\n            action.payload\n          )\n\n          room.emit(\n            // @ts-expect-error\n            `${LOCAL_EVENT_PREFIX}.speaker.updated`,\n            action.payload\n          )\n\n          room.settleCustomSagaTrigger({\n            dispatchId: action.dispatchId,\n            payload: response,\n            kind: 'resolve',\n          })\n          break\n      }\n    } catch (error) {\n      room.settleCustomSagaTrigger({\n        dispatchId: action.dispatchId,\n        payload: error,\n        kind: 'reject',\n      })\n      getLogger().error(error)\n    }\n  }\n}\n\nfunction* audioElementSetupWorker({\n  track,\n  element,\n  speakerId,\n  room,\n}: {\n  track: MediaStreamTrack\n  element: HTMLAudioElement\n  speakerId?: string\n  room: RoomSessionConnection\n}): SagaIterator {\n  setAudioMediaTrack({ track, element })\n  if (speakerId) {\n    // Catch no-op since setMediaElementSinkId already provides logs\n    setMediaElementSinkId(element, speakerId).catch(() => {})\n  }\n\n  yield sagaEffects.fork(audioElementActionsWatcher, {\n    element,\n    room,\n  })\n}\n\nfunction* videoElementSetupWorker({\n  rootElement,\n  applyLocalVideoOverlay = true,\n  track,\n  element,\n}: {\n  // TODO: we'll move this to a separate type once we define how to\n  // dispatch action that only target unique sagas\n  rootElement: HTMLElement\n  applyLocalVideoOverlay?: boolean\n  track: MediaStreamTrack\n  element: HTMLVideoElement\n}): SagaIterator {\n  try {\n    setVideoMediaTrack({ element, track })\n\n    element.style.width = '100%'\n    element.style.maxHeight = '100%'\n\n    if (!applyLocalVideoOverlay) {\n      rootElement.appendChild(element)\n      return\n    }\n    if (rootElement.querySelector('.mcuContent')) {\n      getLogger().debug('MCU Content already there')\n      return\n    }\n\n    const mcuWrapper = document.createElement('div')\n    mcuWrapper.style.position = 'absolute'\n    mcuWrapper.style.top = '0'\n    mcuWrapper.style.left = '0'\n    mcuWrapper.style.right = '0'\n    mcuWrapper.style.bottom = '0'\n    mcuWrapper.appendChild(element)\n\n    const paddingWrapper = document.createElement('div')\n    paddingWrapper.classList.add('paddingWrapper')\n    paddingWrapper.style.paddingBottom = '56.25%'\n    paddingWrapper.style.position = 'relative'\n    paddingWrapper.style.width = '100%'\n    paddingWrapper.appendChild(mcuWrapper)\n\n    const layersWrapper = document.createElement('div')\n    layersWrapper.classList.add('mcuLayers')\n    layersWrapper.style.display = 'none'\n    paddingWrapper.appendChild(layersWrapper)\n\n    const relativeWrapper = document.createElement('div')\n    relativeWrapper.classList.add('mcuContent')\n    relativeWrapper.style.position = 'relative'\n    relativeWrapper.style.width = '100%'\n    relativeWrapper.style.height = '100%'\n    relativeWrapper.style.margin = '0 auto'\n    relativeWrapper.style.display = 'flex'\n    relativeWrapper.style.alignItems = 'center'\n    relativeWrapper.style.justifyContent = 'center'\n    relativeWrapper.appendChild(paddingWrapper)\n\n    rootElement.style.width = '100%'\n    rootElement.style.height = '100%'\n    rootElement.appendChild(relativeWrapper)\n\n    getLogger().debug('MCU readyState 1 >>', element.readyState)\n    if (element.readyState === HTMLMediaElement.HAVE_NOTHING) {\n      getLogger().debug('Wait for the MCU to be ready')\n      yield sagaEffects.call(waitForVideoReady, { element })\n    }\n    getLogger().debug('MCU is ready..')\n\n    const rootElementResizeObserver = createRootElementResizeObserver({\n      rootElement,\n      video: element,\n      paddingWrapper,\n    })\n    rootElementResizeObserver.start()\n    track.addEventListener('ended', () => {\n      if (rootElementResizeObserver) {\n        rootElementResizeObserver.stop()\n      }\n    })\n\n    layersWrapper.style.display = 'block'\n  } catch (error) {\n    getLogger().error('Handle video track error', error)\n  }\n}\n", "import {\n  getLogger,\n  InternalVideoLayoutLayer,\n  InternalVideoLayout,\n  debounce,\n} from '@signalwire/core'\n\nconst addSDKPrefix = (input: string) => {\n  return `sw-sdk-${input}`\n}\n\nconst buildVideo = () => {\n  const video = document.createElement('video')\n  video.muted = true\n  video.autoplay = true\n  video.playsInline = true\n\n  /**\n   * Local and Remov video elements should never be paused\n   * and Safari/Firefox pause the video (ie: enabling PiP, switch cameras etc)\n   * We try to force it to keep playing.\n   */\n  video.addEventListener('pause', () => {\n    video.play().catch((error) => {\n      getLogger().error('Video Element Paused', video, error)\n    })\n  })\n\n  return video\n}\n\nconst waitForVideoReady = ({ element }: { element: HTMLVideoElement }) => {\n  return new Promise<void>((resolve) => {\n    element.addEventListener('canplay', function listener() {\n      element.removeEventListener('canplay', listener)\n      resolve()\n    })\n    element.addEventListener('resize', function listener() {\n      element.removeEventListener('resize', listener)\n      resolve()\n    })\n  })\n}\n\nconst _getLocationStyles = ({\n  x,\n  y,\n  width,\n  height,\n}: InternalVideoLayoutLayer) => {\n  return {\n    top: `${y}%`,\n    left: `${x}%`,\n    width: `${width}%`,\n    height: `${height}%`,\n  }\n}\n\nconst _buildLayer = ({ location }: { location: InternalVideoLayoutLayer }) => {\n  const { top, left, width, height } = _getLocationStyles(location)\n  const layer = document.createElement('div')\n  layer.style.position = 'absolute'\n  layer.style.overflow = 'hidden'\n  layer.style.top = top\n  layer.style.left = left\n  layer.style.width = width\n  layer.style.height = height\n\n  return layer\n}\n\nexport interface LocalOverlay {\n  readonly id: string\n  status: 'hidden' | 'visible'\n  domElement: HTMLDivElement | undefined\n  hide(): void\n  show(): void\n  setLocalOverlayMediaStream(stream: MediaStream): void\n  setLocalOverlayMirror(mirror?: boolean): void\n}\n\ninterface MakeLayoutChangedHandlerParams {\n  localOverlay: LocalOverlay\n  rootElement: HTMLElement\n}\n\ninterface LayoutChangedHandlerParams {\n  layout: InternalVideoLayout\n  myMemberId: string\n  localStream: MediaStream\n}\n\nconst makeLayoutChangedHandler =\n  ({ localOverlay, rootElement }: MakeLayoutChangedHandlerParams) =>\n  async ({ layout, myMemberId, localStream }: LayoutChangedHandlerParams) => {\n    getLogger().debug('Process layout.changed')\n    try {\n      const { layers = [] } = layout\n      const location = layers.find(({ member_id }) => member_id === myMemberId)\n\n      let myLayer = localOverlay.domElement\n      // Update localOverlay.status if a location has been found\n      localOverlay.status = location ? 'visible' : 'hidden'\n      if (!location) {\n        getLogger().debug('Location not found')\n        if (myLayer) {\n          getLogger().debug('Current layer not visible')\n          localOverlay.hide()\n        }\n\n        return\n      }\n\n      if (!myLayer) {\n        getLogger().debug('Build myLayer')\n        myLayer = _buildLayer({ location })\n        myLayer.id = localOverlay.id\n\n        const localVideo = buildVideo()\n        localVideo.srcObject = localStream\n        localVideo.disablePictureInPicture = true\n        localVideo.style.width = '100%'\n        localVideo.style.height = '100%'\n        localVideo.style.pointerEvents = 'none'\n        localVideo.style.objectFit = 'cover'\n\n        myLayer.appendChild(localVideo)\n\n        const mcuLayers = rootElement.querySelector('.mcuLayers')\n        const exists = mcuLayers?.querySelector(`#${myLayer.id}`)\n        if (mcuLayers && !exists) {\n          getLogger().debug('Build myLayer append it')\n          mcuLayers.appendChild(myLayer)\n          localOverlay.domElement = myLayer\n          localOverlay.setLocalOverlayMirror()\n          return\n        }\n\n        getLogger().debug('Build myLayer >> wait next')\n        return\n      }\n\n      const { top, left, width, height } = _getLocationStyles(location)\n      getLogger().debug('Update myLayer:', top, left, width, height)\n      /**\n       * Show myLayer only if the localStream has a valid video track\n       */\n      const hasVideo =\n        localStream\n          .getVideoTracks()\n          .filter((t) => t.enabled && t.readyState === 'live').length > 0\n      if (hasVideo) {\n        localOverlay.setLocalOverlayMediaStream(localStream)\n      }\n      myLayer.style.opacity = hasVideo ? '1' : '0'\n      myLayer.style.top = top\n      myLayer.style.left = left\n      myLayer.style.width = width\n      myLayer.style.height = height\n    } catch (error) {\n      getLogger().error('Layout Changed Error', error)\n    }\n  }\n\nconst cleanupElement = (rootElement: HTMLElement) => {\n  while (rootElement.firstChild) {\n    rootElement.removeChild(rootElement.firstChild)\n  }\n}\n\nconst setVideoMediaTrack = ({\n  track,\n  element,\n}: {\n  track: MediaStreamTrack\n  element: HTMLVideoElement\n}) => {\n  element.srcObject = new MediaStream([track])\n\n  track.addEventListener('ended', () => {\n    element.srcObject = null\n    element.remove()\n  })\n}\n\nconst createRootElementResizeObserver = ({\n  video,\n  rootElement,\n  paddingWrapper,\n}: {\n  video: HTMLVideoElement\n  rootElement: HTMLElement\n  paddingWrapper: HTMLDivElement\n}) => {\n  const computePaddingWrapperWidth = (width: number, height: number) => {\n    const nativeVideoRatio = video.videoWidth / video.videoHeight\n    const rootElementRatio = width / height\n    if (nativeVideoRatio > rootElementRatio) {\n      return '100%'\n    } else {\n      return `${height * nativeVideoRatio}px`\n    }\n  }\n\n  const maxPaddingBottom = (video.videoHeight / video.videoWidth) * 100\n  // debounce to avoid multiple calls\n  const update = debounce(\n    ({ width, height }: { width: number; height: number }) => {\n      if (paddingWrapper) {\n        const pb = (height / width) * 100\n        paddingWrapper.style.paddingBottom = `${\n          pb > maxPaddingBottom ? maxPaddingBottom : pb\n        }%`\n        paddingWrapper.style.width = computePaddingWrapperWidth(width, height)\n      }\n    },\n    100\n  )\n\n  const observer = new ResizeObserver((entries) => {\n    entries.forEach((entry) => {\n      if (entry.contentBoxSize) {\n        // Firefox implements `contentBoxSize` as a single content rect, rather than an array\n        const { inlineSize, blockSize } = Array.isArray(entry.contentBoxSize)\n          ? entry.contentBoxSize[0]\n          : entry.contentBoxSize\n        update({ width: inlineSize, height: blockSize })\n      } else if (entry.contentRect) {\n        update({\n          width: entry.contentRect.width,\n          height: entry.contentRect.height,\n        })\n      }\n    })\n  })\n\n  return {\n    start: () => observer.observe(rootElement),\n    stop: () => observer.disconnect(),\n  }\n}\n\nexport {\n  buildVideo,\n  cleanupElement,\n  makeLayoutChangedHandler,\n  setVideoMediaTrack,\n  waitForVideoReady,\n  addSDKPrefix,\n  createRootElementResizeObserver,\n}\n", "const setAudioMediaTrack = ({\n  track,\n  element,\n}: {\n  track: MediaStreamTrack\n  element: HTMLAudioElement\n}) => {\n  element.autoplay = true\n  // @ts-ignore\n  element.playsinline = true\n  element.srcObject = new MediaStream([track])\n\n  track.addEventListener('ended', () => {\n    element.srcObject = null\n    element.remove()\n  })\n\n  return element\n}\n\nexport { setAudioMediaTrack }\n", "import { actions } from '@signalwire/core'\n\nexport const audioSetSpeakerAction = actions.createAction<string>(\n  'swJs/audioSetSpeakerAction'\n)\n", "import {\n  connect,\n  Rooms,\n  extendComponent,\n  BaseComponentContract,\n  BaseComponentOptions,\n  BaseConnectionContract,\n  VideoAuthorization,\n  LOCAL_EVENT_PREFIX,\n  validateEventsToSubscribe,\n  EventEmitter,\n} from '@signalwire/core'\nimport {\n  getDisplayMedia,\n  BaseConnection,\n  BaseConnectionOptions,\n  BaseConnectionStateEventTypes,\n  supportsMediaOutput,\n  createSpeakerDeviceWatcher,\n  getSpeakerById,\n} from '@signalwire/webrtc'\nimport type {\n  RoomSessionObjectEvents,\n  CreateScreenShareObjectOptions,\n  AddDeviceOptions,\n  AddCameraOptions,\n  AddMicrophoneOptions,\n  BaseRoomInterface,\n  RoomMethods,\n  StartScreenShareOptions,\n  RoomSessionConnectionContract,\n  BaseRoomSessionJoinParams,\n  LocalOverlay,\n} from './utils/interfaces'\nimport { SCREENSHARE_AUDIO_CONSTRAINTS } from './utils/constants'\nimport { audioSetSpeakerAction } from './features/actions'\nimport {\n  RoomSessionScreenShareAPI,\n  RoomSessionScreenShareConnection,\n  RoomSessionScreenShare,\n  RoomSessionScreenShareEvents,\n} from './RoomSessionScreenShare'\nimport {\n  RoomSessionDeviceAPI,\n  RoomSessionDeviceConnection,\n  RoomSessionDevice,\n  RoomSessionDeviceEvents,\n} from './RoomSessionDevice'\nimport * as workers from './video/workers'\n\nexport interface BaseRoomSession<T>\n  extends RoomMethods,\n    RoomSessionConnectionContract,\n    BaseComponentContract,\n    BaseConnectionContract<RoomSessionObjectEvents> {\n  /**\n   * Joins the room session.\n   */\n  join(options?: BaseRoomSessionJoinParams): Promise<T>\n\n  /**\n   * Leaves the room. This detaches all the locally originating streams from the\n   * room.\n   */\n  leave(): Promise<void>\n}\n\nexport class RoomSessionConnection\n  extends BaseConnection<RoomSessionObjectEvents>\n  implements BaseRoomInterface, RoomSessionConnectionContract\n{\n  private _screenShareList = new Set<RoomSessionScreenShare>()\n  private _deviceList = new Set<RoomSessionDevice>()\n  private _mirrored: LocalOverlay['mirrored']\n  private _audioEl:\n    | HTMLAudioElement & {\n        sinkId?: string\n        setSinkId?: (id: string) => Promise<void>\n      }\n\n  constructor(\n    options: BaseConnection<RoomSessionObjectEvents> & {\n      mirrorLocalVideoOverlay: boolean\n    }\n  ) {\n    super(options)\n    this._mirrored = options.mirrorLocalVideoOverlay\n\n    this.runWorker('videoWorker', {\n      worker: workers.videoWorker,\n    })\n  }\n\n  get screenShareList() {\n    return Array.from(this._screenShareList)\n  }\n\n  get deviceList() {\n    return Array.from(this._deviceList)\n  }\n\n  get interactivityMode() {\n    return this.select(({ session }) => {\n      const { authState } = session\n      return (authState as VideoAuthorization)?.join_as ?? ''\n    })\n  }\n\n  get permissions() {\n    return this.select(({ session }) => {\n      const { authState } = session\n      return (authState as VideoAuthorization)?.room?.scopes ?? []\n    })\n  }\n\n  /**\n   * This method will be called by `join()` right before the\n   * `connect()` happens and it's a way for us to control\n   * exactly when the workers are attached.\n   * @internal\n   */\n  protected attachPreConnectWorkers() {\n    this.runWorker('memberListUpdated', {\n      worker: workers.memberListUpdatedWorker,\n    })\n  }\n\n  /** @deprecated Use {@link startScreenShare} instead. */\n  async createScreenShareObject(opts: CreateScreenShareObjectOptions = {}) {\n    return this.startScreenShare(opts)\n  }\n\n  /**\n   * Allow sharing the screen within the room.\n   */\n  async startScreenShare(opts: StartScreenShareOptions = {}) {\n    return new Promise<RoomSessionScreenShare>(async (resolve, reject) => {\n      const {\n        autoJoin = true,\n        audio = false,\n        video = true,\n        layout,\n        positions,\n      } = opts\n      const displayStream: MediaStream = await getDisplayMedia({\n        audio: audio === true ? SCREENSHARE_AUDIO_CONSTRAINTS : audio,\n        video,\n      })\n      const options: BaseConnectionOptions = {\n        ...this.options,\n        screenShare: true,\n        recoverCall: false,\n        localStream: displayStream,\n        remoteStream: undefined,\n        userVariables: {\n          ...(this.options?.userVariables || {}),\n          memberCallId: this.callId,\n          memberId: this.memberId,\n        },\n        layout,\n        positions,\n      }\n\n      const screenShare = connect<\n        RoomSessionScreenShareEvents,\n        RoomSessionScreenShareConnection,\n        RoomSessionScreenShare\n      >({\n        store: this.store,\n        Component: RoomSessionScreenShareAPI,\n      })(options)\n\n      /**\n       * Hangup if the user stop the screenShare from the\n       * native browser button or if the videoTrack ends.\n       */\n      displayStream.getVideoTracks().forEach((t) => {\n        t.addEventListener('ended', () => {\n          if (screenShare && screenShare.active) {\n            screenShare.leave()\n          }\n        })\n      })\n\n      screenShare.once('destroy', () => {\n        screenShare.emit('room.left')\n        this._screenShareList.delete(screenShare)\n      })\n\n      try {\n        screenShare.runWorker('childMemberJoinedWorker', {\n          worker: workers.childMemberJoinedWorker,\n          onDone: () => resolve(screenShare),\n          onFail: reject,\n          initialState: {\n            parentId: this.memberId,\n          },\n        })\n\n        this._screenShareList.add(screenShare)\n        if (autoJoin) {\n          return await screenShare.join()\n        }\n        return resolve(screenShare)\n      } catch (error) {\n        this.logger.error('ScreenShare Error', error)\n        reject(error)\n      }\n    })\n  }\n\n  /**\n   * Allow to add a camera to the room.\n   */\n  addCamera(opts: AddCameraOptions = {}) {\n    const { autoJoin = true, ...video } = opts\n    return this.addDevice({\n      autoJoin,\n      video,\n    })\n  }\n\n  /**\n   * Allow to add a microphone to the room.\n   */\n  addMicrophone(opts: AddMicrophoneOptions = {}) {\n    const { autoJoin = true, ...audio } = opts\n    return this.addDevice({\n      autoJoin,\n      audio,\n    })\n  }\n\n  /**\n   * Allow to add additional devices to the room like cameras or microphones.\n   */\n  async addDevice(opts: AddDeviceOptions = {}) {\n    return new Promise<RoomSessionDevice>(async (resolve, reject) => {\n      const { autoJoin = true, audio = false, video = false } = opts\n      if (!audio && !video) {\n        throw new TypeError(\n          'At least one of `audio` or `video` must be requested.'\n        )\n      }\n\n      const options: BaseConnectionOptions = {\n        ...this.options,\n        localStream: undefined,\n        remoteStream: undefined,\n        audio,\n        video,\n        additionalDevice: true,\n        recoverCall: false,\n        userVariables: {\n          ...(this.options?.userVariables || {}),\n          memberCallId: this.callId,\n          memberId: this.memberId,\n        },\n      }\n\n      const roomDevice = connect<\n        RoomSessionDeviceEvents,\n        RoomSessionDeviceConnection,\n        RoomSessionDevice\n      >({\n        store: this.store,\n        Component: RoomSessionDeviceAPI,\n      })(options)\n\n      roomDevice.once('destroy', () => {\n        roomDevice.emit('room.left')\n        this._deviceList.delete(roomDevice)\n      })\n\n      try {\n        roomDevice.runWorker('childMemberJoinedWorker', {\n          worker: workers.childMemberJoinedWorker,\n          onDone: () => resolve(roomDevice),\n          onFail: reject,\n          initialState: {\n            parentId: this.memberId,\n          },\n        })\n\n        this._deviceList.add(roomDevice)\n        if (autoJoin) {\n          return await roomDevice.join()\n        }\n        return resolve(roomDevice)\n      } catch (error) {\n        this.logger.error('RoomDevice Error', error)\n        reject(error)\n      }\n    })\n  }\n\n  join() {\n    return super.invite<BaseRoomSession<this>>()\n  }\n\n  leave() {\n    return this.hangup()\n  }\n\n  updateSpeaker({ deviceId }: { deviceId: string }) {\n    const prevId = this._audioEl.sinkId as string\n    this.once(\n      // @ts-expect-error\n      `${LOCAL_EVENT_PREFIX}.speaker.updated`,\n      async (newId: string) => {\n        const prevSpeaker = await getSpeakerById(prevId)\n        const newSpeaker = await getSpeakerById(newId)\n\n        const isSame = newSpeaker?.deviceId === prevSpeaker?.deviceId\n        if (!newSpeaker?.deviceId || isSame) return\n\n        this.emit('speaker.updated', {\n          previous: {\n            deviceId: prevSpeaker?.deviceId,\n            label: prevSpeaker?.label,\n          },\n          current: {\n            deviceId: newSpeaker.deviceId,\n            label: newSpeaker.label,\n          },\n        })\n      }\n    )\n\n    return this.triggerCustomSaga<undefined>(audioSetSpeakerAction(deviceId))\n  }\n\n  private _attachSpeakerTrackListener() {\n    if (!supportsMediaOutput()) return\n\n    // @TODO: Stop the watcher when user leave/disconnects\n    createSpeakerDeviceWatcher().then((deviceWatcher) => {\n      deviceWatcher.on('removed', async (data) => {\n        const sinkId = this._audioEl.sinkId\n        const disconnectedSpeaker = data.changes.find((device) => {\n          const payloadDeviceId = device.payload.deviceId\n\n          return (\n            payloadDeviceId === sinkId ||\n            (payloadDeviceId === '' && sinkId === 'default') ||\n            (payloadDeviceId === 'default' && sinkId === '')\n          )\n        })\n        if (disconnectedSpeaker) {\n          this.emit('speaker.disconnected', {\n            deviceId: disconnectedSpeaker.payload.deviceId,\n            label: disconnectedSpeaker.payload.label,\n          })\n\n          /**\n           * In case the currently in-use speaker disconnects, OS by default fallbacks to the default speaker\n           * Set the sink id here to make the SDK consistent with the OS\n           */\n          await this._audioEl.setSinkId?.('')\n\n          const defaultSpeakers = await getSpeakerById('default')\n\n          if (!defaultSpeakers?.deviceId) return\n\n          // Emit the speaker.updated event since the OS will fallback to the default speaker\n          this.emit('speaker.updated', {\n            previous: {\n              deviceId: disconnectedSpeaker.payload.deviceId,\n              label: disconnectedSpeaker.payload.label,\n            },\n            current: {\n              deviceId: defaultSpeakers.deviceId,\n              label: defaultSpeakers.label,\n            },\n          })\n        }\n      })\n    })\n  }\n\n  getAudioEl() {\n    if (this._audioEl) return this._audioEl\n    this._audioEl = new Audio()\n    this._attachSpeakerTrackListener()\n    return this._audioEl\n  }\n\n  /** @internal */\n  override async hangup(id?: string) {\n    this._screenShareList.forEach((screenShare) => {\n      screenShare.leave()\n    })\n    this._deviceList.forEach((device) => {\n      device.leave()\n    })\n\n    return super.hangup(id)\n  }\n\n  /** @internal */\n  protected _finalize() {\n    this._screenShareList.clear()\n    this._deviceList.clear()\n\n    super._finalize()\n  }\n\n  /**\n   * @deprecated Use {@link getLayouts} instead. `getLayoutList` will\n   * be removed in v3.0.0\n   */\n  getLayoutList() {\n    // @ts-expect-error\n    return this.getLayouts()\n  }\n\n  /**\n   * @deprecated Use {@link getMembers} instead. `getMemberList` will\n   * be removed in v3.0.0\n   */\n  getMemberList() {\n    // @ts-expect-error\n    return this.getMembers()\n  }\n\n  /**\n   * Local video stream overlay\n   */\n  get localOverlay() {\n    return {\n      mirrored: this._mirrored,\n      setMirrored: (value: boolean) => {\n        this._mirrored = value\n        this.emit(\n          // @ts-expect-error\n          `${LOCAL_EVENT_PREFIX}.mirror.video`,\n          this._mirrored\n        )\n      },\n    }\n  }\n\n  /** @internal */\n  protected override getSubscriptions() {\n    const eventNamesWithPrefix = this.eventNames().map(\n      (event) => `video.${event}`\n    ) as EventEmitter.EventNames<RoomSessionObjectEvents>[]\n    return validateEventsToSubscribe(eventNamesWithPrefix)\n  }\n}\n\nexport const RoomSessionAPI = extendComponent<\n  RoomSessionConnection,\n  RoomMethods\n>(RoomSessionConnection, {\n  audioMute: Rooms.audioMuteMember,\n  audioUnmute: Rooms.audioUnmuteMember,\n  videoMute: Rooms.videoMuteMember,\n  videoUnmute: Rooms.videoUnmuteMember,\n  deaf: Rooms.deafMember,\n  undeaf: Rooms.undeafMember,\n  setInputVolume: Rooms.setInputVolumeMember,\n  setOutputVolume: Rooms.setOutputVolumeMember,\n  setMicrophoneVolume: Rooms.setInputVolumeMember,\n  setSpeakerVolume: Rooms.setOutputVolumeMember,\n  setInputSensitivity: Rooms.setInputSensitivityMember,\n  removeMember: Rooms.removeMember,\n  removeAllMembers: Rooms.removeAllMembers,\n  getMembers: Rooms.getMembers,\n  getLayouts: Rooms.getLayouts,\n  setLayout: Rooms.setLayout,\n  setPositions: Rooms.setPositions,\n  setMemberPosition: Rooms.setMemberPosition,\n  hideVideoMuted: Rooms.hideVideoMuted,\n  showVideoMuted: Rooms.showVideoMuted,\n  getRecordings: Rooms.getRecordings,\n  startRecording: Rooms.startRecording,\n  getPlaybacks: Rooms.getPlaybacks,\n  play: Rooms.play,\n  setHideVideoMuted: Rooms.setHideVideoMuted,\n  getMeta: Rooms.getMeta,\n  setMeta: Rooms.setMeta,\n  updateMeta: Rooms.updateMeta,\n  deleteMeta: Rooms.deleteMeta,\n  getMemberMeta: Rooms.getMemberMeta,\n  setMemberMeta: Rooms.setMemberMeta,\n  updateMemberMeta: Rooms.updateMemberMeta,\n  deleteMemberMeta: Rooms.deleteMemberMeta,\n  promote: Rooms.promote,\n  demote: Rooms.demote,\n  getStreams: Rooms.getStreams,\n  startStream: Rooms.startStream,\n  lock: Rooms.lock,\n  unlock: Rooms.unlock,\n  setRaisedHand: Rooms.setRaisedHand,\n  setPrioritizeHandraise: Rooms.setPrioritizeHandraise,\n})\n\ntype RoomSessionObjectEventsHandlerMapping = RoomSessionObjectEvents &\n  BaseConnectionStateEventTypes\n\n/** @internal */\nexport const createBaseRoomSessionObject = <RoomSessionType>(\n  params: BaseComponentOptions\n): BaseRoomSession<RoomSessionType> => {\n  const room = connect<\n    RoomSessionObjectEventsHandlerMapping,\n    RoomSessionConnection,\n    BaseRoomSession<RoomSessionType>\n  >({\n    store: params.store,\n    customSagas: params.customSagas,\n    Component: RoomSessionAPI,\n  })(params)\n\n  return room\n}\n", "export const SCREENSHARE_AUDIO_CONSTRAINTS: MediaTrackConstraints = {\n  echoCancellation: true,\n  noiseSuppression: false,\n  autoGainControl: false,\n  // @ts-expect-error\n  googAutoGainControl: false,\n}\n", "import {\n  Rooms,\n  extendComponent,\n  BaseConnectionContract,\n  BaseConnectionState,\n  RoomLeft,\n  RoomLeftEventParams,\n} from '@signalwire/core'\nimport { BaseConnection, MediaEvent } from '@signalwire/webrtc'\nimport { RoomScreenShareMethods } from './utils/interfaces'\n\ntype RoomSessionScreenShareEventsHandlerMap = Record<\n  BaseConnectionState,\n  (params: RoomSessionScreenShare) => void\n> &\n  Record<RoomLeft, (params?: RoomLeftEventParams) => void> &\n  Record<MediaEvent, () => void>\n\nexport type RoomSessionScreenShareEvents = {\n  [k in keyof RoomSessionScreenShareEventsHandlerMap]: RoomSessionScreenShareEventsHandlerMap[k]\n}\n\n/** @deprecated Use {@link RoomSessionScreenShare} instead */\nexport interface RoomScreenShare extends RoomSessionScreenShare {}\nexport interface RoomSessionScreenShare\n  extends RoomScreenShareMethods,\n    BaseConnectionContract<RoomSessionScreenShareEvents> {\n  join(): Promise<void>\n  leave(): Promise<void>\n  /** @internal */\n  runWorker: BaseConnection<RoomSessionScreenShareEvents>['runWorker']\n}\n\nexport class RoomSessionScreenShareConnection extends BaseConnection<RoomSessionScreenShareEvents> {\n  join() {\n    return super.invite()\n  }\n\n  leave() {\n    return super.hangup()\n  }\n}\n\n/**\n * Represents a screen sharing.\n */\nexport const RoomSessionScreenShareAPI = extendComponent<\n  RoomSessionScreenShareConnection,\n  RoomScreenShareMethods\n>(RoomSessionScreenShareConnection, {\n  audioMute: Rooms.audioMuteMember,\n  audioUnmute: Rooms.audioUnmuteMember,\n  videoMute: Rooms.videoMuteMember,\n  videoUnmute: Rooms.videoUnmuteMember,\n  setMicrophoneVolume: Rooms.setInputVolumeMember,\n  setInputVolume: Rooms.setInputVolumeMember,\n  setInputSensitivity: Rooms.setInputSensitivityMember,\n})\n", "import {\n  Rooms,\n  extendComponent,\n  BaseConnectionContract,\n  BaseConnectionState,\n  RoomLeft,\n  RoomLeftEventParams,\n} from '@signalwire/core'\nimport { BaseConnection, MediaEvent } from '@signalwire/webrtc'\nimport { RoomSessionDeviceMethods } from './utils/interfaces'\n\ntype RoomSessionDeviceEventsHandlerMap = Record<\n  BaseConnectionState,\n  (params: RoomSessionDevice) => void\n> &\n  Record<RoomLeft, (params?: RoomLeftEventParams) => void> &\n  Record<MediaEvent, () => void>\n\nexport type RoomSessionDeviceEvents = {\n  [k in keyof RoomSessionDeviceEventsHandlerMap]: RoomSessionDeviceEventsHandlerMap[k]\n}\n\n/** @deprecated Use {@link RoomSessionDevice} instead */\nexport interface RoomDevice extends RoomSessionDevice {}\nexport interface RoomSessionDevice\n  extends RoomSessionDeviceMethods,\n    BaseConnectionContract<RoomSessionDeviceEvents> {\n  join(): Promise<void>\n  leave(): Promise<void>\n  /** @internal */\n  runWorker: BaseConnection<RoomSessionDeviceEvents>['runWorker']\n}\n\nexport class RoomSessionDeviceConnection extends BaseConnection<RoomSessionDeviceEvents> {\n  join() {\n    return super.invite()\n  }\n\n  leave() {\n    return super.hangup()\n  }\n}\n\n/**\n * A RoomSessionDevice represents a device (such as a microphone or a camera)\n * that is at some point in its lifetime part of a {@link RoomSession}. You can\n * obtain a RoomSessionDevice from the {@link RoomSession} methods\n * {@link RoomSession.addCamera}, {@link RoomSession.addMicrophone}, and\n * {@link RoomSession.addDevice}.\n */\nexport const RoomSessionDeviceAPI = extendComponent<\n  RoomSessionDeviceConnection,\n  RoomSessionDeviceMethods\n>(RoomSessionDeviceConnection, {\n  audioMute: Rooms.audioMuteMember,\n  audioUnmute: Rooms.audioUnmuteMember,\n  videoMute: Rooms.videoMuteMember,\n  videoUnmute: Rooms.videoUnmuteMember,\n  setInputVolume: Rooms.setInputVolumeMember,\n  setMicrophoneVolume: Rooms.setInputVolumeMember,\n  setInputSensitivity: Rooms.setInputSensitivityMember,\n})\n", "import {\n  sagaEffects,\n  SagaIterator,\n  SDKWorker,\n  toSyntheticEvent,\n  validateEventsToSubscribe,\n  toInternalEventName,\n  SwEventChannel,\n  InternalVideoMemberEntity,\n  InternalVideoMemberUpdatedEvent,\n  VideoMemberJoinedEvent,\n  VideoMemberLeftEvent,\n  VideoMemberUpdatedEvent,\n  InternalVideoRoomJoinedEvent,\n  MapToPubSubShape,\n} from '@signalwire/core'\nimport type { RoomSession } from '../RoomSession'\nimport type { VideoMemberListUpdatedParams } from '../utils/interfaces'\n\nconst noop = () => {}\n\nconst EXTERNAL_MEMBER_LIST_UPDATED_EVENT = 'memberList.updated'\n\nconst INTERNAL_MEMBER_LIST_UPDATED_EVENT = toInternalEventName({\n  event: EXTERNAL_MEMBER_LIST_UPDATED_EVENT,\n})\n\nconst SYNTHETIC_MEMBER_LIST_UPDATED_EVENT = toSyntheticEvent(\n  INTERNAL_MEMBER_LIST_UPDATED_EVENT\n)\n\n/**\n * List of action types this worker cares about.\n */\ntype MemberListUpdatedTargetActions = MapToPubSubShape<\n  | InternalVideoRoomJoinedEvent\n  | InternalVideoMemberUpdatedEvent\n  | VideoMemberJoinedEvent\n  | VideoMemberLeftEvent\n  | VideoMemberUpdatedEvent\n>\n\nconst MEMBER_LIST_EVENTS: Array<MemberListUpdatedTargetActions['type']> = [\n  /** Alias to `video.room.subscribed` */\n  'video.room.joined',\n  'video.member.joined',\n  'video.member.left',\n  'video.member.updated',\n]\n\ntype MemberList = Map<string, InternalVideoMemberEntity>\n\nconst isMemberListEvent = (\n  event: string\n): event is MemberListUpdatedTargetActions['type'] => {\n  // @ts-expect-error\n  return MEMBER_LIST_EVENTS.includes(event)\n}\n\nconst getMemberListEventsToSubscribe = (\n  subscriptions: MemberListUpdatedTargetActions['type'][]\n) => {\n  return validateEventsToSubscribe(MEMBER_LIST_EVENTS).filter((event) => {\n    return !subscriptions.includes(event)\n  })\n}\n\nconst shouldHandleMemberList = (subscriptions: string[]) => {\n  return subscriptions.some((event) =>\n    event.includes(EXTERNAL_MEMBER_LIST_UPDATED_EVENT)\n  )\n}\n\nconst getMembersFromAction = (action: MemberListUpdatedTargetActions) => {\n  if (action.type === 'video.room.joined') {\n    return action.payload.room_session.members\n  }\n\n  return [action.payload.member]\n}\n\nexport const getUpdatedMembers = ({\n  action,\n  memberList,\n}: {\n  action: MemberListUpdatedTargetActions\n  memberList: MemberList\n}) => {\n  const actionMembers = getMembersFromAction(action)\n\n  switch (action.type) {\n    case 'video.member.left':\n      actionMembers.forEach((member: InternalVideoMemberEntity) => {\n        memberList.delete(member.id)\n      })\n      break\n    default:\n      actionMembers.forEach((member: InternalVideoMemberEntity) => {\n        memberList.set(member.id, member)\n      })\n  }\n\n  return Array.from(memberList.values())\n}\n\nconst initMemberListSubscriptions = (\n  room: RoomSession,\n  subscriptions: MemberListUpdatedTargetActions['type'][]\n) => {\n  const events = getMemberListEventsToSubscribe(subscriptions)\n\n  events.forEach((event) => {\n    /**\n     * Params to `subscribe` come from the event handlers\n     * the user has attached so to make sure we subscribe to\n     * all the appropiate events needed for\n     * `memberList.updated` to work, we must subscribe to\n     * the required events. We don't need to act upon the\n     * event (that's why we attach a `noop`), just to\n     * register it (`subscribe` gets its values from\n     * `BaseComponent.getSubscriptions`, which gets\n     * populated by each of the  event handlers the user\n     * attached).\n     */\n    room.once(event as any, noop)\n  })\n\n  /**\n   * This handler will act as a simple bridge between\n   * synthetic events and external events.\n   */\n  const eventBridgeHandler = ({ members }: VideoMemberListUpdatedParams) => {\n    room.emit(EXTERNAL_MEMBER_LIST_UPDATED_EVENT, { members })\n  }\n\n  // @ts-expect-error\n  room.on(SYNTHETIC_MEMBER_LIST_UPDATED_EVENT, eventBridgeHandler)\n\n  /**\n   * Any events attached by the saga should be specified\n   * here so it can be cleaned up when needed.\n   */\n  const cleanup = () => {\n    // @ts-expect-error\n    room.off(SYNTHETIC_MEMBER_LIST_UPDATED_EVENT, eventBridgeHandler)\n  }\n\n  return {\n    cleanup,\n  }\n}\n\nfunction* membersListUpdatedWatcher({\n  swEventChannel,\n  instance,\n}: {\n  swEventChannel: SwEventChannel\n  instance: any\n}): SagaIterator {\n  const memberList: MemberList = new Map()\n\n  function* worker(pubSubAction: MemberListUpdatedTargetActions) {\n    const roomSessionId =\n      pubSubAction.type === 'video.room.joined'\n        ? pubSubAction.payload.room_session.id\n        : pubSubAction.payload.room_session_id\n\n    const members = getUpdatedMembers({ action: pubSubAction, memberList })\n    const memberListPayload = {\n      /**\n       * At this point it's needed to send the\n       * `room_session_id` so the pubSubSaga can properly\n       * infer the namespace for emitting the events to the\n       * appropiate room.\n       */\n      room_session_id: roomSessionId,\n      members,\n    }\n\n    instance.emit(SYNTHETIC_MEMBER_LIST_UPDATED_EVENT, memberListPayload)\n  }\n\n  while (true) {\n    const pubSubAction: MemberListUpdatedTargetActions = yield sagaEffects.take(\n      swEventChannel,\n      ({ type }: any) => {\n        return isMemberListEvent(type)\n      }\n    )\n\n    yield sagaEffects.fork(worker, pubSubAction)\n  }\n}\n\nexport const memberListUpdatedWorker: SDKWorker<RoomSession> =\n  function* membersChangedWorker({\n    channels: { swEventChannel },\n    instance,\n  }): SagaIterator {\n    // @ts-expect-error\n    const subscriptions = instance.getSubscriptions()\n\n    if (!shouldHandleMemberList(subscriptions)) {\n      return\n    }\n\n    const { cleanup } = initMemberListSubscriptions(instance, subscriptions)\n\n    yield sagaEffects.fork(membersListUpdatedWatcher, {\n      swEventChannel,\n      instance,\n    })\n\n    instance.once('destroy', () => {\n      cleanup()\n    })\n  }\n", "import {\n  getLogger,\n  sagaEffects,\n  SagaIterator,\n  SDKWorker,\n  SDKActions,\n  MapToPubSubShape,\n  SDKWorkerHooks,\n  VideoMemberJoinedEvent,\n  componentSelectors,\n  componentActions,\n  type ReduxComponent,\n} from '@signalwire/core'\n\nimport type { BaseConnection } from '@signalwire/webrtc'\n\ntype ChildMemberJoinedWorkerOnDone = () => void\ntype ChildMemberJoinedWorkerOnFail = (args: { error: Error }) => void\n\nexport type ChildMemberJoinedWorkerHooks = SDKWorkerHooks<\n  ChildMemberJoinedWorkerOnDone,\n  ChildMemberJoinedWorkerOnFail\n>\n\nexport const childMemberJoinedWorker: SDKWorker<\n  BaseConnection<any>,\n  ChildMemberJoinedWorkerHooks\n> = function* (options): SagaIterator {\n  getLogger().trace('childMemberJoinedWorker started')\n  const { channels, instance, initialState, onDone, onFail } = options\n  const { swEventChannel } = channels\n  const { parentId } = initialState\n  if (!parentId) {\n    throw new Error('Missing parentId for childMemberJoinedWorker')\n  }\n\n  const action: MapToPubSubShape<VideoMemberJoinedEvent> =\n    yield sagaEffects.take(swEventChannel, (action: SDKActions) => {\n      if (action.type === 'video.member.joined') {\n        return action.payload.member.parent_id === parentId\n      }\n      return false\n    })\n\n  /**\n   * On video.member.joined with a parent_id, check if we are the\n   * owner of the object comparing parent_id in the state.\n   * If so update the state with the room values to update the\n   * object.\n   */\n  const { member } = action.payload\n  if (member?.parent_id) {\n    const byId: Record<string, ReduxComponent> = yield sagaEffects.select(\n      componentSelectors.getComponentsById\n    )\n    const parent = Object.values(byId).find((row) => {\n      return 'memberId' in row && row.memberId === member.parent_id\n    })\n    if (parent) {\n      yield sagaEffects.put(\n        componentActions.upsert({\n          id: instance.callId,\n          roomId: action.payload.room_id,\n          roomSessionId: action.payload.room_session_id,\n          memberId: member.id,\n        })\n      )\n\n      onDone?.()\n    } else {\n      onFail?.({ error: new Error('Unknown parent_id') })\n    }\n  }\n  getLogger().trace('childMemberJoinedWorker ended')\n}\n", "import {\n  MapToPubSubShape,\n  SDKActions,\n  SDKWorker,\n  SagaIterator,\n  VideoAPIEventParams,\n  getLogger,\n  sagaEffects,\n  SDKWorkerParams,\n  MemberPosition,\n  VideoAPIEventNames,\n  stripNamespacePrefix,\n} from '@signalwire/core'\nimport { RoomSessionConnection } from '../BaseRoomSession'\nimport { videoStreamWorker } from './videoStreamWorker'\nimport { videoRecordWorker } from './videoRecordWorker'\nimport { videoPlaybackWorker } from './videoPlaybackWorker'\n\nexport type VideoWorkerParams<T> = SDKWorkerParams<RoomSessionConnection> & {\n  action: T\n}\n\nexport const videoWorker: SDKWorker<RoomSessionConnection> = function* (\n  options\n): SagaIterator {\n  const { channels, instance: roomSession } = options\n  const { swEventChannel } = channels\n\n  function* worker(action: MapToPubSubShape<VideoAPIEventParams>) {\n    const { type, payload } = action\n\n    switch (type) {\n      case 'video.room.subscribed':\n        yield sagaEffects.spawn(MemberPosition.memberPositionWorker, {\n          ...options,\n          instance: roomSession,\n          initialState: payload,\n        })\n        break\n      case 'video.playback.started':\n      case 'video.playback.updated':\n      case 'video.playback.ended':\n        yield sagaEffects.fork(videoPlaybackWorker, {\n          action,\n          ...options,\n        })\n        return // Return since we don't need to handle the raw event for this\n      case 'video.recording.started':\n      case 'video.recording.updated':\n      case 'video.recording.ended':\n        yield sagaEffects.fork(videoRecordWorker, {\n          action,\n          ...options,\n        })\n        return\n      case 'video.stream.ended':\n      case 'video.stream.started':\n        yield sagaEffects.fork(videoStreamWorker, {\n          action,\n          ...options,\n        })\n        return\n      case 'video.room.audience_count': {\n        roomSession.emit('room.audienceCount', payload)\n        return\n      }\n      case 'video.member.talking': {\n        const { member } = payload\n        if ('talking' in member) {\n          const suffix = member.talking ? 'started' : 'ended'\n          roomSession.emit(`member.talking.${suffix}`, payload)\n\n          // Keep for backwards compat.\n          const deprecatedSuffix = member.talking ? 'start' : 'stop'\n          roomSession.emit(`member.talking.${deprecatedSuffix}`, payload)\n        }\n        break // Break here since we do need the raw event sent to the client\n      }\n      default:\n        break\n    }\n\n    roomSession.emit(stripNamespacePrefix(type) as VideoAPIEventNames, payload)\n  }\n\n  const isVideoEvent = (action: SDKActions) => action.type.startsWith('video.')\n\n  while (true) {\n    const action: MapToPubSubShape<VideoAPIEventParams> =\n      yield sagaEffects.take(swEventChannel, isVideoEvent)\n\n    yield sagaEffects.fork(worker, action)\n  }\n\n  getLogger().trace('videoWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  MapToPubSubShape,\n  VideoStreamEvent,\n  RoomSessionStream,\n  Rooms,\n} from '@signalwire/core'\nimport { VideoWorkerParams } from './videoWorker'\n\nexport const videoStreamWorker = function* (\n  options: VideoWorkerParams<MapToPubSubShape<VideoStreamEvent>>\n): SagaIterator {\n  getLogger().trace('videoStreamWorker started')\n  const {\n    instance: roomSession,\n    action: { type, payload },\n    instanceMap: { get, set, remove },\n  } = options\n\n  // For now, we are not storing the RoomSession object in the instance map\n\n  let streamInstance = get<RoomSessionStream>(payload.stream.id)\n  if (!streamInstance) {\n    streamInstance = Rooms.createRoomSessionStreamObject({\n      store: roomSession.store,\n      payload,\n    })\n  } else {\n    streamInstance.setPayload(payload)\n  }\n  set<RoomSessionStream>(payload.stream.id, streamInstance)\n\n  switch (type) {\n    case 'video.stream.started':\n      roomSession.emit('stream.started', streamInstance)\n      break\n    case 'video.stream.ended':\n      roomSession.emit('stream.ended', streamInstance)\n      remove<RoomSessionStream>(payload.stream.id)\n      break\n    default:\n      getLogger().warn(`Unknown video.stream event: \"${type}\"`)\n      break\n  }\n\n  getLogger().trace('videoStreamWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  MapToPubSubShape,\n  RoomSessionRecording,\n  Rooms,\n  VideoRecordingEvent,\n  VideoRecordingEventNames,\n  stripNamespacePrefix,\n} from '@signalwire/core'\nimport { VideoWorkerParams } from './videoWorker'\n\nexport const videoRecordWorker = function* (\n  options: VideoWorkerParams<MapToPubSubShape<VideoRecordingEvent>>\n): SagaIterator {\n  getLogger().trace('videoRecordWorker started')\n  const {\n    instance: roomSession,\n    action: { type, payload },\n    instanceMap: { get, set, remove },\n  } = options\n\n  // For now, we are not storing the RoomSession object in the instance map\n\n  let recordingInstance = get<RoomSessionRecording>(payload.recording.id)\n  if (!recordingInstance) {\n    recordingInstance = Rooms.createRoomSessionRecordingObject({\n      store: roomSession.store,\n      payload,\n    })\n  } else {\n    recordingInstance.setPayload(payload)\n  }\n  set<RoomSessionRecording>(payload.recording.id, recordingInstance)\n\n  const event = stripNamespacePrefix(type) as VideoRecordingEventNames\n\n  switch (type) {\n    case 'video.recording.started':\n    case 'video.recording.updated': {\n      roomSession.emit(event, recordingInstance)\n      break\n    }\n    case 'video.recording.ended':\n      roomSession.emit(event, recordingInstance)\n      remove<RoomSessionRecording>(payload.recording.id)\n      break\n    default:\n      getLogger().warn(`Unknown video.stream event: \"${type}\"`)\n      break\n  }\n\n  getLogger().trace('videoRecordWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  MapToPubSubShape,\n  RoomSessionPlayback,\n  Rooms,\n  VideoPlaybackEvent,\n  VideoPlaybackEventNames,\n  stripNamespacePrefix,\n} from '@signalwire/core'\nimport { VideoWorkerParams } from './videoWorker'\n\nexport const videoPlaybackWorker = function* (\n  options: VideoWorkerParams<MapToPubSubShape<VideoPlaybackEvent>>\n): SagaIterator {\n  getLogger().trace('videoPlaybackWorker started')\n  const {\n    instance: roomSession,\n    action: { type, payload },\n    instanceMap: { get, set, remove },\n  } = options\n\n  // For now, we are not storing the RoomSession object in the instance map\n\n  let playbackInstance = get<RoomSessionPlayback>(payload.playback.id)\n  if (!playbackInstance) {\n    playbackInstance = Rooms.createRoomSessionPlaybackObject({\n      store: roomSession.store,\n      payload,\n    })\n  } else {\n    playbackInstance.setPayload(payload)\n  }\n  set<RoomSessionPlayback>(payload.playback.id, playbackInstance)\n\n  const event = stripNamespacePrefix(type) as VideoPlaybackEventNames\n\n  switch (type) {\n    case 'video.playback.started':\n    case 'video.playback.updated': {\n      roomSession.emit(event, playbackInstance)\n      break\n    }\n    case 'video.playback.ended':\n      roomSession.emit(event, playbackInstance)\n      remove<RoomSessionPlayback>(payload.playback.id)\n      break\n    default:\n      getLogger().warn(`Unknown video.stream event: \"${type}\"`)\n      break\n  }\n\n  getLogger().trace('videoPlaybackWorker ended')\n}\n", "import {\n  BaseComponentOptions,\n  VideoManagerRoomEventNames,\n  connect,\n  ConsumerContract,\n  VideoManagerRoomEntity,\n  validateEventsToSubscribe,\n  EventEmitter,\n  BaseConsumer,\n} from '@signalwire/core'\nimport { videoManagerWorker } from './workers'\n\n/** @internal */\nexport type VideoManagerEvents = Record<\n  VideoManagerRoomEventNames,\n  (room: VideoManagerRoomEntity) => void\n>\n\n/** @internal */\nexport interface VideoManager extends ConsumerContract<VideoManagerEvents> {}\n\n/** @internal */\nexport class VideoManagerAPI extends BaseConsumer<VideoManagerEvents> {\n  constructor(options: BaseComponentOptions) {\n    super(options)\n\n    this.runWorker('videoManagerWorker', {\n      worker: videoManagerWorker,\n    })\n  }\n\n  /** @internal */\n  protected override getSubscriptions() {\n    const eventNamesWithPrefix = this.eventNames().map(\n      (event) => `video-manager.${event}`\n    ) as EventEmitter.EventNames<VideoManagerEvents>[]\n    return validateEventsToSubscribe(eventNamesWithPrefix)\n  }\n}\n\nexport const createVideoManagerObject = (params: BaseComponentOptions) => {\n  const manager = connect<VideoManagerEvents, VideoManagerAPI, VideoManager>({\n    store: params.store,\n    Component: VideoManagerAPI,\n  })(params)\n\n  const proxy = new Proxy<VideoManager>(manager, {\n    get(\n      target: VideoManager,\n      property: string | symbol,\n      receiver: ProxyHandler<VideoManager>\n    ) {\n      if (property === '_eventsNamespace') {\n        return ''\n      } else if (property === 'eventChannel') {\n        return 'video-manager.rooms'\n      }\n\n      return Reflect.get(target, property, receiver)\n    },\n  })\n  return proxy\n}\n", "import { getLogger, sagaEffects } from '@signalwire/core'\nimport type {\n  SagaIterator,\n  MapToPubSubShape,\n  VideoManagerEvent,\n  SDKWorker,\n  SDKActions,\n  SDKWorkerParams,\n} from '@signalwire/core'\nimport type { VideoManager } from '../VideoManager'\nimport { videoManagerRoomsWorker } from './videoManagerRoomsWorker'\nimport { videoManagerRoomWorker } from './videoManagerRoomWorker'\n\nexport type VideoManagerWorkerParams<T> = SDKWorkerParams<VideoManager> & {\n  action: T\n}\n\nexport const videoManagerWorker: SDKWorker<VideoManager> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('videoManagerWorker started')\n  const {\n    channels: { swEventChannel },\n  } = options\n\n  function* worker(action: MapToPubSubShape<VideoManagerEvent>) {\n    const { type } = action\n\n    switch (type) {\n      case 'video-manager.rooms.subscribed':\n        yield sagaEffects.fork(videoManagerRoomsWorker, {\n          action,\n          ...options,\n        })\n        break\n      case 'video-manager.room.added':\n      case 'video-manager.room.deleted':\n      case 'video-manager.room.ended':\n      case 'video-manager.room.started':\n      case 'video-manager.room.updated':\n        yield sagaEffects.fork(videoManagerRoomWorker, {\n          action,\n          ...options,\n        })\n        break\n      default:\n        getLogger().warn(`Unknown video-manager event: \"${type}\"`)\n        break\n    }\n  }\n\n  while (true) {\n    const action: MapToPubSubShape<VideoManagerEvent> = yield sagaEffects.take(\n      swEventChannel,\n      (action: SDKActions) => {\n        return action.type.startsWith('video-manager.')\n      }\n    )\n\n    yield sagaEffects.fork(worker, action)\n  }\n\n  getLogger().trace('videoManagerWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  MapToPubSubShape,\n  VideoManagerRoomsSubscribedEvent,\n  toExternalJSON,\n  VideoManagerRoomEventNames,\n  stripNamespacePrefix,\n} from '@signalwire/core'\nimport { VideoManagerWorkerParams } from './videoManagerWorker'\n\nexport const videoManagerRoomsWorker = function* (\n  options: VideoManagerWorkerParams<\n    MapToPubSubShape<VideoManagerRoomsSubscribedEvent>\n  >\n): SagaIterator {\n  getLogger().trace('videoManagerRoomsWorker started')\n  const {\n    instance: client,\n    action: { type, payload },\n  } = options\n\n  // For now we expose the transformed payload and not a RoomSession\n  const modPayload = {\n    rooms: payload.rooms.map((row) => toExternalJSON(row)),\n  }\n  client.emit(\n    stripNamespacePrefix(type) as VideoManagerRoomEventNames,\n    modPayload\n  )\n\n  getLogger().trace('videoManagerRoomsWorker ended')\n}\n", "import {\n  getLogger,\n  SagaIterator,\n  MapToPubSubShape,\n  VideoManagerRoomEvent,\n  toExternalJSON,\n  VideoManagerRoomEventNames,\n  stripNamespacePrefix,\n} from '@signalwire/core'\nimport { VideoManagerWorkerParams } from './videoManagerWorker'\n\nexport const videoManagerRoomWorker = function* (\n  options: VideoManagerWorkerParams<MapToPubSubShape<VideoManagerRoomEvent>>\n): SagaIterator {\n  getLogger().trace('videoManagerRoomWorker started')\n  const {\n    instance: client,\n    action: { type, payload },\n  } = options\n\n  // For now we expose the transformed payload and not a RoomSession\n  client.emit(\n    stripNamespacePrefix(type) as VideoManagerRoomEventNames,\n    toExternalJSON(payload)\n  )\n\n  getLogger().trace('videoManagerRoomWorker ended')\n}\n", "import jwtDecode from 'jwt-decode'\nimport {\n  BaseJWTSession,\n  getLogger,\n  SessionOptions,\n  SwAuthorizationState,\n  type SWCloseEvent,\n} from '@signalwire/core'\nimport { getStorage, sessionStorageManager } from './utils/storage'\nimport { SwCloseEvent } from './utils/CloseEvent'\n\ntype JWTHeader = { ch?: string; typ?: string }\n\nexport class JWTSession extends BaseJWTSession {\n  public WebSocketConstructor = WebSocket\n  public CloseEventConstructor = SwCloseEvent\n  public agent = process.env.SDK_PKG_AGENT!\n\n  private tokenTyp: string\n\n  constructor(public options: SessionOptions) {\n    let decodedJwt: JWTHeader = {}\n    try {\n      decodedJwt = jwtDecode<{ ch?: string; typ: string }>(options.token, {\n        header: true,\n      })\n    } catch (e) {\n      if (process.env.NODE_ENV !== 'production') {\n        getLogger().debug('[JWTSession] error decoding the JWT')\n      }\n    }\n\n    super({\n      ...options,\n      host: options.host || decodedJwt?.ch,\n    })\n    this.tokenTyp = decodedJwt.typ ?? 'VRT'\n  }\n\n  get allowReattach() {\n    // @ts-expect-error\n    return this.options?.reattach !== false && this.isVRT()\n  }\n\n  override async retrieveRelayProtocol() {\n    if (!this.allowReattach) {\n      return ''\n    }\n\n    const { protocolKey } = sessionStorageManager(this.options.token)\n    if (protocolKey) {\n      this.logger.trace('Search protocol for', protocolKey)\n      return getStorage()?.getItem(protocolKey) ?? ''\n    }\n    return ''\n  }\n\n  override async persistRelayProtocol() {\n    if (!this.allowReattach) {\n      return\n    }\n\n    const { protocolKey } = sessionStorageManager(this.options.token)\n    if (protocolKey) {\n      this.logger.trace('Persist protocol', protocolKey, this.relayProtocol)\n      getStorage()?.setItem(protocolKey, this.relayProtocol)\n    }\n  }\n\n  protected override async retrieveSwAuthorizationState() {\n    const { authStateKey } = sessionStorageManager(this.options.token)\n    if (authStateKey) {\n      return getStorage()?.getItem(authStateKey) ?? ''\n    }\n    return ''\n  }\n\n  protected override async persistSwAuthorizationState(\n    state: SwAuthorizationState\n  ) {\n    if (!this.allowReattach) {\n      return\n    }\n\n    const { authStateKey } = sessionStorageManager(this.options.token)\n    if (authStateKey) {\n      this.logger.trace('Persist auth state', authStateKey, state)\n      getStorage()?.setItem(authStateKey, state)\n    }\n  }\n\n  protected override _onSocketClose(event: SWCloseEvent) {\n    if (this.status === 'unknown') {\n      const { protocolKey, authStateKey, callIdKey } = sessionStorageManager(\n        this.options.token\n      )\n      this.logger.debug('Cleaning up storage')\n      if (protocolKey) {\n        this.logger.debug('Remove protocolKey', protocolKey)\n        getStorage()?.removeItem(protocolKey)\n      }\n      if (authStateKey) {\n        this.logger.debug('Remove authStateKey', authStateKey)\n        getStorage()?.removeItem(authStateKey)\n      }\n      if (callIdKey) {\n        this.logger.debug('Remove callIdKey', callIdKey)\n        getStorage()?.removeItem(callIdKey)\n      }\n    }\n\n    super._onSocketClose(event)\n  }\n\n  private isVRT() {\n    return this.tokenTyp === 'VRT'\n  }\n}\n", "import jwtDecode from 'jwt-decode'\nimport { getLogger } from '@signalwire/core'\n\n/**\n * Note: ready to support RN with a \"storage.native.ts\" file.\n */\nexport const getStorage = () => {\n  if (window && window.sessionStorage) {\n    return window.sessionStorage\n  }\n  return undefined\n}\n\nexport const sessionStorageManager = (token: string) => {\n  let roomName: string = ''\n  try {\n    const jwtPayload = jwtDecode<{ r: string; ja: string }>(token)\n    roomName = jwtPayload?.r ?? ''\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') {\n      getLogger().error('[sessionStorageManager] error decoding JWT', token)\n    }\n    roomName = ''\n  }\n\n  const valid = Boolean(roomName)\n  return {\n    authStateKey: valid && `as-${roomName}`,\n    protocolKey: valid && `pt-${roomName}`,\n    callIdKey: valid && `ci-${roomName}`,\n  }\n}\n", "import { SWCloseEvent as CoreCloseEvent } from '@signalwire/core'\n\nconst SwCloseEvent =\n  typeof CloseEvent === 'function' ? CloseEvent : CoreCloseEvent\n\nexport { SwCloseEvent }\n", "import { CreateRoomObjectOptions, createRoomObject } from './createRoomObject'\n\n/**\n * Using Video.joinRoom() you can automatically join a room.\n *\n * @example\n * With an HTMLDivElement with id=\"root\" in the DOM.\n * ```js\n * // <div id=\"root\"></div>\n *\n * try {\n *   const roomObj = await Video.joinRoom({\n *     token: '<YourJWT>',\n *     rootElementId: 'root',\n *   })\n *\n *   // You have joined the room..\n * } catch (error) {\n *   console.error('Error', error)\n * }\n * ```\n * @deprecated Use {@link RoomSession} instead.\n */\nexport const joinRoom = (roomOptions: CreateRoomObjectOptions) => {\n  return createRoomObject({\n    ...roomOptions,\n    autoJoin: true,\n  })\n}\n", "import {\n  UserOptions,\n  getLogger,\n  VideoAuthorization,\n  VideoRoomSubscribedEventParams,\n} from '@signalwire/core'\nimport { createClient } from './createClient'\nimport { BaseRoomSession } from './BaseRoomSession'\nimport { checkMediaParams, getJoinMediaParams } from './utils/roomSession'\nimport type { MakeRoomOptions } from './Client'\nimport type {\n  BaseRoomSessionJoinParams,\n  RoomSessionObjectEvents,\n} from './utils/interfaces'\nimport { getStorage, sessionStorageManager } from './utils/storage'\n\n/**\n * List of properties/methods the user shouldn't be able to\n * use until they sucessfully call `roomSession.join()`.\n */\nexport const UNSAFE_PROP_ACCESS = [\n  'audioMute',\n  'audioUnmute',\n  'deaf',\n  'getLayouts',\n  'getMembers',\n  'getRecordings',\n  'hideVideoMuted',\n  'leave',\n  'removerMember',\n  'restoreOutboundAudio',\n  'restoreOutboundVideo',\n  'setInputSensitivity',\n  'setInputVolume',\n  'setLayout',\n  'setPositions',\n  'setMemberPosition',\n  'setOutputVolume',\n  'showVideoMuted',\n  'startRecording',\n  'stopOutboundAudio',\n  'stopOutboundVideo',\n  'undeaf',\n  'videoMute',\n  'videoUnmute',\n  'setMicrophoneVolume',\n  'setSpeakerVolume',\n  'getMeta',\n  'setMeta',\n  'updateMeta',\n  'deleteMeta',\n  'getMemberMeta',\n  'setMemberMeta',\n  'updateMemberMeta',\n  'deleteMemberMeta',\n  'promote',\n  'demote',\n  'lock',\n  'unlock',\n]\n\n/**\n * List of events that the SDK must subscribe at the invite time.\n * ie. ScreenShare/AdditionaDevice are based on the member.joined logic.\n */\nconst REQUIRED_EVENTS: (keyof RoomSessionObjectEvents)[] = [\n  'member.joined',\n  'layout.changed',\n]\nconst noop = () => {}\n\nexport interface RoomSessionOptions extends UserOptions, MakeRoomOptions {}\n\nexport interface RoomSession extends BaseRoomSession<RoomSession> {\n  new (opts: RoomSessionOptions): this\n}\n\n/**\n * A RoomSession allows you to start and control video sessions.\n *\n * For example, the following code joins a video session and listens for new\n * members joining:\n *\n * ```typescript\n * const roomSession = new SignalWire.Video.RoomSession({\n *   token: '<YourRoomToken>',\n *   rootElement: document.getElementById('myVideoElement'),\n *   audio: true,\n *   video: true,\n * })\n *\n * roomSession.on('member.joined', (e) => {\n *   console.log(`${e.member.name} joined`)\n * })\n *\n * roomSession.join({ receiveAudio: true, sendVideo: false })\n * ```\n */\nexport const RoomSession = function (roomOptions: RoomSessionOptions) {\n  const {\n    audio: audioFromConstructor = true,\n    video: videoFromConstructor = true,\n    iceServers,\n    rootElement,\n    applyLocalVideoOverlay = true,\n    mirrorLocalVideoOverlay = false,\n    stopCameraWhileMuted = true,\n    stopMicrophoneWhileMuted = true,\n    speakerId,\n    destinationNumber,\n    localStream,\n    watchMediaPackets,\n    watchMediaPacketsTimeout,\n    ...userOptions\n  } = roomOptions\n\n  const deprecatedParams = ['audio', 'video']\n  deprecatedParams.forEach((param) => {\n    if (param in roomOptions) {\n      getLogger().warn(\n        `The '${param}' parameter on the RoomSession constructor is deprecated. Set it on the '.join()' function instead.`\n      )\n    }\n  })\n\n  // @ts-expect-error - true by default\n  const allowReattach = roomOptions?.reattach !== false\n\n  const { callIdKey } = sessionStorageManager(userOptions.token)\n  const reattachManager = {\n    joined: ({ call_id }: VideoRoomSubscribedEventParams) => {\n      if (allowReattach && callIdKey) {\n        getStorage()?.setItem(callIdKey, call_id)\n      }\n    },\n    init: () => {\n      if (allowReattach) {\n        room.on('room.subscribed', reattachManager.joined)\n      }\n      room.options.prevCallId = reattachManager.getPrevCallId()\n    },\n    destroy: () => {\n      if (!allowReattach) {\n        return\n      }\n\n      room.off('room.subscribed', reattachManager.joined)\n      if (callIdKey) {\n        getStorage()?.removeItem(callIdKey)\n      }\n    },\n    getPrevCallId: () => {\n      if (!allowReattach || !callIdKey) {\n        return\n      }\n\n      return getStorage()?.getItem(callIdKey) ?? undefined\n    },\n  }\n\n  const client = createClient<RoomSession>(userOptions)\n  const room = client.rooms.makeRoomObject({\n    // audio,\n    // video: video === true ? VIDEO_CONSTRAINTS : video,\n    negotiateAudio: true,\n    negotiateVideo: true,\n    iceServers,\n    rootElement,\n    applyLocalVideoOverlay,\n    mirrorLocalVideoOverlay,\n    stopCameraWhileMuted,\n    stopMicrophoneWhileMuted,\n    speakerId,\n    destinationNumber,\n    localStream,\n    watchMediaPackets,\n    watchMediaPacketsTimeout,\n    prevCallId: reattachManager.getPrevCallId(),\n  })\n\n  // WebRTC connection left the room.\n  room.once('destroy', () => {\n    room.emit('room.left', { reason: room.leaveReason })\n\n    // Remove callId to reattach\n    reattachManager.destroy()\n    client.disconnect()\n  })\n\n  // @ts-expect-error\n  client.session.once('session.disconnected', () => {\n    room.destroy()\n  })\n\n  const join = (params?: BaseRoomSessionJoinParams) => {\n    return new Promise(async (resolve, reject) => {\n      try {\n        // @ts-expect-error\n        room.attachPreConnectWorkers()\n\n        await client.connect()\n\n        // Fallback to the constructor values for backwards compat.\n        const audio = params?.audio ?? audioFromConstructor\n        const video = params?.video ?? videoFromConstructor\n\n        // @ts-expect-error\n        const authState: VideoAuthorization = client._sessionAuthState\n        getLogger().debug('getJoinMediaParams authState?', authState)\n        if (authState && authState.type === 'video') {\n          const mediaOptions = getJoinMediaParams({\n            authState,\n            // constructor values override the send\n            sendAudio: Boolean(audio),\n            sendVideo: Boolean(video),\n            ...params,\n          })\n\n          if (!checkMediaParams(mediaOptions)) {\n            client.disconnect()\n            return reject(\n              new Error(\n                `Invalid arguments to join the room. The token used has join_as: '${\n                  authState.join_as\n                }'. \\n${JSON.stringify(params, null, 2)}\\n`\n              )\n            )\n          }\n          getLogger().debug('Set mediaOptions', mediaOptions)\n\n          /**\n           * audio and video might be objects with MediaStreamConstraints\n           * so if we must send media, we make sure to use the user's\n           * preferences.\n           * Note: params.sendAudio: `true` will override audio: `false` so\n           * we're using `||` instead of `??` for that reason.\n           */\n          // @ts-expect-error\n          room.updateMediaOptions({\n            audio: mediaOptions.mustSendAudio ? audio || true : false,\n            video: mediaOptions.mustSendVideo ? video || true : false,\n            negotiateAudio: mediaOptions.mustRecvAudio,\n            negotiateVideo: mediaOptions.mustRecvVideo,\n          })\n        }\n\n        room.once('room.subscribed', () => {\n          resolve(room)\n        })\n\n        // Hijack previous callId if present\n        reattachManager.init()\n\n        REQUIRED_EVENTS.forEach((event) => room.once(event, noop))\n\n        await room.join()\n      } catch (error) {\n        getLogger().error('RoomSession Join', error)\n        // Disconnect the underlay client in case of media/signaling errors\n        client.disconnect()\n\n        reject(error)\n      }\n    })\n  }\n\n  const interceptors = {\n    join,\n  } as const\n\n  return new Proxy<Omit<RoomSession, 'new'>>(room, {\n    get(target: RoomSession, prop: keyof RoomSession, receiver: any) {\n      if (prop in interceptors) {\n        // @ts-expect-error\n        return interceptors[prop]\n      }\n\n      if (!target.active && UNSAFE_PROP_ACCESS.includes(prop)) {\n        throw new Error(\n          `Tried to access the property/method \"${prop}\" before the room was connected. Please call roomSession.join() first.`\n        )\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n  })\n  // For consistency with other constructors we'll make TS force the use of `new`\n} as unknown as { new (roomOptions: RoomSessionOptions): RoomSession }\n", "import { getLogger } from '@signalwire/core'\nimport type { VideoAuthorization } from '@signalwire/core'\nimport type { BaseRoomSessionJoinParams } from './interfaces'\n\ntype GetJoinMediaParamsOptions = BaseRoomSessionJoinParams & {\n  authState: VideoAuthorization\n}\n/**\n * getJoinMediaParams returns whether the Join method must send/recv\n * audio and video.\n * Based on values on the Auth block (media allowed and join_as type)\n * it matches the user's preferences and return an object that tells\n * if the negotiation has to include sendrecv/sendonly or recvonly\n * for audio and video.\n */\nexport const getJoinMediaParams = (options: GetJoinMediaParamsOptions) => {\n  const {\n    authState,\n    audio = true,\n    video = true,\n    sendAudio,\n    sendVideo,\n    receiveAudio,\n    receiveVideo,\n  } = options\n  getLogger().debug('getJoinMediaParams options', { ...options })\n  const { audio_allowed, video_allowed, join_as } = authState\n  // Fallback to 'member' in case of null/undefined\n  const joinAs = join_as ?? 'member'\n  const canSend = joinAs === 'member'\n\n  const canSendAudio = canSend && audio_allowed === 'both'\n  const canSendVideo = canSend && video_allowed === 'both'\n  const canReceiveAudio = audio_allowed !== 'none'\n  const canReceiveVideo = video_allowed !== 'none'\n\n  const reqToSendAudio = Boolean(sendAudio ?? audio)\n  const reqToSendVideo = Boolean(sendVideo ?? video)\n  const reqToReceiveAudio = Boolean(receiveAudio ?? audio)\n  const reqToReceiveVideo = Boolean(receiveVideo ?? video)\n\n  if (!canSendAudio && reqToSendAudio) {\n    getLogger().info(\n      'Not allowed to send audio on this room. Default values will be used.'\n    )\n  }\n  if (!canSendVideo && reqToSendVideo) {\n    getLogger().info(\n      'Not allowed to send video on this room. Default values will be used.'\n    )\n  }\n  if (!canReceiveAudio && reqToReceiveAudio) {\n    getLogger().info(\n      'Not allowed to receive video from the room. Default values will be used.'\n    )\n  }\n  if (!canReceiveVideo && reqToReceiveVideo) {\n    getLogger().info(\n      'Not allowed to receive video from the room. Default values will be used.'\n    )\n  }\n  return {\n    mustSendAudio: canSendAudio && reqToSendAudio,\n    mustSendVideo: canSendVideo && reqToSendVideo,\n    mustRecvAudio: canReceiveAudio && reqToReceiveAudio,\n    mustRecvVideo: canReceiveVideo && reqToReceiveVideo,\n  }\n}\n\nexport const checkMediaParams = (\n  options: Record<string, boolean | undefined>\n) => {\n  // At least one value must be true\n  return Object.values(options).some(Boolean)\n}\n", "import { MakeRoomOptions } from '../Client'\nimport { RoomSession } from '../video'\n\ntype Strategy = 'room'\ntype StrategyParams = RoomStrategyParams\ntype RoomStrategyParams = {\n  token: string\n}\ninterface FabricCallResponse {\n  strategy: Strategy\n  params: StrategyParams\n  userParams: MakeRoomOptions\n}\n\nexport const buildCall = ({\n  strategy,\n  params,\n  userParams,\n}: FabricCallResponse) => {\n  let obj: RoomSession\n  let start: (...args: any[]) => void\n  switch (strategy) {\n    case 'room':\n      obj = new RoomSession({\n        token: params.token,\n        debug: {\n          logWsTraffic: true,\n        },\n        logLevel: 'debug',\n        watchMediaPackets: false,\n        ...userParams,\n      })\n      start = (joinParams: any) => {\n        return new Promise((resolve, reject) => {\n          obj.once('room.joined', (params) => resolve(params))\n          // @ts-ignore\n          obj.emitter.once('verto.display', (params) => resolve(params))\n          return obj.join(joinParams).catch((error) => reject(error))\n        })\n      }\n      break\n    // case 'voice':\n    // case 'script':\n    // case 'whatever':\n    default:\n      throw new Error(`Unknown strategy: '${strategy}'`)\n  }\n\n  const interceptors = {\n    start,\n  }\n\n  return new Proxy(obj, {\n    get(target: typeof obj, prop: keyof typeof obj, receiver: any) {\n      if (prop in interceptors) {\n        // @ts-expect-error\n        return interceptors[prop]\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n  })\n}\n", "import { createHttpClient } from './createHttpClient'\nimport { buildCall } from './buildCall'\n\ninterface ClientOptions {\n  host?: string\n  accessToken: string\n}\n\n/**\n *\n *\n * // TODO: Remove this file\n * Replaced by SWClient.ts\n *\n */\nexport class Client {\n  private httpClient: ReturnType<typeof createHttpClient>\n\n  constructor(public options: ClientOptions) {\n    this.httpClient = createHttpClient({\n      baseUrl: `https://${this.host}`,\n      headers: {\n        Authorization: `Bearer ${this.options.accessToken}`,\n      },\n    })\n  }\n\n  get host() {\n    return this.options.host ?? 'fabric.signalwire.com'\n  }\n\n  async getAddresses() {\n    const path = '/addresses' as const\n    const { body } = await this.httpClient<any>(path)\n    const anotherPage = async (url: string) => {\n      const { search } = new URL(url)\n      const { body } = await this.httpClient<any>(`${path}${search}`)\n      return buildResult(body)\n    }\n\n    const buildResult = (body: any) => {\n      return {\n        addresses: body.data,\n        nextPage: async () => {\n          const { next } = body.links\n          return next ? anotherPage(next) : undefined\n        },\n        prevPage: async () => {\n          const { prev } = body.links\n          return prev ? anotherPage(prev) : undefined\n        },\n      }\n    }\n\n    return buildResult(body)\n  }\n\n  async createCall({\n    uri,\n    ...userParams\n  }: {\n    uri: string\n    rootElement: HTMLElement\n  }) {\n    const path = '/call' as const\n    const { body } = await this.httpClient<any>(path, {\n      method: 'POST',\n      body: { uri },\n    })\n\n    console.log('Dial Response', body)\n    return buildCall({\n      ...body,\n      userParams: {\n        host: this.host.includes('swire') ? 'relay.swire.io' : undefined,\n        ...userParams,\n      },\n    })\n  }\n}\n", "import { createHttpClient } from './createHttpClient'\n\ninterface SWClientOptions {\n  httpHost?: string\n  accessToken: string\n  rootElement?: HTMLElement\n}\n\ninterface RegisterDeviceParams {\n  deviceType: 'iOS' | 'Android' | 'Desktop'\n  deviceToken: string\n}\n\n// TODO: extends from a Base class to share from core\nexport class SWClient {\n  private httpClient: ReturnType<typeof createHttpClient>\n\n  constructor(public options: SWClientOptions) {\n    this.httpClient = createHttpClient({\n      baseUrl: `https://${this.httpHost}`,\n      headers: {\n        Authorization: `Bearer ${this.options.accessToken}`,\n      },\n    })\n  }\n\n  get httpHost() {\n    return this.options.httpHost ?? 'fabric.signalwire.com'\n  }\n\n  async getAddresses() {\n    const path = '/addresses' as const\n    const { body } = await this.httpClient<any>(path)\n    const anotherPage = async (url: string) => {\n      const { search } = new URL(url)\n      const { body } = await this.httpClient<any>(`${path}${search}`)\n      return buildResult(body)\n    }\n\n    const buildResult = (body: any) => {\n      return {\n        addresses: body.data,\n        nextPage: async () => {\n          const { next } = body.links\n          return next ? anotherPage(next) : undefined\n        },\n        prevPage: async () => {\n          const { prev } = body.links\n          return prev ? anotherPage(prev) : undefined\n        },\n      }\n    }\n\n    return buildResult(body)\n  }\n\n  async registerDevice({ deviceType, deviceToken }: RegisterDeviceParams) {\n    const path = '/subscriber/devices' as const\n    const { body } = await this.httpClient<any>(path, {\n      method: 'POST',\n      body: {\n        device_type: deviceType,\n        device_token: deviceToken,\n      },\n    })\n\n    return body\n  }\n\n  async unregisterDevice({ id }: { id: string }) {\n    const path = `/subscriber/devices/${id}` as const\n    return await this.httpClient<any>(path, {\n      method: 'DELETE',\n    })\n  }\n}\n", "import { type UserOptions, getLogger, VertoSubscribe } from '@signalwire/core'\nimport { createClient } from '../createClient'\nimport { WSClientWorker } from './WSClientWorker'\n\ninterface PushNotification {\n  encryption_type: 'aes_256_gcm'\n  notification_uuid: string\n  with_video: 'true' | 'false'\n  incoming_caller_name: string\n  incoming_caller_id: string\n  tag: string\n  invite: string\n  title: string\n  type: 'call_invite'\n  iv: string\n  version: string\n  decrypted: Record<string, any>\n}\n\ninterface WSClientOptions extends UserOptions {\n  rootElement?: HTMLElement\n}\n\nexport class WSClient {\n  private wsClient: ReturnType<typeof createClient>\n  private logger = getLogger()\n\n  constructor(public options: WSClientOptions) {\n    this.wsClient = createClient({\n      host: this.options.host,\n      token: this.options.token,\n      debug: {\n        logWsTraffic: true,\n      },\n      logLevel: 'debug',\n    })\n  }\n\n  connect() {\n    // @ts-ignore\n    this.wsClient.runWorker('WSClientWorker', {\n      worker: WSClientWorker,\n    })\n    return this.wsClient.connect()\n  }\n\n  disconnect() {\n    return this.wsClient.disconnect()\n  }\n\n  async dial(params: { to: string; nodeId?: string }) {\n    return new Promise(async (resolve, reject) => {\n      try {\n        console.log('WSClient dial with:', params)\n\n        await this.connect()\n\n        // const {\n        //   audio: audioFromConstructor = true,\n        //   video: videoFromConstructor = true,\n        //   iceServers,\n        //   rootElement,\n        //   applyLocalVideoOverlay = true,\n        //   stopCameraWhileMuted = true,\n        //   stopMicrophoneWhileMuted = true,\n        //   speakerId,\n        //   destinationNumber,\n        //   watchMediaPackets,\n        //   watchMediaPacketsTimeout,\n        //   ...userOptions\n        // } = params\n\n        const call = this.wsClient.rooms.makeRoomObject({\n          // audio,\n          // video: video === true ? VIDEO_CONSTRAINTS : video,\n          negotiateAudio: true,\n          negotiateVideo: true,\n          // iceServers,\n          rootElement: this.options.rootElement,\n          applyLocalVideoOverlay: true,\n          stopCameraWhileMuted: true,\n          stopMicrophoneWhileMuted: true,\n          // speakerId,\n          destinationNumber: params.to,\n          watchMediaPackets: false,\n          // watchMediaPacketsTimeout:,\n          nodeId: params.nodeId,\n        })\n\n        // WebRTC connection left the room.\n        call.once('destroy', () => {\n          this.logger.debug('RTC Connection Destroyed')\n        })\n\n        this.wsClient.once('session.disconnected', () => {\n          this.logger.debug('Session Disconnected')\n        })\n\n        // @ts-expect-error\n        call.attachPreConnectWorkers()\n\n        // @ts-expect-error\n        call.start = () => {\n          return new Promise(async (resolve, reject) => {\n            try {\n              // @ts-expect-error\n              call.once('verto.display', () => resolve(call))\n              call.once('room.subscribed', () => resolve(call))\n\n              await call.join()\n            } catch (error) {\n              getLogger().error('WSClient call start', error)\n\n              reject(error)\n            }\n          })\n        }\n\n        resolve(call)\n      } catch (error) {\n        getLogger().error('WSClient dial', error)\n\n        reject(error)\n      }\n    })\n  }\n\n  handlePushNotification(payload: PushNotification) {\n    return new Promise(async (resolve, reject) => {\n      const { decrypted, type } = payload\n      if (type !== 'call_invite') {\n        this.logger.warn('Unknown notification type', payload)\n        return\n      }\n      this.logger.debug('handlePushNotification', payload)\n      const { params: jsonrpc, node_id: nodeId } = decrypted\n      const {\n        params: {\n          callID,\n          sdp,\n          caller_id_name,\n          caller_id_number,\n          callee_id_name,\n          callee_id_number,\n          display_direction,\n        },\n      } = jsonrpc\n      this.logger.debug('handlePushNotification data', {\n        callID,\n        sdp,\n        caller_id_name,\n        caller_id_number,\n        callee_id_name,\n        callee_id_number,\n        display_direction,\n      })\n      try {\n        // Connect the client first\n        await this.connect()\n\n        // Catch the error temporarly\n        try {\n          // Send verto.subscribe\n          await this.executeVertoSubscribe(callID, nodeId)\n        } catch (error) {\n          this.logger.warn('Verto Subscribe', error)\n        }\n\n        // Build the Call object and return to the user\n\n        // const {\n        //   audio: audioFromConstructor = true,\n        //   video: videoFromConstructor = true,\n        //   iceServers,\n        //   rootElement,\n        //   applyLocalVideoOverlay = true,\n        //   stopCameraWhileMuted = true,\n        //   stopMicrophoneWhileMuted = true,\n        //   speakerId,\n        //   destinationNumber,\n        //   watchMediaPackets,\n        //   watchMediaPacketsTimeout,\n        //   ...userOptions\n        // } = params\n\n        const call = this.wsClient.rooms.makeRoomObject({\n          negotiateAudio: true,\n          negotiateVideo: true,\n          rootElement: this.options.rootElement,\n          applyLocalVideoOverlay: true,\n          stopCameraWhileMuted: true,\n          stopMicrophoneWhileMuted: true,\n          // speakerId,\n          watchMediaPackets: false,\n          // watchMediaPacketsTimeout:,\n\n          remoteSdp: sdp,\n          prevCallId: callID,\n          nodeId,\n        })\n\n        // WebRTC connection left the room.\n        call.once('destroy', () => {\n          getLogger().debug('RTC Connection Destroyed')\n        })\n\n        // @ts-expect-error\n        call.attachPreConnectWorkers()\n\n        // // @ts-expect-error\n        // call.attachOnSubscribedWorkers(payload)\n\n        getLogger().debug('Resolving Call', call)\n        resolve({ resultType: 'inboundCall', resultObject: call })\n      } catch (error) {\n        reject(error)\n      }\n    })\n  }\n\n  private async executeVertoSubscribe(callId: string, nodeId: string) {\n    try {\n      // @ts-expect-error\n      return await this.wsClient.execute({\n        method: 'webrtc.verto',\n        params: {\n          callID: callId,\n          node_id: nodeId,\n          subscribe: [],\n          message: VertoSubscribe({\n            sessid: callId,\n            eventChannel: [],\n          }),\n        },\n      })\n    } catch (error) {\n      this.logger.warn('The call is not available anymore', callId)\n      throw error\n    }\n  }\n\n  updateToken(token: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.wsClient.once('session.auth_error', (error) => {\n        reject(error)\n      })\n      this.wsClient.once('session.connected', () => {\n        resolve()\n      })\n\n      // @ts-expect-error\n      this.wsClient.reauthenticate(token)\n    })\n  }\n}\n", "import {\n  getLogger,\n  sagaEffects,\n  SagaIterator,\n  SDKWorker,\n  SDKActions,\n  MapToPubSubShape,\n  SDKWorkerHooks,\n  // VideoMemberJoinedEvent,\n  // componentSelectors,\n  // componentActions,\n} from '@signalwire/core'\nimport { createClient } from '../createClient'\nimport type { BaseConnection } from '@signalwire/webrtc'\n\ntype WSClientWorkerOnDone = () => void\ntype WSClientWorkerOnFail = (args: { error: Error }) => void\n\nexport type WSClientWorkerHooks = SDKWorkerHooks<\n  WSClientWorkerOnDone,\n  WSClientWorkerOnFail\n>\n\nexport const WSClientWorker: SDKWorker<\n  ReturnType<typeof createClient<BaseConnection<any>>>,\n  WSClientWorkerHooks\n> = function* (options): SagaIterator {\n  getLogger().debug('WSClientWorker started')\n  const { channels, instance } = options\n  const { swEventChannel } = channels\n  getLogger().debug('WSClientWorker instance', instance)\n  while (true) {\n    const action: MapToPubSubShape<any> = yield sagaEffects.take(\n      swEventChannel,\n      (action: SDKActions) => {\n        getLogger().debug('WSClientWorker action', action)\n        if (action.type === 'webrtc.message') {\n          return action.payload.method === 'verto.invite'\n        }\n        return false\n      }\n    )\n    getLogger().debug('Build new call to answer', action)\n\n    // TODO: invoke WSClient function to build and answer the invite\n    // instance.buildInboundCall(action)\n  }\n\n  getLogger().trace('WSClientWorker ended')\n}\n", "import { type UserOptions } from '@signalwire/core'\nimport { createHttpClient } from './createHttpClient'\n\ninterface RegisterDeviceParams {\n  deviceType: 'iOS' | 'Android' | 'Desktop'\n  deviceToken: string\n}\n\n// TODO: extends from a Base class to share from core\nexport class HTTPClient {\n  private httpClient: ReturnType<typeof createHttpClient>\n\n  constructor(public options: UserOptions) {\n    this.httpClient = createHttpClient({\n      baseUrl: `https://${this.httpHost}`,\n      headers: {\n        Authorization: `Bearer ${this.options.token}`,\n      },\n    })\n  }\n\n  get httpHost() {\n    const { host } = this.options\n    if (!host) {\n      return 'fabric.signalwire.com'\n    }\n    return `fabric.${host.split('.').splice(1).join('.')}`\n  }\n\n  public async getAddresses() {\n    const path = '/addresses' as const\n    const { body } = await this.httpClient<any>(path)\n    const anotherPage = async (url: string) => {\n      const { search } = new URL(url)\n      const { body } = await this.httpClient<any>(`${path}${search}`)\n      return buildResult(body)\n    }\n\n    const buildResult = (body: any) => {\n      return {\n        addresses: body.data,\n        nextPage: async () => {\n          const { next } = body.links\n          return next ? anotherPage(next) : undefined\n        },\n        prevPage: async () => {\n          const { prev } = body.links\n          return prev ? anotherPage(prev) : undefined\n        },\n      }\n    }\n\n    return buildResult(body)\n  }\n\n  public async registerDevice({\n    deviceType,\n    deviceToken,\n  }: RegisterDeviceParams) {\n    const path = '/subscriber/devices' as const\n    const { body } = await this.httpClient<any>(path, {\n      method: 'POST',\n      body: {\n        device_type: deviceType,\n        device_token: deviceToken,\n      },\n    })\n\n    return body\n  }\n\n  public async unregisterDevice({ id }: { id: string }) {\n    const path = `/subscriber/devices/${id}` as const\n    return await this.httpClient<any>(path, {\n      method: 'DELETE',\n    })\n  }\n}\n", "import { type UserOptions } from '@signalwire/core'\nimport { HTTPClient } from './HTTPClient'\nimport { WSClient } from './WSClient'\n\ninterface SignalWireOptions extends UserOptions {\n  rootElement?: HTMLElement\n}\n\ninterface SignalWireContract {\n  httpHost: HTTPClient['httpHost']\n  getAddresses: HTTPClient['getAddresses']\n  registerDevice: HTTPClient['registerDevice']\n  unregisterDevice: HTTPClient['unregisterDevice']\n  connect: WSClient['connect']\n  disconnect: WSClient['disconnect']\n  dial: WSClient['dial']\n  handlePushNotification: WSClient['handlePushNotification']\n  updateToken: WSClient['updateToken']\n}\n\nexport const SignalWire = (\n  options: SignalWireOptions\n): Promise<SignalWireContract> => {\n  return new Promise(async (resolve, reject) => {\n    try {\n      const httpClient = new HTTPClient(options)\n      const wsClient = new WSClient(options)\n\n      resolve({\n        httpHost: httpClient.httpHost,\n        getAddresses: httpClient.getAddresses.bind(httpClient),\n        registerDevice: httpClient.registerDevice.bind(httpClient),\n        unregisterDevice: httpClient.unregisterDevice.bind(httpClient),\n        connect: wsClient.connect.bind(wsClient),\n        disconnect: wsClient.disconnect.bind(wsClient),\n        dial: wsClient.dial.bind(wsClient),\n        handlePushNotification: wsClient.handlePushNotification.bind(wsClient),\n        updateToken: wsClient.updateToken.bind(wsClient),\n        // @ts-expect-error\n        __httpClient: httpClient,\n        __wsClient: wsClient,\n      })\n    } catch (error) {\n      reject(error)\n    }\n  })\n}\n", "export { Client, ClientOptions, ClientApiEvents } from './Client'\n\nexport { ChatMember, ChatMessage } from '@signalwire/core'\n\nexport type { PagingCursor } from '../utils/interfaces'\n\nexport type {\n  ChatAction,\n  ChatChannel,\n  ChatChannelMessageEvent,\n  ChatChannelMessageEventParams,\n  ChatChannelState,\n  ChatEvent,\n  ChatGetMembersParams,\n  ChatGetMemberStateParams,\n  ChatGetMessagesParams,\n  ChatMemberContract,\n  ChatMemberEntity,\n  ChatMemberJoinedEvent,\n  ChatMemberJoinedEventParams,\n  ChatMemberLeftEvent,\n  ChatMemberLeftEventParams,\n  ChatMemberUpdatedEvent,\n  ChatMemberUpdatedEventParams,\n  ChatMessageContract,\n  ChatMessageEntity,\n  ChatSetMemberStateParams,\n  InternalChatMemberEntity,\n  InternalChatMessageEntity,\n  PaginationCursor,\n} from '@signalwire/core'\n", "import type {\n  ChatContract,\n  ConsumerContract,\n  UserOptions,\n  Chat as ChatNamespace,\n} from '@signalwire/core'\nimport { createClient } from '../createClient'\n\nexport interface ClientApiEvents extends ChatNamespace.BaseChatApiEvents {}\n\n/** @ignore */\nexport interface ClientFullState extends Client {}\nexport interface Client\n  extends ChatContract,\n    Omit<ConsumerContract<ClientApiEvents, ClientFullState>, 'subscribe'> {}\n\n/** @ignore */\nexport interface ClientOptions extends UserOptions {}\n\ntype ClientMethods = keyof Client\nconst INTERCEPTED_METHODS: ClientMethods[] = [\n  'subscribe',\n  'publish',\n  'getMessages',\n  'getMembers',\n  'getMemberState',\n  'getAllowedChannels',\n  'setMemberState',\n]\n\n/**\n * You can use the Client object to build a messaging system into the browser.\n *\n * Example usage:\n *\n * ```js\n * import { Chat } from '@signalwire/js'\n *\n * const chatClient = new Chat.Client({\n *   token: '<your_chat_token>',  // get this from the REST APIs\n * })\n *\n * await chatClient.subscribe([ 'mychannel1', 'mychannel2' ])\n *\n * chatClient.on('message', (message) => {\n *   console.log(\"Received\", message.content,\n *               \"on\", message.channel,\n *               \"at\", message.publishedAt)\n * })\n *\n * await chatClient.publish({\n *   channel: 'mychannel1',\n *   content: 'hello world'\n * })\n * ```\n *\n * ## Events\n *\n * Please see {@link ClientApiEvents} for the list of events emitted by a chat\n * Client object.\n */\nexport const Client = function (chatOptions: ClientOptions) {\n  const client = createClient<Client>(chatOptions)\n\n  const createInterceptor = <K extends keyof Client>(prop: K) => {\n    return async (...params: Parameters<Client[K]>) => {\n      await client.connect()\n\n      // @ts-expect-error\n      return client.chat[prop](...params)\n    }\n  }\n\n  const interceptors = {\n    _session: client,\n    disconnect: () => client.disconnect(),\n  } as const\n\n  return new Proxy<Client>(client.chat, {\n    get(target: Client, prop: keyof Client, receiver: any) {\n      if (prop in interceptors) {\n        // @ts-expect-error\n        return interceptors[prop]\n      }\n\n      if (INTERCEPTED_METHODS.includes(prop)) {\n        return createInterceptor(prop)\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n  })\n  // For consistency with other constructors we'll make TS force the use of `new`\n} as unknown as { new (chatOptions: ClientOptions): Client }\n", "import { PubSub } from '@signalwire/core'\nimport { PagingCursor } from '../utils/interfaces'\nimport PubSubMessage = PubSub.PubSubMessage\n\nexport * from './Client'\n\nexport {\n  PubSubMessage,\n  PagingCursor\n}\n", "import type {\n  Rooms,\n  BaseConnectionState,\n  InternalVideoLayout,\n  VideoLayoutEventNames,\n  VideoRoomSessionEventNames,\n  VideoRoomEventParams,\n  InternalVideoMemberEntity,\n  InternalVideoMemberEntityUpdated,\n  VideoMemberEventNames,\n  MemberUpdated,\n  MemberUpdatedEventNames,\n  MemberTalkingEventNames,\n  VideoMemberTalkingEventParams,\n  RTCTrackEventName,\n  InternalVideoMemberUpdatableProps,\n  VideoRecordingEventNames,\n  VideoPlaybackEventNames,\n  RoomSessionRecording,\n  RoomSessionPlayback,\n  VideoRoomSessionContract,\n  OnlyFunctionProperties,\n  MemberListUpdated,\n  VideoPositions,\n  RoomAudienceCount,\n  VideoRoomAudienceCountEventParams,\n  RoomLeft,\n  RoomLeftEventParams,\n  VideoStreamEventNames,\n  RoomSessionStream,\n  RoomJoined,\n  RoomSubscribed,\n  VideoRoomSubscribedEventParams,\n  VideoAuthorization,\n  VideoRoomDeviceUpdatedEventNames,\n  DeviceUpdatedEventParams,\n  VideoRoomDeviceDisconnectedEventNames,\n  DeviceDisconnectedEventParams,\n  VideoRoomDeviceEventNames,\n} from '@signalwire/core'\nimport { INTERNAL_MEMBER_UPDATABLE_PROPS } from '@signalwire/core'\nimport type { MediaEvent } from '@signalwire/webrtc'\nimport type { RoomSession } from '../RoomSession'\nimport type { RoomSessionDevice } from '../RoomSessionDevice'\nimport type { RoomSessionScreenShare } from '../RoomSessionScreenShare'\n\n/**\n * @privateRemarks\n * Every other package exposing a `VideoMemberEntity` is\n * transforming the server payload into something else, with\n * the most significant change being converting properties\n * from snake to camel case. The `js` package, on the other\n * hand, exposes the server payload pretty much as is (as of\n * v3) so what we consider internal (sdk and server) in\n * other packages is external (user facing) for `js`. Same\n * applies to `VideoMemberEntityUpdated` since it's just a\n * derived type.\n */\ntype VideoMemberEntity = InternalVideoMemberEntity\ntype VideoMemberEntityUpdated = InternalVideoMemberEntityUpdated\ntype VideoLayout = InternalVideoLayout\n\nconst INTERNAL_MEMBER_UPDATED_EVENTS = Object.keys(\n  INTERNAL_MEMBER_UPDATABLE_PROPS\n).map((key) => {\n  return `member.updated.${\n    key as keyof InternalVideoMemberUpdatableProps\n  }` as const\n})\n/** @deprecated */\nexport type DeprecatedMemberUpdatableProps =\n  (typeof INTERNAL_MEMBER_UPDATED_EVENTS)[number]\n/** @deprecated */\nexport type DeprecatedVideoMemberHandlerParams = {\n  member: InternalVideoMemberEntity\n}\nexport type VideoMemberHandlerParams = { member: VideoMemberEntity }\nexport type VideoMemberUpdatedHandlerParams = {\n  member: VideoMemberEntityUpdated\n  room_id?: string\n  room_session_id?: string\n}\nexport type VideoMemberListUpdatedParams = { members: VideoMemberEntity[] }\n\n/**\n * List of all the events a RoomObject can listen to\n */\nexport type RoomEventNames =\n  | VideoRoomSessionEventNames\n  | VideoMemberEventNames\n  | VideoLayoutEventNames\n  | VideoRecordingEventNames\n  | VideoPlaybackEventNames\n  | VideoStreamEventNames\n  | RTCTrackEventName\n\nexport type RoomSessionObjectEventsHandlerMap = Record<\n  VideoRoomDeviceEventNames,\n  (params: DeviceUpdatedEventParams) => void\n> &\n  Record<VideoLayoutEventNames, (params: { layout: VideoLayout }) => void> &\n  Record<\n    Exclude<\n      VideoMemberEventNames,\n      MemberUpdated | MemberUpdatedEventNames | MemberListUpdated\n    >,\n    (params: VideoMemberHandlerParams) => void\n  > &\n  Record<\n    Extract<VideoMemberEventNames, MemberUpdated | MemberUpdatedEventNames>,\n    (params: VideoMemberUpdatedHandlerParams) => void\n  > &\n  Record<\n    Extract<VideoMemberEventNames, MemberListUpdated>,\n    (params: VideoMemberListUpdatedParams) => void\n  > &\n  Record<\n    DeprecatedMemberUpdatableProps,\n    (params: DeprecatedVideoMemberHandlerParams) => void\n  > &\n  Record<\n    MemberTalkingEventNames,\n    (params: VideoMemberTalkingEventParams) => void\n  > &\n  Record<\n    Exclude<VideoRoomSessionEventNames, RoomLeft | RoomJoined | RoomSubscribed>,\n    (params: VideoRoomEventParams) => void\n  > &\n  Record<\n    RoomJoined | RoomSubscribed,\n    (params: VideoRoomSubscribedEventParams) => void\n  > &\n  Record<RoomLeft, (params?: RoomLeftEventParams) => void> &\n  Record<MediaEvent, () => void> &\n  Record<\n    VideoRoomDeviceUpdatedEventNames,\n    (params: DeviceUpdatedEventParams) => void\n  > &\n  Record<\n    VideoRoomDeviceDisconnectedEventNames,\n    (params: DeviceDisconnectedEventParams) => void\n  > &\n  Record<\n    RoomAudienceCount,\n    (params: VideoRoomAudienceCountEventParams) => void\n  > &\n  Record<RTCTrackEventName, (event: RTCTrackEvent) => void> &\n  Record<VideoRecordingEventNames, (recording: RoomSessionRecording) => void> &\n  Record<VideoPlaybackEventNames, (recording: RoomSessionPlayback) => void> &\n  Record<BaseConnectionState, (params: RoomSession) => void> &\n  Record<VideoStreamEventNames, (stream: RoomSessionStream) => void>\n\nexport type RoomSessionObjectEvents = {\n  [k in keyof RoomSessionObjectEventsHandlerMap]: RoomSessionObjectEventsHandlerMap[k]\n}\n\nexport type StartScreenShareOptions = {\n  /** Whether the screen share object should automatically join the room */\n  autoJoin?: boolean\n  /** Audio constraints to use when joining the room. Default: `true`. */\n  audio?: MediaStreamConstraints['audio']\n  /** Video constraints to use when joining the room. Default: `true`. */\n  video?: MediaStreamConstraints['video']\n  layout?: string\n  positions?: VideoPositions\n}\n\n/**\n * @deprecated Use {@link StartScreenShareOptions} instead.\n */\nexport interface CreateScreenShareObjectOptions\n  extends StartScreenShareOptions {}\n\nexport type AddDeviceOptions = {\n  autoJoin?: boolean\n  audio?: MediaStreamConstraints['audio']\n  video?: MediaStreamConstraints['video']\n}\n\nexport type AddCameraOptions = MediaTrackConstraints & {\n  autoJoin?: boolean\n}\nexport type AddMicrophoneOptions = MediaTrackConstraints & {\n  autoJoin?: boolean\n}\n\nexport interface MemberCommandParams {\n  memberId?: string\n}\nexport interface MemberCommandWithVolumeParams extends MemberCommandParams {\n  volume: number\n}\nexport interface MemberCommandWithValueParams extends MemberCommandParams {\n  value: number\n}\n\nexport interface BaseRoomInterface {\n  join(): Promise<unknown>\n  leave(): Promise<unknown>\n}\n\nexport interface LocalOverlay {\n  mirrored: boolean\n  setMirrored(mirror: boolean): void\n}\n\ninterface RoomMemberSelfMethodsInterface {\n  /**\n   * Puts the microphone on mute. The other participants will not hear audio\n   * from the muted device anymore.\n   *\n   * @permissions\n   *  - `room.self.audio_mute`\n   *\n   * You need to specify the permissions when [creating the Video Room\n   * Token](https://developer.signalwire.com/apis/reference/create_room_token)\n   * on the server side.\n   *\n   * @example Muting the microphone:\n   * ```typescript\n   * await roomdevice.audioMute()\n   * ```\n   */\n  audioMute(): Rooms.AudioMuteMember\n\n  /**\n   * Unmutes the microphone if it had been previously muted.\n   *\n   * @permissions\n   *  - `room.self.audio_unmute`\n   *\n   * You need to specify the permissions when [creating the Video Room\n   * Token](https://developer.signalwire.com/apis/reference/create_room_token)\n   * on the server side.\n   *\n   * @example Unmuting the microphone:\n   * ```typescript\n   * await roomdevice.audioUnmute()\n   * ```\n   */\n  audioUnmute(): Rooms.AudioUnmuteMember\n\n  /**\n   * Puts the video on mute. Participants will see a mute image instead of the\n   * video stream.\n   *\n   * @permissions\n   *  - `room.self.video_mute`\n   *\n   * You need to specify the permissions when [creating the Video Room\n   * Token](https://developer.signalwire.com/apis/reference/create_room_token)\n   * on the server side.\n   *\n   * @example Muting the camera:\n   * ```typescript\n   * await roomdevice.videoMute()\n   * ```\n   */\n  videoMute(): Rooms.VideoMuteMember\n\n  /**\n   * Unmutes the video if it had been previously muted. Participants will start\n   * seeing the video stream again.\n   *\n   * @permissions\n   *  - `room.self.video_unmute`\n   *\n   * You need to specify the permissions when [creating the Video Room\n   * Token](https://developer.signalwire.com/apis/reference/create_room_token)\n   * on the server side.\n   *\n   * @example Unmuting the camera:\n   * ```typescript\n   * await roomdevice.videoUnmute()\n   * ```\n   */\n  videoUnmute(): Rooms.VideoUnmuteMember\n\n  /**\n   * @deprecated Use {@link setInputVolume} instead.\n   */\n  setMicrophoneVolume(params: { volume: number }): Rooms.SetInputVolumeMember\n\n  /**\n   * Sets the input volume level (e.g. for the microphone).\n   * @param params\n   * @param params.volume desired volume. Values range from -50 to 50, with a\n   * default of 0.\n   *\n   * @permissions\n   *  - `room.self.set_input_volume`\n   *\n   * You need to specify the permissions when [creating the Video Room\n   * Token](https://developer.signalwire.com/apis/reference/create_room_token)\n   * on the server side.\n   *\n   * @example\n   * ```typescript\n   * await roomdevice.setMicrophoneVolume({volume: -10})\n   * ```\n   */\n  setInputVolume(params: { volume: number }): Rooms.SetInputVolumeMember\n\n  /**\n   * Sets the input level at which the participant is identified as currently\n   * speaking.\n   * @param params\n   * @param params.value desired sensitivity. The default value is 30 and the\n   * scale goes from 0 (lowest sensitivity, essentially muted) to 100 (highest\n   * sensitivity).\n   *\n   * @permissions\n   *  - `room.self.set_input_sensitivity`\n   *\n   * You need to specify the permissions when [creating the Video Room\n   * Token](https://developer.signalwire.com/apis/reference/create_room_token)\n   * on the server side.\n   *\n   * @example\n   * ```typescript\n   * await roomdevice.setInputSensitivity({value: 80})\n   * ```\n   */\n  setInputSensitivity(params: {\n    value: number\n  }): Rooms.SetInputSensitivityMember\n}\n\n/**\n * We are using these interfaces in combination of\n * Object.defineProperties() to avoid code duplication and\n * expose a nice documentation via TypeDoc. The interface\n * forces TS checking while Object.defineProperties allow us\n * flexibility across different objects.\n */\nexport interface RoomMethods\n  extends OnlyFunctionProperties<VideoRoomSessionContract> {\n  /** @deprecated Use {@link setVideoMuted} instead */\n  hideVideoMuted(): Rooms.HideVideoMuted\n  /** @deprecated Use {@link setVideoMuted} instead */\n  showVideoMuted(): Rooms.ShowVideoMuted\n}\n\nexport interface RoomSessionConnectionContract {\n  screenShareList: RoomSessionScreenShare[]\n  deviceList: RoomSessionDevice[]\n  localOverlay: LocalOverlay\n  interactivityMode: VideoAuthorization['join_as']\n  permissions: VideoAuthorization['scopes']\n  /**\n   * Adds a screen sharing instance to the room. You can create multiple screen\n   * sharing instances and add all of them to the room.\n   * @param opts - {@link CreateScreenShareObjectOptions}\n   * @returns - {@link RoomSessionScreenShare}\n   *\n   * @deprecated Use {@link startScreenShare} instead.\n   */\n  createScreenShareObject(\n    opts?: CreateScreenShareObjectOptions\n  ): Promise<RoomSessionScreenShare>\n  /**\n   * Adds a screen sharing instance to the room. You can create multiple screen\n   * sharing instances and add all of them to the room.\n   * @param opts - {@link StartScreenShareOptions}\n   * @returns - {@link RoomSessionScreenShare}\n   *\n   * @example Sharing the screen together with the associated audio:\n   * ```js\n   * await roomSession.startScreenShare({ audio: true, video: true })\n   * ```\n   */\n  startScreenShare(\n    opts?: StartScreenShareOptions\n  ): Promise<RoomSessionScreenShare>\n  /**\n   * Adds a camera device to the room. Using this method, a user can stream\n   * multiple video sources at the same time.\n   *\n   * @param opts - Specify the constraints for the device. In addition, you can\n   * add the `autoJoin` key to specify whether the device should immediately\n   * join the room or joining will be performed manually later. {@link AddCameraOptions}\n   * @returns - {@link RoomSessionDevice}\n   *\n   * @example Adding a specific camera:\n   * ```typescript\n   * await roomSession.addCamera({deviceId: \"gOtMHwZdoA6wMlAnhbfTmeRgPAsqa7iw1OwgKYtbTLA=\"})\n   * ```\n   */\n  addCamera(opts: AddCameraOptions): Promise<RoomSessionDevice>\n  /**\n   * Adds a microphone device to the room. Using this method, a user can stream\n   * multiple video sources at the same time.\n   *\n   * @param opts Specify the constraints for the device. In addition, you can\n   * add the `autoJoin` key to specify whether the device should immediately\n   * join the room or joining will be performed manually later. {@link AddMicrophoneOptions}\n   * @returns - {@link RoomSessionDevice}\n   *\n   * @example Adding a specific microphone:\n   * ```typescript\n   * await roomSession.addMicrophone({deviceId: \"PIn/IIDDgBUHzJkhRncv1m85hX1gC67xYIgJvvThB3Q=\"})\n   * ```\n   */\n  addMicrophone(opts: AddMicrophoneOptions): Promise<RoomSessionDevice>\n  /**\n   * Adds a device to the room. Using this method, a user can stream multiple\n   * sources at the same time. If you need to add a camera device or a\n   * microphone device, you can alternatively use the more specific methods\n   * {@link addCamera} and {@link addMicrophone}.\n   *\n   * @param opts Specify the constraints for the device. In addition, you can\n   * add the `autoJoin` key to specify whether the device should immediately\n   * join the room or joining will be performed manually later. {@link AddDeviceOptions}\n   * @returns - {@link RoomSessionDevice}\n   *\n   * @example Adding any of the microphone devices to the room (duplicate\n   * streams are possible):\n   * ```typescript\n   * await roomSession.addDevice({audio: true})\n   * ```\n   */\n  addDevice(opts: AddDeviceOptions): Promise<RoomSessionDevice>\n  /**\n   * Replaces the current speaker with a different one.\n   *\n   * > \uD83D\uDCD8\n   * > Some browsers do not support output device selection. You can check by calling {@link WebRTC.supportsMediaOutput}.\n   *\n   * @param opts\n   * @param opts.deviceId id of the new speaker device\n   *\n   * @example Replaces the current speaker:\n   * ```typescript\n   * await room.updateSpeaker({deviceId: \"/o4ZeWzroh+8q0Ds/CFfmn9XpqaHzmW3L/5ZBC22CRg=\"})\n   * ```\n   */\n  updateSpeaker(opts: { deviceId: string }): Promise<undefined>\n}\n\nexport interface RoomSessionDeviceMethods\n  extends RoomMemberSelfMethodsInterface {}\n\nexport interface RoomScreenShareMethods\n  extends RoomMemberSelfMethodsInterface {}\n\nexport interface BaseRoomSessionJoinParams {\n  audio?: MediaStreamConstraints['audio']\n  video?: MediaStreamConstraints['video']\n  receiveAudio?: boolean\n  receiveVideo?: boolean\n  sendAudio?: boolean\n  sendVideo?: boolean\n}\n\nexport type PagingCursor =\n  | {\n      before: string\n      after?: never\n    }\n  | {\n      before?: never\n      after: string\n    }\n", "import type {\n  PubSubContract,\n  ConsumerContract,\n  UserOptions,\n  PubSub as PubSubNamespace,\n} from '@signalwire/core'\nimport { createClient } from '../createClient'\n\nexport interface ClientApiEvents extends PubSubNamespace.BasePubSubApiEvents {}\n\n/** @ignore */\nexport interface ClientFullState extends Client {}\nexport interface Client\n  extends PubSubContract,\n    Omit<ConsumerContract<ClientApiEvents, ClientFullState>, 'subscribe'> {}\n\n/** @ignore */\nexport interface ClientOptions extends UserOptions {}\n\ntype ClientMethods = keyof Client\nconst INTERCEPTED_METHODS: ClientMethods[] = [\n  'getAllowedChannels',\n  'subscribe',\n  'publish',\n]\n\n/**\n * You can use the Client object to build a messaging system into the browser.\n *\n * Example usage:\n *\n * ```js\n * import { PubSub } from '@signalwire/js'\n *\n * const pubSubClient = new PubSub.Client({\n *   token: '<your pubSub token>', // get this from the REST APIs\n * })\n *\n * await pubSubClient.subscribe([ 'mychannel1', 'mychannel2' ])\n *\n * pubSubClient.on('message', (message) => {\n *   console.log(\"Received\", message.content,\n *               \"on\", message.channel,\n *               \"at\", message.publishedAt)\n * })\n *\n * await pubSubClient.publish({\n *   channel: 'mychannel1',\n *   content: 'hello world'\n * })\n * ```\n *\n * ## Events\n *\n * Please see {@link ClientApiEvents} for the list of events emitted by a pubSub\n * Client object.\n */\nexport const Client = function (pubSubOptions: ClientOptions) {\n  const client = createClient<Client>(pubSubOptions)\n\n  const createInterceptor = <K extends keyof Client>(prop: K) => {\n    return async (...params: Parameters<Client[K]>) => {\n      await client.connect()\n\n      // @ts-expect-error\n      return client.pubSub[prop](...params)\n    }\n  }\n\n  const interceptors = {\n    _session: client,\n    disconnect: () => client.disconnect(),\n  } as const\n\n  return new Proxy<Client>(client.pubSub, {\n    get(target: Client, prop: keyof Client, receiver: any) {\n      if (prop in interceptors) {\n        // @ts-expect-error\n        return interceptors[prop]\n      }\n\n      if (INTERCEPTED_METHODS.includes(prop)) {\n        return createInterceptor(prop)\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n  })\n  // For consistency with other constructors we'll make TS force the use of `new`\n} as unknown as { new (pubSubOptions: ClientOptions): Client }\n", "export {\n  getDevices,\n  getCameraDevices,\n  getMicrophoneDevices,\n  getSpeakerDevices,\n  getDevicesWithPermissions,\n  getCameraDevicesWithPermissions,\n  getMicrophoneDevicesWithPermissions,\n  getSpeakerDevicesWithPermissions,\n  checkPermissions,\n  checkCameraPermissions,\n  checkMicrophonePermissions,\n  checkSpeakerPermissions,\n  requestPermissions,\n  createDeviceWatcher,\n  createCameraDeviceWatcher,\n  createMicrophoneDeviceWatcher,\n  createSpeakerDeviceWatcher,\n  supportsMediaDevices,\n  supportsGetUserMedia,\n  supportsGetDisplayMedia,\n  getUserMedia,\n  getDisplayMedia,\n  enumerateDevices,\n  getSupportedConstraints,\n  supportsMediaOutput,\n  setMediaElementSinkId,\n  stopStream,\n  stopTrack,\n  createMicrophoneAnalyzer,\n} from '@signalwire/webrtc'\n"],
  "mappings": "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",
  "names": []
}
